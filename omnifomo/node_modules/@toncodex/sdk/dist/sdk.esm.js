import JSBI from 'jsbi';
import invariant from 'tiny-invariant';
import { Address, Cell, Dictionary, beginCell, contractAddress, SendMode, toNano } from '@ton/core';
import _Big from 'big.js';
import toFormat from 'toformat';
import _Decimal from 'decimal.js-light';
import { sha256_sync, sign } from '@ton/crypto';
import { Address as Address$1, WalletContractV5R1, WalletContractV4, WalletContractV3R2, WalletContractV3R1, beginCell as beginCell$1, storeMessage, external, SendMode as SendMode$1, internal, toNano as toNano$1 } from '@ton/ton';
import { crc32 } from 'crc';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/**
 * This tick data provider does not know how to fetch any tick data. It throws whenever it is required. Useful if you
 * do not need to load tick data for your use case.
 */
var NoTickDataProvider = /*#__PURE__*/function () {
  function NoTickDataProvider() {}
  var _proto = NoTickDataProvider.prototype;
  _proto.getTick = /*#__PURE__*/function () {
    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_tick) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getTick(_x) {
      return _getTick.apply(this, arguments);
    }
    return getTick;
  }();
  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
      return _nextInitializedTickWithinOneWord.apply(this, arguments);
    }
    return nextInitializedTickWithinOneWord;
  }();
  return NoTickDataProvider;
}();
NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';

var ADDRESS_ZERO = '0:0000000000000000000000000000000000000000000000000000000000000000';
var BLACK_HOLE_ADDRESS = /*#__PURE__*/Address.parse(ADDRESS_ZERO);
var FEE_DENOMINATOR = 10000;
var IMPOSSIBLE_FEE = FEE_DENOMINATOR + 1;
var INITIAL_POOL_FEE = 100;
var DEFAULT_TICK_SPACING = 60;

// constants used internally but not expected to be used externally
var NEGATIVE_ONE = /*#__PURE__*/JSBI.BigInt(-1);
var ZERO = /*#__PURE__*/JSBI.BigInt(0);
var ONE = /*#__PURE__*/JSBI.BigInt(1);
// used in liquidity amount math
var Q96 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(96));
var Q192 = /*#__PURE__*/JSBI.exponentiate(Q96, /*#__PURE__*/JSBI.BigInt(2));
var MaxUint256 = /*#__PURE__*/JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

var ROUTER = 'EQC_-t0nCnOFMdp7E7qPxAOCbCWGFz-e3pwxb6tTvFmshjt5';
var POOL_FACTORY = 'EQDiNOe3qNffbCsEeX-6KYWT26TT1xL7D-dqx47-qqEkp4e9';
var pTON_MINTER = 'EQCUnExmdgwAKADi-j2KPKThyQqTc7U650cgM0g78UzZXn9J';
var pTON_ROUTER_WALLET = 'EQCHHakhWxSQIWbw6ioW21YnjVKBCDd_gVjF9Mz9_dIuFy23';

var INIT_CODE_BASE64 = {
  router: 'te6cckECKgEACeQAART/APSkE/S88sgLAQIBYgIeAgLLAxsCAUgEGgTj0QY4BJL4JwAOhpgYC42EkvgnB2omh9IAD8MP0gAPwxfSAA/DHpn4D8MumfgPwyagDoagD8M2oA/DPqGHw0ahh8NP0gGADpj+mfkUEIFxgad91xgRFBCFDtVLbdcYEaEMEIObFoTl1xgRgQQQhqb1gd3UBQkNFAP+MjMzAvpA+kDTF9Of0wDTD9MP0w/U1NQw0PpA+kD6QDD4QS/HBfhCVhDHBbH4QwEREMcFUvCx8uBv+Eb4R/hIEE8QPiT5AST5Ab8gwgCOhhA1RETbPI6HEDRFVds8EuJwIMjLART0APQAEssAyQEhcAH5AHTIywISygfL/8nQIScnBgH+wwDy4HABwgCayFADzxZQDM8WyZrIUA3PFljPFskb4irXScICkXGRcOL4RHFUcAAgAREUAbCCEEQcOe3Iyx8BERMByz8BERIBywABERIBywD4Qs8WE8sAUA3PFh7LABrLFx3LABfLnxrLABTLABLLD8sPyw8VzBTME/QAEss/yQcBZnBVIIBA2zz4RKT4ZPhJ+Ej4R/hGyMzMzMn4RPhFyPhBzxb4Qs8W+EPPFss/yz/MzMntVAgALneAGMjLBVAFzxZQBfoCE8trzMzJAfsAA/YyNPpA+kDTH9M/MdMAAcAAkl8H4NQw0PoA+kD6APpAcG0hbSTHArP4RXGwwwCwjhBfBNQw0PoA9AT6APQEMFUgkTTi+Eb4R/hIKVE4QTMk+QEk+QG/IMIAjoYQNURE2zyOhxA0RVXbPBLicCDIywEU9AD0ABLLAMkBMHAnJwoCyAH5AHTIywISygfL/8nQLMcF+EWDC7D4QVAOxwUdsByx8uBvcCCAQCnCACjCALCOHF8DC4IIcQ1ooSGhKqEgqwBSIKABqwBSsKBwTd2RPuIowgCXEFsQSDdfBeMNIMIAkl8J4w0LDAFmLgRJw3CCEA+KfqXIyx8Wyz9QA/oCIc8WAc8WE8sAAfoC9ABSYMsfySpysRA2ECXbPEFQEwFeEEgQNlCCcIIQD4p+pcjLHxbLP1AD+gIhzxYBzxYTywAB+gL0ABLLH8kCcrES2zwTAnAxMwH6APpAIsIA8uBuIMcCkl8F4NQw0CDHAZJfBeDTH/pAIoIQp/tY+LrjAgKCEERo3ne64wJfBg4QA/xsItOf+gD6QIsCcG0hbQX0BDAgbrP4RXGwwwCwnmxR0PpA+gDU+gDUMFUwkTDi+Eb4R/hILQQMVSAk+QEk+QG/IMIAjoYQNURE2zyOhxA0RVXbPBLicCDIywEU9AD0ABLLAMkBMHAB+QB0yMsCEsoHy//J0MhQBM8WWPoC9AAnJw8BZFAG+gL0AMnIUAb6AhPLnwH6AsmCEKf7WPjIyx8Wyz8BzxZQA88WE8wSzHAByRKAQNs8EwT+AfoA+gDTf9IX0hcw+Eb4R/hIK1E5QTMk+QEk+QG/IMIAjoYQNURE2zyOhxA0RVXbPBLicCDIywEU9AD0ABLLAMkBMHAB+QB0yMsCEsoHy//J0IIQRGjed8jLHxvLP1AHzxYI+QEF+QEVvJ5QZfoCcPoCAfoCUAT6AuMOEst/EicnERIAJAZw+gJQBfoCUAT6AlAD+gIQIwEYyhfKF3AByRKAQNs8EwAscYAYyMsFUATPFlAE+gISy2rMyQH7AAT+4wIgghCYusQFuo7gE18D+EEBxwXy4G/wFiXDAI4XI8MAJPgjubCdMzQC+GFwiwJUFAREQ97eIsMAjhEgwwAh+CO5sJcwMfhlcFMA3t4owwCOFybDACf4I7mwnTY3BfsEcMjJVBcHR3be3vAX4CCCEEKg+0O64wIzIoIQh//jYxUWFxkB/jAy+EFYxwXy4G/TAPpA0wDTP/QEMPAWKYEBLLYJD44ZbDMq1wsBwACVOnCLAiGXf/gjLaBBwOJVEpE94gucMDk5f/gjK6BQqggJkTniJ26zjh9sMyTQ10sBwAABwACwlTQ3cG0hmH/4I1AKoElQ4lUCkjc64hBJEDhHFUZj8BcWAE74SfhI+Ef4RsjMzMzJ+ET4Rcj4Qc8W+ELPFvhDzxbLP8s/zMzJ7VQBPjAx+EEBxwXy4G8gggo0k0C88uBxggo0k0Ch+EFw2zwYAChwgBjIywVQA88WUAP6AstqyQH7AAC4uo5LMvhBWMcF8uBv0wD6QNMA+kAwA8MAkwH4Y5Ex4sMAkvhikTDi+En4SPhH+EbIzMzMyfhE+EXI+EHPFvhCzxb4Q88Wyz/LP8zMye1U4FuCENUydtu63IQP8vAASdOEARRw6A6YOA1QOJWTxPkEGHWEtVAECIENlJVQBxckIH2HIYwCAnMcHQC1PhJ0NM/9AT0BPQEMHBtUxRus5xfAwLQfwHU0z8wRESRNeJwiwJTFW6znV8DA9B/AfpA0z8wRVWRNuJwVHAFbrOdXwME0H8B0z/TPzBGZpE34hBYXiQQNUEEA4ABpAKWyMs/yz/Jkltt4gOXyFjPFss/yZJbbeIElgLIzMs/yZNsIW3iA8jLPxP0APQA9ADJ+GmACAVgfIgIBICAhAHe2hf2omh9IAD8MP0gAPwxfSAA/DHpn4D8MumfgPwyagDoagD8M2oA/DPqGHw0ahh8NPwg/CF8Ifwi/CJABb7ZlPaiaH0gAPww/SAA/DF9IAD8MemfgPwy6Z+A/DJqAOhqAPwzagD8M+oYfDRqGHw0/CP8JG2eQJwIBWCMmAgEgJCUAb69c9qJofSAA/DD9IAD8MX0gAPwx6Z+A/DLpn4D8MmoA6GoA/DNqAPwz6hh8NGoYfDT8I3wj/CRAAuWsYXaiaH0gAPww/SAA/DF9IAD8MemfgPwy6Z+A/DJqAOhqAPwzagD8M+oYfDRqGHw0/CN8I/wkEnyAknyA35BhAEdDCBqiIm2eR0OIGiKq7Z4JcTgQZGWAinoAegAJZYBkgJg4APyAOmRlgQllA+X/5OhAJycCx7Gr+1E0PpAAfhh+kAB+GL6QAH4Y9M/Afhl0z8B+GTUAdDUAfhm1AH4Z9Qw+GjUMPhp+Eb4R/hIJPkBJPkBvyDCAI6GEDVERNs8jocQNEVV2zwS4nAgyMsBFPQA9AASywDJATCAnJwP2+CjIycjJBMjME8wTzMzJbcj0AMnIjQhgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEzxaNCGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATPFsnIgQHRz0CJzxaJzxbMyciBAwjPQMlwcYAeKCgpAEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAEpTAMhQCs8WGcsPGMsPF8sPUAjPFlAGzxYUyxcVyz8TzMwSzMzJ+Vn2Pg==',
  pool: 'te6cckECgwEAGa8AART/APSkE/S88sgLAQIBYgJiAgLKAy4CASAELQIBSAUsAgEgBisE90IMcAkl8E4AHQ0wMBcbCSXwTg2zz6QDAB0x/4V40IYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMcFsyKCEEQcOe26jpgyMzP4RvkB+Ef5Abzy4GshxwCzkl8D4w3g8uBlIYIQBedGl7rjAiGCEDIFrb26iBBwoLAf4B0z8x0wDTAPpA0wD6QNMA0xfTANOf0wDTANMP0w/TD9TU9AQw+EJWEgHHBfhXVhMBxwWx8uBSERDAAAEREgGw8tBSDZML+HeRO+IJkwf4eJE34inQxwCzkwn4fpE54ivQxwCzkwv4f5E74ihus5wI0PpAAfh5+kAw+HqROOICCAL8wwCS+GiRMOIHwwCTA/hwkTPiIoEnELuTAvhkkTLiIYEnELuTAfhjkTHiIIEnELuS+GWRMOICwAH4VsAAsI6uIYIRAAJ2o77y4F0hgpD//Ylj79H8alBkiEldlR1SY5iNJrny4F4h+HIB2zz4cZEx4vhJghDVMnbbyMsfyz/JUwkCIPhJpPhp2zyCCC3GwFlw2zwpKAJkECRfBPhXUhDHBfhYUiDHBbHy4FJw+HD4SYIQ1TJ228jLH8s/yfhJpPhp2zxwWYBA2zwpKASOjzIQJF8E+FdSEMcF+FhSIMcFsfLgUnH4cPhJghDVMnbbyMsfyz/J+Emk+GnbPHBZgEDbPOAhghBr3L64uuMCIYIQUwtfLLopKAwNAqYxbCL4V1IgxwX4WFIwxwWx8uBS0z8x0w/TD9MPMCKBJxC7IoEnELuwIYEnELuw8uBVAvhk+GP4ZfhJghDVMnbbyMsfyz/J+Emk+GnbPHBZgEDbPCkoBDzjAiGCEERo3ne64wIhghDT+KU4uuMCIYIQQqD7Q7oOEBESAfwxbCLTP9M/03/SF9IXMPhVUkC+8tBn+Cj4XW1wyMsH9ADJQTAWUDNwBMiDCM9AyQLIyz8jzxZQA88WEsyBALDPQMzJIsjLARL0APQAywDJcAH5AHTIywISygfL/8nQ+FH4SvhLJFE3QTPwIgHIy//L/8mCEEbKM1rIyx8Wyz8PASZQBs8WEst/yhfKF8zJcFmAQNs8KAH8MWwi0z/6QPoA+gD6APoA03/SF9IXMPhCGscF8uBS+Cj4XBAoAnACyIAQz0DJyFADzxYBzxbMySHIywET9AAS9ADLAMkgcAH5AHTIywISygfL/8nQghA+vlQxyMsfGcs/UAb6AlAE+gJY+gIB+gLLfxLKFxPKF8lwUDOAQNs8IALkMWwi0z8w+FcSxwXy4FL4TPhNcPhscPhtIcIAIcIAsY7LyCL6AvhGzxYh+gL4R88WyXBx+EmBAMuCEKHaqW3Iyx8Yyz/4V88W+FfPFhfLHxbLPxXLABTLABPMAvAycPhCAskSgEDbPPhJpPhpkl8D4ts8KCkEjo6rECNfA4IQCPDRgIIQEBffgPhUqIBkqQSg+FdYxwXy4FJcvPLgU6H4V3DbPOAhghDXOsCduuMC+FDAAOMCNCCCEIFwLvi6ExQXGwAocIAYyMsFUAPPFlAD+gLLaskB+wAC/DFsItM/+kDTP9N/0hfSF9N/1DDQ0//T/zD4KPhdbXDIywf0AMlSkFAzcATIgwjPQMkCyMs/I88WUAPPFhLMgQCwz0DMySLIywES9AD0AMsAyXAB+QB0yMsCEsoHy//J0BrHBfLgZ3BTAqMmVEYwVElu8DEkwgCRM+MNoFCZoBUWAC4yOlR0MfAtIMAA8vRUZmXwLjCjAqNQKgLa+FEGyMs/UiDLfxTKFxLKFxTKF8nIJ/oC+EbPFiL6AvhHzxbJcSD4SYEAyYIQodqpbcjLHxvLPynPFlAJzxYZyx8Xyz8XywAVywAVzBPMUEPwMnD4QgPJQTCAQNs8+Emk+GkBupX4VqX4dt7bPCgpAhxEMGwhIYIQgXAu+LrjDxgaAf4x0z/6APoA+kAw+Cj4XCJZAnACyIAQz0DJyFADzxYBzxbMySHIywET9AAS9ADLAMlwAfkAdMjLAhLKB8v/ydAVxwXy4FLIWPoC+EbPFgH6AvhHzxbJcHEhgGaCEKHaqW3Iyx8Wyz8mzxZQBs8WFMsfFMs/EssAEssAzHD4QgLJGQEKEoBA2zwoAfIBghCn+1j4uo7p0z/6QPpA1DDQ+gAw+EJSUMcF8uBScCD4RlJAxwWSMTKb+EcUxwWSbBKRMeLiyAH6AvhGzxYB+gL4R88WyXBxIYBmghCh2qltyMsfF8s/Jc8WUAXPFhXLHxPLPxPLAMsAzHAByRKAQNs84FuED/LwKAIi4wKCEKf7WPi64wJfA4QP8vAcIwH8MDEB0z/6APoA+kDTf9IX0hcw+Cj4XCVZAnACyIAQz0DJyFADzxYBzxbMySHIywET9AAS9ADLAMlwAfkAdMjLAhLKB8v/ydAYxwXy4FJTQ/AzghAI8NGAghAQF9+A+FSogGSpBKCBIjipBHT7AlRwYfAtJMAAlDCBAOLeUye8HQSOUye8sZkgwACUMIEA4d7eIMAAjo8wVHKD8C4gwACTOV8E4w2TOV8E4iLCACLCALGOlDRbghDVMnbbyMsfyz/JcFmDBts84w0eKCEiAfxRcqFRYaH4UfhK+EsmUT1BM/Ai+Cj4XfhVbXDIywf0AMlQM3AEyIMIz0DJAsjLPyPPFlADzxYSzIEAsM9AzMkiyMsBEvQA9ADLAMkgcAH5AHTIywISygfL/8nQ+FH4VQXIy/8Uy/8Uyz9QBvoCUAT6AhPKF8n4SYIQ1ezKKsgfAWbLH1Kwyz8ozxYXy38VyhcayhcUyz8SzMmCCfeKQFUgcNs8+Emk+Gn4VaT4dfhWpPh2QUAgAC53gBjIywVQBc8WUAX6AhPLa8zMyQH7AAGMyCP6AvhGzxYi+gL4R88WyXBx+EmCEKHaqW3Iyx8Yyz8kzxZQBM8WF8sfFcs/ywAUywASzALwMvhJpPhpcPhCAskSgwbbPCgBBNs8KQH8AtM/+kD6QNQB0PoA05/6ADAD1DDQ+kD6APQE+gD0BDAk1wsBwACTNCgE3vhCUtDHBfLgUnL4RlKgxwWXMDglcPAzcZ/4RxrHBZc4cCbwM3AI3gjiIMAC8tBWgQDI8BAMqg/4QW8TqQRTQqCqD/hBbxOpBIIIBAWwoKH4QW8SJAL8gXUwobYIcFReAC5UTjAsVEswK1RLMCsCVhNUTDBWGFntRO1F7UefMSDAYJUwMoEA5pPy8ALi7WftZe1kgA1/7RGOLFRnIBjwMAGjAaMmmFIJuZPywGDemFIZuZPywGDe4hCrEJoQaRBIEDdGBUMT7UHt8QHy/yOUUCmgAeMNJSYABAmgAfyCEAjw0YCCEBAX34D4VKiAZKkEoIEiOKkEdPsC+Ev4SvhR+FL4U8jLf8ufyhfL/8v/ySORJpEk4iSRN5M1EEbiyCSRJpEo4voCFfQAA5E0kzYQNeIF+gIT9ADJyCL6AvhGzxYk+gL4R88WzMlxIPhJghCh2qltyMsfG8s/UAknAk7PFlAGzxYWyx8Xyz8VywASywASzBLMyVnwMnBZgwbbPPhJpPhp2zwoKQAscYAYyMsFUATPFlAE+gISy2rMyQH7AAH0+F/4Xvhd+FzIzMzMzMn4W8j0AMnI+FnPFvhazxbJ+Fb4VfhU+FP4UvhR+FDIywDKF8ufy3/LF8s/yz/4V88W+FjPFszJ+E34TPhL+ErIy//L/8t/y3/4TvoC+E/6Asn4SfhI+EX4RPhDyPhCzxbLD8sPyw/4Rs8W+EcqABrPFssXyz/MzMzMye1UAG9CDEmDCLNuYW6M8WjiltIcEAmYAtUAPLBwGjWN6cAXqpDKYwWG8CIcAA5jGYbyICywchbhLmMOKABJ04QBFHDoDpg4DVA4lZPE+QQYdYS1UAQIgQ2UlVAHFyQgfYchjACt0cFRwAG8E+GH4Lm8T0weVIYEA0bqOGTH4QQHTP1lwb4X4YfhBAdM/WXFvhfhh0wfoIYEA3roCgQDduhKxjhb4QQHTP1lzb4X4YfhBAdM/WXJvhfhh3jCAgEgL0oCASAwOwIBIDE0AgEgMjMAP1gg/ydhghqQYhqIIIDYnoIqkEIqgBoQGpBKSEfwGpBIAMFCT4W4AY9AxvoZrT/9J/0//T/zBxljBwVHAAIOIwbCIl+FuAGPQMb6Ga0//Sf9P/0/8wcZYwcFRwACDiMGwiUmm+l1JDoVIyoVjfUFa5mFIloVIWoQUE3xKhUAOhWaFYoYAgEgNTgCASA2NwBNF28khAj3gGqX1MjoSTCAPLgXQKbAqmMwgCRpN4BqQbgAqmEAakEgADEXbySECPemwKhg1+pjMIAkaTe4AKhqbRfgAgEgOToAHQgwQCVo3DwJKOTcfAk4oAAdCDBAJWjcPAlo5Nx8CXigAgEgPEMCASA9QAIBID4/ANs7aLt+yHAAJJfA+ACql9TE7eoA441IsSzjhRSA6BTAr6bMRKpjMIAkaTe2zHgMJEy4lITqQRYt6AgxLPy4FqpBiC2A4EAoLvy4FrgMSHEs/LgWlMBvPLgWlICoRKpjMIAkaTeILYDgQCgu/LgWoAB3I4Xg19Yt6mEIMSz8uBaoCC2A4EAoLvy4Frgg19Yt6mMIcSz8uBawwCRpN5cvPLgWqEgtgOBAKC78uBagAgEgQUIAKQjwgDy4F0iwgDy4FCTcfAo4HHwKYAApCPCAPLgXSLCAPLgUJNw8CngcPAogAgEgREcE01cFRwMr6VbDKBANzgJIIP8nYYuZVsMoEA3OAjgggNiei8lWwygQDd4PhIUlCpCMMAlWwygQDe4PhIUkCpCMMAlWwygQDe4PhRJbmPCzEj2zwj2zwj8CYB3vhRUlC7+FElubDjAPhRUkC7hVVUVGAiJb+FIi2zwi8CYj2zz4UiPwJ1VVAiiPCzAD2zwC2zwB8CcBkzRsIeIBcFVVAfdFMhufLgWyKCD/J2GL7y4FshgggNiei78uBcIMMA8uBQIvhbgBj0DG+hmtP/0n/T/9P/MHGWMHBUcAAg4ib4W4AY9AxvoZrT/9J/0//T/zBxljBwVHAAIOJRiqBROqFRmqBRSqD4SPAhU1C8UiK8sZVfDYEA4OD4VIFOIISAHuvpVfDYEA3+D4UVLQu/hRLbmwl/hTUAug+HOROuIjwACOFDU1W/hbGIAY9Fow+Hv4VFAHofh0jiNQZQPIy/8Syn/L/8v/+FtBkIAY9EL4e/hUB5FwkXHiF6D4dOIjwACOExNfAzL4W4AY9Fow+Hv4VAGh+HTjDnBJAEJQBQPIy/8Syn/L/8v/+FsSgBj0Qvh7+FQBkXCRceKg+HQCAWJLXwIBIExeAvc7aLt+3BTA8MA8uBXJY4XI4IRAAJ2o7zy4F34UlJAvpRsQtsx4FuOJyOCkP/9iWPv0fxqUGSISV2VHVJjmI0mufLgXvhSUkC7lGxC2zHgW+IicPhS+FEi+FMpkvhKkvhL4p0mwwBTWb2w+AdSkLywiug3Nwb4cwH4cvhxgTV0D8FNKmvhbUlCAGPR7b6Wa+FtSUIAY9HhvpeIgs44QMS2Vgg/ydhiVgggNiejiAd4h2zwvlFMNtgmUUw22COL4RSgQPFLi2zxRIqAeoVDNofhEwgCOEfhEUsCogScQqQRRzKFQnKAI3ifCAJhRt6nUfxagBZE74lIKulVOUgPqU0O+IsL/cFMBjioxgScQJKFSUIEnEKmEI5ZUd4Zx8CSWVHh2cfAl4ly+kjEnllRpgybwKuKOJDAil1R2cFKA8CWXVHdgUoDwJOIloyG+kSeYJaNUaYAm8CviEuJTgLoF4w8gsySjUoC8sJQ2IqMG3lIWvRWwT1BRAEIksySzsZgxVHCGcfAkAd4EsyOxmTFUQoZw8CUGBJI2N+IAQCSzJLOxmDFUeAZx8CUB3gSzI7GYMVQnJnDwJAaSNjfiAC6TMCGhnzGBJxAhoSJZqYzDAJGk3uJBMAHqjmEzNgGOUiuRIZL4SuIskvhLkSLiJlUgcFRwACbHALOfXwQC0//Sf9P/0/8wBVUgkTbiFKFQJKFUEgFQRAPIy/8Syn/L/8v/+FtBMIAY9EL4eyuRo94SoAGRMOIqkgOlkQPijo5fA1JQvY6FMyPbPAPeA+IDUwHyIIIRAAJ2o77y4F0ggpD//Ylj79H8alBkiEldlR1SY5iNJrny4F4gqh8gIMEBkjB/k7YDpeIggwa+lSCmgRKtloB/IaESrOIBpoCqP3CTIMEOjhVRIKirfiCrf4A/JKFSEKwTsQKtAqToMDGCQDYnowHXEFV3TIWoIFQBeIJqj2SBq38EWlrwEqGdADqqoat/AYJw2y3wnoGVmoFFXiYHmaBjL6Crf1y6kjAxjoog2zxQA7uRMOAx4lUC9iCCD/J2GL7y4FsggggNiei78uBcUwDBAJMwIKPeIHGwwwCOEoJw//y5M71vrTeqLRYtGllAAZKDf+IhcrDDAI4VgnD/+XJyNz1BMlmkaZBYDiE6qKt/3iF0sMMAjhWCcP/y5Q9fZWky7xI1fPPH/cyoq3/eIXiwwwDjAFZXACqCcP/lysp+EOTmHDYk6qCUHNCoq38B/CGAELDDAI4VgnD/y5hD1g9hWcnbWINckmZEqKt/3iGAILDDAI4VgnD/lztB+pjAgUcuaJbfslTAqKt/3iGAQLDDAI4VgnD/LqFkZslqOEPseLMmtShhqKt/3iGDBrDDAI4VgnD+Xe4EapmiqBHEYfGWnDBTqKt/3iGDB7DDAFgC/I4VgnD8vobHkAqIrtz/yDtHmqOkqKt/3iGDCLDDAI4VgnD5h6clOsQTF28rB0z3gV5UqKt/3iGDCbDDAI4VgnDzOSsIIrcABZQMejmOS3DzqKt/3iGDCrDDAI4VgnDnFZR1osKbdEOynH+m6InZqKt/3iGDC7DDAOMAIYMMsFlaACqCcNCX8739ICK4hFrY95KqWCWoq38C/sMAjhWCcKn3RkYthw/fimXcH5DgYeWoq3/eIYMNsMMAjhWCcHDYaaFW0qG4kLs99iuvMveoq3/eIYMOsMMAjhWCcDG+E1+X0I/ZgSMVBVQvz6aoq3/eIYMPsMMAjhWCcAmqUItbeoThxnfeVPPpm8moq3/eIYMQsMMA4wAhgxFbXAAogmhdavje24EZZpnDKSJe5gSoq38AmLDDAI4TgmAiFuWE9foeqSYEG+3+mKirf94BgxKwwwCOEYJQBIoXA5H33EJETo+iqKt/3gHCAJWE/wGpBN4gqx8BqTgfwACRcJFx4qAAaCWOEQL4aiLCAJf4TFADoPhskTLijhEC+GsiwgCX+E1QA6D4bZEy4uIDwwDA/5GhkqEB4gEAMT4UfhK+EsQRxA28CIEoSGptH9aoViptH+ACASBgYQBNCHC//LgaSDC//LgafhOWKH4bvhPAaH4b/hOwv/y4Gr4T8L/8uBqgADEIcL/8uBpIML/8uBp+E5YoPhu+E8BoPhvgAgEgY3QCASBkbQIBIGVsAgFIZmcBEa2V7Z58JHgQwIECAUhoaQFtpKW2efBR8LgE4AWRACGegZOQoAeeLAOeLZmSQ5GWAifoACXoAZYBkuAD8gDpkZYEJZQPl/+ToYED+aa7tnmhpg5j6AhiQa6TAgFhcya38L/Bpv5jpC+kLmHwv6GmDmPoCGEF4ZII3vRvWh1Pnc5mqzCfSoUTBfFm+R73nZI+9Y40+aIIQwYP6BzfQuADHDJDrpWEARwiQ66ZoEGuk4RBKGOuFj8iYcW9vQQQSpxLdSYovgnGGuGRgWprAObXTNDTH8gyzxbJyMzJcMjLB4sSOM8WUAXwAo0ECBMUCBQb3NpdGlvbjogWyCDPFlAD8AKLQgLT4gjPFgHwAosiBdjPFhLMyXDIywfMgvDJBG96N60Op87nM1WYT6VCiYL4s3yPe87JH3rHGnzRBFiDB/RDAArLB/QAyQFztaWdtF2/e2eEGAAS5h4CHwgt4lvQQBhqFCSIhn4GAHNkVGsXMqtuBBtmPBNkFGsXMqtuBBtmPBxAMIECASBucQIBSG9wAQ2so+2efChAgQEZrpvtnngIfCC3iXgYQIECASBycwGXsej2zz4KPhdbXDIywf0AMlBMFAzcATIgwjPQMkCyMs/I88WUAPPFhLMgQCwz0DMySLIywES9AD0AMsAyXAB+QB0yMsCEsoHy//J0IIEBDbJSds8+FuCBAgEgdXoCASB2dwEVtgt7Z58KvwvfCFCBAgFIeHkBDa90bZ54FsCBAQ2sr22eeBjAgQIBIHt+AgFIfH0B3a6nbZ43gDg3gEcukmAATXwtqThADHo8N9LNfC2pOEAMej030vEQRxscgOn/6T/p/+n/mBRgAEwtkSy3gYk3xkwSKpg3gok3xnEBUhBCA99MGCy3xjeALDhvA1KjMwPJNhDxYAATYABY8xi2ITfGQIEBba9AbZ58IXwr/Cx8I3wj/Cz8LXwofCR8IfwifCL8KPwpfCn8JXwl/CZ8Jvwq/Cd8J/wrfCp8JMCBAgEgf4ABGbGuds8+Fz4Xfhe+F+CBAQ2zq/bPPAiggQH07UTQ+kAB+GLTDwH4Y9MPAfhk0w8B+GX6QAH4ZvpAAfhn0xcB+GjTPwH4adQB0NP/Afhq0/8B+GvTfwH4bNN/Afht+gAB+G76ADD4b9QB0NMAAfhw0hcB+HHTnwH4ctN/Afhz0xcB+HTTPwH4ddM/Afh2+kAB+Hf6QAGCAFT4eNQw0PpAAfh5+kAw+HrUAdD0BDD4e9Qw0NQB+HzUAfh91AH4ftQw+H9bE+Dq',
  account: 'te6cckECDQEAAloAART/APSkE/S88sgLAQIBYgIMAgLNAwsCtddtF2/ZkQ44BJL4HwaGmB9qJofSAA/DD9IAD8MWoYaH0AAPwx/QAA/DJ9AAD8Mv0AGHwzALjYSS+B8H0gGADpj+mf/CEpIGOCyJhxhvwgieOCyS+B8YbCB/l4QEBwLuIoIQPr5UMbqPa2wy+gD6APoA+gDTf9IX0hcw+ENQB6D4Y/hEUAWg+GQC+GX4ZiDCAPhD+EW+sPhE+Ea+sI6yghCBcC74yMsfFMs/+EP6AvhE+gL4Qc8WE8t/EsoXyhfJ+EIB2zxw+GNw+GRw+GVw+GaSXwTi4DAFBgAscYAYyMsFUAPPFnD6AhLLaszJgwb7AABCyPhD+gL4RPoC+EX6AvhG+gLJyPhBzxb4Qs8WzMntVNsxAl4gghBCoPtDuo6YWyCCCJiWgLzy4FOCCJiWgKH4QXDbPNsx4GwSghAL8/RHuuMCMAgJAChwgBjIywVQA88WUAP6AstqyQH7AAHc+EPCAPhEwgCx8uBQgg/ydhiCCA2J6HCCEIFwLvjIyx8Uyz/4Q/oC+ET6AvhBzxYTy38SyhfKF3D4QgLJEoBA2zxw+GNw+GRw+GVw+GbI+EP6AvhE+gL4RfoC+Eb6AsnI+EHPFvhCzxbMye1U2zEKACxxgBjIywVQBM8WUAT6AhLLaszJAfsAAEnThAEUcOgOmDgNUDiVk8T5BBh1hLVQBAiBDZSVUAcXJCB9hyGMAGWgonPaiaH0gAPww/SAA/DFqGGh9AAD8Mf0AAPwyfQAA/DL9ABh8M3wg/CF8IfwifCL8I0lL38n',
  positionnft: 'te6cckECFwEAA3gAART/APSkE/S88sgLAQIBYgIQAgLLAw8CASAEDgIBIAUNAvXRkQ44BJL4HwaGmBgLjYSS+B8H0gfSAY/QAYuOuQ/QAY/QAYOdTaAHgHgWmP6Z+RQQhq9mUVXUcXGi2ZfCEsY4L5cMr9IAD8Mem/gPwy6QuA/DNpC4D8M+oYaGn/gPw0af+YfDT4CHARQQgv5h6KXXGBGhpBCCNlGa1dQGCQLYMvhDE8cF8uGR+kD6QNIAMfoAcCSBAU0B+kQwWLry9CDXScIA8uLEBoIK+vCAoYIImJaAoSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIZI2MOMN+EKCCJiWgIIQ9Ydg7/hByCbPFss/UmBwBwgAeoIQBRONkcj4Q88WUAjPFnElBEkTVEegcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wAA3nCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAA44+cCOBAU0B+kQwWLry9BOCENUydttQBG1xcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wCSbDHi+GPwEAEQ4wJfA4QP8vAKAf4B+kDTf9IX0hfUMNDT/9P/MPhCF8cF8uBS+EMVxwXy4ZH4RhK68uGZ+Ee68uGZ+EXAAPLRmPhFAbYIIcjL/1Iwy//J+En4SMjL/8v/yfhH+Eb4RfhBghDXOsCdyMsfGss/+EPPFhnLPxjLfxfKFxbKF1Igy38VzBTMyfhFUAShCwEy+GX4aPhpgED4RcAAkzCDBt5w+EJa2zzwEAwALHGAGMjLBVAEzxZQBPoCEstqzMkB+wAASdOEARRw6A6YOA1QOJWTxPkEGHWEtVAECIENlJVQBxckIH2HIYwAZf9qJoaZ+A/DD9IAD8MX0gAPwx6gD8Mmm/gPwy6QuA/DNpC4D8M+oYaGn/gPw0af+YfDTABV0+En4SMjL/8v/yfhH+Eb4RfhE+EHIyz/4Qs8W+EPPFszLf8oXyhfMye1UgIBIBEUAgEgEhMAHbijjwD/hF+Eb4R/hI+EmAANueGfAP+EOAIBIBUWAHO4/P8A/4RNDTBzH0BDD4SfhI+Ef4RvhFcMjLBxb0ABXLfxTKFxPKFxLL/8v/yfhFwwD4QfhC+ENVA4AA26jC8A/4Qo1aJhlg=='
};
var ROUTERV3_CODE = /*#__PURE__*/Cell.fromBase64(INIT_CODE_BASE64.router);
var ACCOUNTV3_CODE = /*#__PURE__*/Cell.fromBase64(INIT_CODE_BASE64.account);
var POSITIONV3_CODE = /*#__PURE__*/Cell.fromBase64(INIT_CODE_BASE64.positionnft);
var POOLV3_CODE = /*#__PURE__*/Cell.fromBase64(INIT_CODE_BASE64.pool);

var TWO = /*#__PURE__*/JSBI.BigInt(2);
var POWERS_OF_2 = /*#__PURE__*/[128, 64, 32, 16, 8, 4, 2, 1].map(function (pow) {
  return [pow, JSBI.exponentiate(TWO, JSBI.BigInt(pow))];
});
function mostSignificantBit(x) {
  !JSBI.greaterThan(x, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO') : invariant(false) : void 0;
  !JSBI.lessThanOrEqual(x, MaxUint256) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX') : invariant(false) : void 0;
  var msb = 0;
  for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
      power = _step$value[0],
      min = _step$value[1];
    if (JSBI.greaterThanOrEqual(x, min)) {
      x = JSBI.signedRightShift(x, JSBI.BigInt(power));
      msb += power;
    }
  }
  return msb;
}

function mulShift(val, mulBy) {
  return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128));
}
var Q32 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(32));
var TickMath = /*#__PURE__*/function () {
  function TickMath() {}
  /**
   * Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick
   * @param tick the tick for which to compute the sqrt ratio
   */
  TickMath.getSqrtRatioAtTick = function getSqrtRatioAtTick(tick) {
    !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK') : invariant(false) : void 0;
    var absTick = tick < 0 ? tick * -1 : tick;
    var ratio = (absTick & 0x1) != 0 ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001') : JSBI.BigInt('0x100000000000000000000000000000000');
    if ((absTick & 0x2) != 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a');
    if ((absTick & 0x4) != 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc');
    if ((absTick & 0x8) != 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0');
    if ((absTick & 0x10) != 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644');
    if ((absTick & 0x20) != 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0');
    if ((absTick & 0x40) != 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861');
    if ((absTick & 0x80) != 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053');
    if ((absTick & 0x100) != 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4');
    if ((absTick & 0x200) != 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54');
    if ((absTick & 0x400) != 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3');
    if ((absTick & 0x800) != 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9');
    if ((absTick & 0x1000) != 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825');
    if ((absTick & 0x2000) != 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5');
    if ((absTick & 0x4000) != 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7');
    if ((absTick & 0x8000) != 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6');
    if ((absTick & 0x10000) != 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9');
    if ((absTick & 0x20000) != 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604');
    if ((absTick & 0x40000) != 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98');
    if ((absTick & 0x80000) != 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2');
    if (tick > 0) ratio = JSBI.divide(MaxUint256, ratio);
    // back to Q96
    return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO) ? JSBI.add(JSBI.divide(ratio, Q32), ONE) : JSBI.divide(ratio, Q32);
  }
  /**
   * Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96
   * and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
   * @param sqrtRatioX96 the sqrt ratio as a Q64.96 for which to compute the tick
   */;
  TickMath.getTickAtSqrtRatio = function getTickAtSqrtRatio(sqrtRatioX96) {
    !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SQRT_RATIO') : invariant(false) : void 0;
    var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32));
    var msb = mostSignificantBit(sqrtRatioX128);
    var r;
    if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {
      r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127));
    } else {
      r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb));
    }
    var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64));
    for (var i = 0; i < 14; i++) {
      r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127));
      var f = JSBI.signedRightShift(r, JSBI.BigInt(128));
      log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)));
      r = JSBI.signedRightShift(r, f);
    }
    var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'));
    var tickLow = JSBI.toNumber(JSBI.signedRightShift(JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')), JSBI.BigInt(128)));
    var tickHigh = JSBI.toNumber(JSBI.signedRightShift(JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')), JSBI.BigInt(128)));
    return tickLow === tickHigh ? tickLow : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96) ? tickHigh : tickLow;
  };
  return TickMath;
}();
/**
 * Cannot be constructed.
 */
/**
 * The minimum tick that can be used on any pool.
 */
TickMath.MIN_TICK = -887272;
/**
 * The maximum tick that can be used on any pool.
 */
TickMath.MAX_TICK = -TickMath.MIN_TICK;
/**
 * The sqrt ratio corresponding to the minimum tick that could be used on any pool.
 */
TickMath.MIN_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('4295128739');
/**
 * The sqrt ratio corresponding to the maximum tick that could be used on any pool.
 */
TickMath.MAX_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('1461446703485210103287273052203988822378723970342');

/**
 * Determines if a tick list is sorted
 * @param list The tick list
 * @param comparator The comparator
 * @returns true if sorted
 */
function isSorted(list, comparator) {
  for (var i = 0; i < list.length - 1; i++) {
    if (comparator(list[i], list[i + 1]) > 0) {
      return false;
    }
  }
  return true;
}

function tickComparator(a, b) {
  return a.index - b.index;
}
/**
 * Utility methods for interacting with sorted lists of ticks
 */
var TickList = /*#__PURE__*/function () {
  function TickList() {}
  /**
   * Cannot be constructed
   */
  TickList.validateList = function validateList(ticks, tickSpacing) {
    !(tickSpacing > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING_NONZERO') : invariant(false) : void 0;
    // ensure ticks are spaced appropriately
    !ticks.every(function (_ref) {
      var index = _ref.index;
      return index % tickSpacing === 0;
    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING') : invariant(false) : void 0;
    // ensure tick liquidity deltas sum to 0
    !JSBI.equal(ticks.reduce(function (accumulator, _ref2) {
      var liquidityNet = _ref2.liquidityNet;
      return JSBI.add(accumulator, liquidityNet);
    }, ZERO), ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO_NET') : invariant(false) : void 0;
    !isSorted(ticks, tickComparator) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SORTED') : invariant(false) : void 0;
  };
  TickList.isBelowSmallest = function isBelowSmallest(ticks, tick) {
    !(ticks.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'LENGTH') : invariant(false) : void 0;
    return tick < ticks[0].index;
  };
  TickList.isAtOrAboveLargest = function isAtOrAboveLargest(ticks, tick) {
    !(ticks.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'LENGTH') : invariant(false) : void 0;
    return tick >= ticks[ticks.length - 1].index;
  };
  TickList.getTick = function getTick(ticks, index) {
    var tick = ticks[this.binarySearch(ticks, index)];
    !(tick.index === index) ? process.env.NODE_ENV !== "production" ? invariant(false, 'NOT_CONTAINED') : invariant(false) : void 0;
    return tick;
  };
  TickList.nextInitializedTick = function nextInitializedTick(ticks, tick, lte) {
    if (lte) {
      !!TickList.isBelowSmallest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'BELOW_SMALLEST') : invariant(false) : void 0;
      if (TickList.isAtOrAboveLargest(ticks, tick)) {
        return ticks[ticks.length - 1];
      }
      var _index = this.binarySearch(ticks, tick);
      return ticks[_index];
    }
    !!this.isAtOrAboveLargest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'AT_OR_ABOVE_LARGEST') : invariant(false) : void 0;
    if (this.isBelowSmallest(ticks, tick)) {
      return ticks[0];
    }
    var index = this.binarySearch(ticks, tick);
    return ticks[index + 1];
  };
  TickList.nextInitializedTickWithinOneWord = function nextInitializedTickWithinOneWord(ticks, tick, lte, tickSpacing) {
    var compressed = Math.floor(tick / tickSpacing); // matches rounding in the code
    if (lte) {
      var _wordPos = compressed >> 8;
      var minimum = (_wordPos << 8) * tickSpacing;
      if (TickList.isBelowSmallest(ticks, tick)) {
        return [minimum, false];
      }
      var _index2 = TickList.nextInitializedTick(ticks, tick, lte).index;
      var _nextInitializedTick = Math.max(minimum, _index2);
      return [_nextInitializedTick, _nextInitializedTick === _index2];
    }
    var wordPos = compressed + 1 >> 8;
    var maximum = (wordPos + 1 << 8) * tickSpacing - 1;
    if (this.isAtOrAboveLargest(ticks, tick)) {
      return [maximum, false];
    }
    var index = this.nextInitializedTick(ticks, tick, lte).index;
    var nextInitializedTick = Math.min(maximum, index);
    return [nextInitializedTick, nextInitializedTick === index];
  }
  /**
   * Finds the largest tick in the list of ticks that is less than or equal to tick
   * @param ticks list of ticks
   * @param tick tick to find the largest tick that is less than or equal to tick
   * @private
   */;
  TickList.binarySearch = function binarySearch(ticks, tick) {
    !!this.isBelowSmallest(ticks, tick) ? process.env.NODE_ENV !== "production" ? invariant(false, 'BELOW_SMALLEST') : invariant(false) : void 0;
    var l = 0;
    var r = ticks.length - 1;
    var i;
    while (true) {
      i = Math.floor((l + r) / 2);
      if (ticks[i].index <= tick && (i === ticks.length - 1 || ticks[i + 1].index > tick)) {
        return i;
      }
      if (ticks[i].index < tick) {
        l = i + 1;
      } else {
        r = i - 1;
      }
    }
  };
  return TickList;
}();

var Tick = function Tick(_ref) {
  var index = _ref.index,
    liquidityGross = _ref.liquidityGross,
    liquidityNet = _ref.liquidityNet;
  !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK') : invariant(false) : void 0;
  this.index = index;
  this.liquidityGross = JSBI.BigInt(liquidityGross);
  this.liquidityNet = JSBI.BigInt(liquidityNet);
};

/**
 * A data provider for ticks that is backed by an in-memory array of ticks.
 */
var TickListDataProvider = /*#__PURE__*/function () {
  function TickListDataProvider(ticks, tickSpacing) {
    var ticksMapped = ticks.map(function (t) {
      return t instanceof Tick ? t : new Tick(t);
    });
    TickList.validateList(ticksMapped, tickSpacing);
    this.ticks = ticksMapped;
  }
  var _proto = TickListDataProvider.prototype;
  _proto.getTick = /*#__PURE__*/function () {
    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tick) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", TickList.getTick(this.ticks, tick));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getTick(_x) {
      return _getTick.apply(this, arguments);
    }
    return getTick;
  }();
  _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
      return _nextInitializedTickWithinOneWord.apply(this, arguments);
    }
    return nextInitializedTickWithinOneWord;
  }();
  return TickListDataProvider;
}();

var Rounding;
(function (Rounding) {
  Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));

var Bound;
(function (Bound) {
  Bound["LOWER"] = "LOWER";
  Bound["UPPER"] = "UPPER";
})(Bound || (Bound = {}));

var Field;
(function (Field) {
  Field["CURRENCY_A"] = "CURRENCY_A";
  Field["CURRENCY_B"] = "CURRENCY_B";
})(Field || (Field = {}));

var TradeType;
(function (TradeType) {
  TradeType[TradeType["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType[TradeType["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType || (TradeType = {}));

var _toSignificantRoundin, _toFixedRounding;
var Decimal = /*#__PURE__*/toFormat(_Decimal);
var Big = /*#__PURE__*/toFormat(_Big);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = /*#__PURE__*/function () {
  function Fraction(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);
    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;
    throw new Error('Could not parse fraction');
  }
  // performs floor division
  ;
  var _proto = Fraction.prototype;
  _proto.invert = function invert() {
    return new Fraction(this.denominator, this.numerator);
  };
  _proto.add = function add(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
    !(significantDigits > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
  /**
   * Helper method for converting any super class back to a fraction
   */;
  _createClass(Fraction, [{
    key: "quotient",
    get: function get() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get() {
      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get() {
      return new Fraction(this.numerator, this.denominator);
    }
  }]);
  return Fraction;
}();

var Big$1 = /*#__PURE__*/toFormat(_Big);
var JettonAmount = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(JettonAmount, _Fraction);
  function JettonAmount(jetton, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256) ? process.env.NODE_ENV !== "production" ? invariant(false, 'AMOUNT') : invariant(false) : void 0;
    _this.jetton = jetton;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(jetton.decimals));
    return _this;
  }
  /**
   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount
   * @param currency the currency in the amount
   * @param rawAmount the raw token or ether amount
   */
  JettonAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new JettonAmount(currency, rawAmount);
  }
  /**
   * Construct a currency amount with a denominator that is not equal to 1
   * @param currency the currency
   * @param numerator the numerator of the fractional token amount
   * @param denominator the denominator of the fractional token amount
   */;
  JettonAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new JettonAmount(currency, numerator, denominator);
  };
  var _proto = JettonAmount.prototype;
  _proto.add = function add(other) {
    !this.jetton.equals(other.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return JettonAmount.fromFractionalAmount(this.jetton, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract(other) {
    !this.jetton.equals(other.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return JettonAmount.fromFractionalAmount(this.jetton, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return JettonAmount.fromFractionalAmount(this.jetton, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return JettonAmount.fromFractionalAmount(this.jetton, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.jetton.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    !(decimalPlaces <= this.jetton.decimals) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    Big$1.DP = this.jetton.decimals;
    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass(JettonAmount, [{
    key: "wrapped",
    get: function get() {
      // if (this.jetton.isToken) return this as JettonAmount<Jetton>;
      return JettonAmount.fromFractionalAmount(this.jetton, this.numerator, this.denominator);
    }
  }]);
  return JettonAmount;
}(Fraction);

var FullMath = /*#__PURE__*/function () {
  function FullMath() {}
  /**
   * Cannot be constructed.
   */
  FullMath.mulDivRoundingUp = function mulDivRoundingUp(a, b, denominator) {
    var product = JSBI.multiply(a, b);
    var result = JSBI.divide(product, denominator);
    if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE);
    return result;
  };
  return FullMath;
}();

var MaxUint160 = /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(160)), ONE);
function multiplyIn256(x, y) {
  var product = JSBI.multiply(x, y);
  return JSBI.bitwiseAnd(product, MaxUint256);
}
function addIn256(x, y) {
  var sum = JSBI.add(x, y);
  return JSBI.bitwiseAnd(sum, MaxUint256);
}
var SqrtPriceMath = /*#__PURE__*/function () {
  function SqrtPriceMath() {}
  /**
   * Cannot be constructed.
   */
  SqrtPriceMath.getAmount0Delta = function getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
      var _ref = [sqrtRatioBX96, sqrtRatioAX96];
      sqrtRatioAX96 = _ref[0];
      sqrtRatioBX96 = _ref[1];
    }
    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
    var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96);
    return roundUp ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96) : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96);
  };
  SqrtPriceMath.getAmount1Delta = function getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
      var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
      sqrtRatioAX96 = _ref2[0];
      sqrtRatioBX96 = _ref2[1];
    }
    return roundUp ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96) : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96);
  };
  SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
    !JSBI.greaterThan(sqrtPX96, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    !JSBI.greaterThan(liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    return zeroForOne ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
  };
  SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne) {
    !JSBI.greaterThan(sqrtPX96, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    !JSBI.greaterThan(liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    return zeroForOne ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
  };
  SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amount, add) {
    if (JSBI.equal(amount, ZERO)) return sqrtPX96;
    var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
    if (add) {
      var _product = multiplyIn256(amount, sqrtPX96);
      if (JSBI.equal(JSBI.divide(_product, amount), sqrtPX96)) {
        var _denominator = addIn256(numerator1, _product);
        if (JSBI.greaterThanOrEqual(_denominator, numerator1)) {
          return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator);
        }
      }
      return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount));
    }
    var product = multiplyIn256(amount, sqrtPX96);
    !JSBI.equal(JSBI.divide(product, amount), sqrtPX96) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    !JSBI.greaterThan(numerator1, product) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    var denominator = JSBI.subtract(numerator1, product);
    return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator);
  };
  SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amount, add) {
    if (add) {
      var _quotient = JSBI.lessThanOrEqual(amount, MaxUint160) ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity) : JSBI.divide(JSBI.multiply(amount, Q96), liquidity);
      return JSBI.add(sqrtPX96, _quotient);
    }
    var quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity);
    !JSBI.greaterThan(sqrtPX96, quotient) ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
    return JSBI.subtract(sqrtPX96, quotient);
  };
  return SqrtPriceMath;
}();

var MAX_FEE = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(10), /*#__PURE__*/JSBI.BigInt(6));
var SwapMath = /*#__PURE__*/function () {
  function SwapMath() {}
  /**
   * Cannot be constructed.
   */
  SwapMath.computeSwapStep = function computeSwapStep(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, amountRemaining, feePips) {
    var returnValues = {};
    var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96);
    var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO);
    if (exactIn) {
      var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips))), MAX_FEE);
      returnValues.amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
      if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn)) {
        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
      } else {
        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne);
      }
    } else {
      returnValues.amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
      if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {
        returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
      } else {
        returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96, liquidity, JSBI.multiply(amountRemaining, NEGATIVE_ONE), zeroForOne);
      }
    }
    var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96);
    if (zeroForOne) {
      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
    } else {
      returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true);
      returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false);
    }
    if (!exactIn && JSBI.greaterThan(returnValues.amountOut, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {
      returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE);
    }
    if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {
      // we didn't reach the target, so take the remainder of the maximum input as fee
      returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn);
    } else {
      returnValues.feeAmount = FullMath.mulDivRoundingUp(returnValues.amountIn, JSBI.BigInt(feePips), JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips)));
    }
    return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount];
  };
  return SwapMath;
}();

var LiquidityMath = /*#__PURE__*/function () {
  function LiquidityMath() {}
  /**
   * Cannot be constructed.
   */
  LiquidityMath.addDelta = function addDelta(x, y) {
    if (JSBI.lessThan(y, ZERO)) {
      return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE));
    }
    return JSBI.add(x, y);
  };
  return LiquidityMath;
}();

var Price = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(Price, _Fraction);
  /**
   * Construct a price, either with the base and quote currency amount, or the
   * @param args
   */
  function Price() {
    var _this;
    var baseCurrency;
    var quoteCurrency;
    var denominator;
    var numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.jetton, args[0].quoteAmount.jetton, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  /**
   * Flip the price, switching the base and quote currency
   */
  var _proto = Price.prototype;
  _proto.invert = function invert() {
    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  }
  /**
   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency
   * @param other the other price
   */;
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  }
  /**
   * Return the amount of quote currency corresponding to a given amount of the base currency
   * @param currencyAmount the amount of base currency to quote against the price
   */;
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.jetton.equals(this.baseCurrency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return JettonAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  }
  /**
   * Get the value scaled by decimals for formatting
   * @private
   */;
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  }
  /* new for TONCO */;
  _createClass(Price, [{
    key: "adjustedForDecimals",
    get: function get() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }, {
    key: "asFraction",
    get: function get() {
      return new Fraction(this.adjustedForDecimals.numerator, this.adjustedForDecimals.denominator);
    }
  }]);
  return Price;
}(Fraction);

/**
 *   This is a autogenerated file that is created by parsig op-code files
 *   To regenerate it use
 *
 *   ts-node scripts/scan_opcodes.ts
 **/
var ContractOpcodes = function ContractOpcodes() {};
ContractOpcodes.ACCOUNTV3_RESET_GAS = 0x42a0fb43; // 1117846339
ContractOpcodes.ACCOUNTV3_ADD_LIQUIDITY = 0x3ebe5431; // 1052660785
ContractOpcodes.ACCOUNTV3_CB_ADD_LIQUIDITY = 0x56dfeb8a; // 1457515402
ContractOpcodes.ACCOUNTV3_GETTER_LP_ACCOUNT_DATA = 0x1d439ae0; // 490969824
ContractOpcodes.ACCOUNTV3_DIRECT_ADD_LIQUIDITY = 0x4cf82803; // 1291331587
ContractOpcodes.ACCOUNTV3_REFUND_ME = 0xbf3f447; // 200537159
ContractOpcodes.ACCOUNTV3_CB_REFUND_ME = 0x89446a42; // 2302962242
ContractOpcodes.JETTON_PROVIDE_WALLET_ADDRESS = 0x2c76b973; // 745978227
ContractOpcodes.JETTON_TAKE_WALLET_ADDRESS = 0xd1735400; // 3513996288
ContractOpcodes.JETTON_TRANSFER = 0xf8a7ea5; // 260734629
ContractOpcodes.JETTON_TRANSFER_NOTIFICATION = 0x7362d09c; // 1935855772
ContractOpcodes.JETTON_INTERNAL_TRANSFER = 0x178d4519; // 395134233
ContractOpcodes.JETTON_EXCESSES = 0xd53276db; // 3576854235
ContractOpcodes.JETTON_BURN = 0x595f07bc; // 1499400124
ContractOpcodes.JETTON_BURN_NOTIFICATION = 0x7bdd97de; // 2078119902
ContractOpcodes.JETTON_MINT = 0x15; // 21
ContractOpcodes.NFT_TRANSFER = 0x5fcc3d14; // 1607220500
ContractOpcodes.NFT_OWNERSHIP_ASSIGNED = 0x5138d91; // 85167505
ContractOpcodes.NFT_EXCESSES = 0xd53276db; // 3576854235
ContractOpcodes.NFT_GET_STATIC_DATA = 0x2fcb26a2; // 801842850
ContractOpcodes.NFT_REPORT_STATIC_DATA = 0x8b771735; // 2339837749
ContractOpcodes.NFT_GET_ROYALTY_PARAMS = 0x693d3950; // 1765620048
ContractOpcodes.NFT_REPORT_ROYALTY_PARAMS = 0xa8cb00ad; // 2831876269
ContractOpcodes.NFT_EDIT_CONTENT = 0x1a0b9d51; // 436968785
ContractOpcodes.NFT_TRANSFER_EDITORSHIP = 0x1c04412a; // 470040874
ContractOpcodes.NFT_EDITORSHIP_ASSIGNED = 0x511a4463; // 1360675939
ContractOpcodes.POOL_FACTORY_CHANGE_PARAMS = 0xaa0db3d7; // 2853024727
ContractOpcodes.POOL_FACTORY_CREATE_POOL = 0x9e9a8f7f; // 2660929407
ContractOpcodes.POOL_FACTORY_RESET_GAS = 0x42a0fb43; // 1117846339
ContractOpcodes.POOL_FACTORY_ORDER_INIT = 0x8b85de63; // 2340806243
ContractOpcodes.POOL_FACTORY_EXECUTE = 0xd4b33b0a; // 3568515850
ContractOpcodes.POOLV3_INIT = 0x441c39ed; // 1142700525
ContractOpcodes.POOLV3_LOCK = 0x5e74697; // 99042967
ContractOpcodes.POOLV3_UNLOCK = 0x3205adbd; // 839232957
ContractOpcodes.POOLV3_SET_FEE = 0x6bdcbeb8; // 1809628856
ContractOpcodes.POOLV3_SWAP = 0xa7fb58f8; // 2818267384
ContractOpcodes.POOLV3_FUND_ACCOUNT = 0x4468de77; // 1147723383
ContractOpcodes.POOLV3_MINT = 0x81702ef8; // 2171612920
ContractOpcodes.POOLV3_START_BURN = 0x530b5f2c; // 1393254188
ContractOpcodes.POOLV3_BURN = 0xd73ac09d; // 3610951837
ContractOpcodes.POOLV3_COLLECT_PROTOCOL = 0xd3f8a538; // 3556287800
ContractOpcodes.POOLV3_RESET_GAS = 0x42a0fb43; // 1117846339
ContractOpcodes.POOLV3_MINT_M = 0xdbb7bb55; // 3686251349
ContractOpcodes.POOLV3_BURN_M = 0xe639646c; // 3862520940
ContractOpcodes.POOLV3_SWAP_M = 0xdb913023; // 3683725347
ContractOpcodes.POOLV3_FILL_TICK_M = 0x80139ad6; // 2148768470
ContractOpcodes.POSITIONNFTV3_NFT_TRANSFER = 0x5fcc3d14; // 1607220500
ContractOpcodes.POSITIONNFTV3_OWNERSHIP_ASSIGNED = 0x5138d91; // 85167505
ContractOpcodes.POSITIONNFTV3_EXCESSES = 0xd53276db; // 3576854235
ContractOpcodes.POSITIONNFTV3_GET_STATIC_DATA = 0x2fcb26a2; // 801842850
ContractOpcodes.POSITIONNFTV3_REPORT_STATIC_DATA = 0x8b771735; // 2339837749
ContractOpcodes.POSITIONNFTV3_GET_ROYALTY_PARAMS = 0x693d3950; // 1765620048
ContractOpcodes.POSITIONNFTV3_REPORT_ROYALTY_PARAMS = 0xa8cb00ad; // 2831876269
ContractOpcodes.POSITIONNFTV3_POSITION_INIT = 0xd5ecca2a; // 3589065258
ContractOpcodes.POSITIONNFTV3_POSITION_BURN = 0x46ca335a; // 1187656538
ContractOpcodes.POSITIONNFTV3_FEE_COLLECTED = 0x5ee6039f; // 1592132511
ContractOpcodes.POSITIONNFTV3_OWNERSHIP_ASSIGNED_NOTIFY = 0xf58760ef; // 4119290095
ContractOpcodes.POSITIONNFTV3_EDIT_CONTENT = 0x1a0b9d51; // 436968785
ContractOpcodes.POSITIONNFTV3_TRANSFER_EDITORSHIP = 0x1c04412a; // 470040874
ContractOpcodes.POSITIONNFTV3_EDITORSHIP_ASSIGNED = 0x511a4463; // 1360675939
ContractOpcodes.ROUTERTV3_ADD_POOL = 0x5bcb5a84; // 1540053636
ContractOpcodes.ROUTERTV3_CHANGE_ADMIN = 0xb3bc094; // 188465300
ContractOpcodes.ROUTERV3_PAY_TO = 0xa1daa96d; // 2715461997
ContractOpcodes.ROUTERV3_CREATE_POOL = 0x2e3034ef; // 774911215
ContractOpcodes.ROUTERV3_RESET_GAS = 0x42a0fb43; // 1117846339
ContractOpcodes.ROUTERV3_CHANGE_ADMIN_START = 0xd4deb03b; // 3571363899
ContractOpcodes.ROUTERV3_CHANGE_ADMIN_COMMIT = 0x98bac405; // 2562376709
ContractOpcodes.ROUTERV3_CHANGE_PARAMS = 0x87ffe363; // 2281694051
ContractOpcodes.SINKV3_SET = 0xe61425dc; // 3860080092
ContractOpcodes.SINKV3_ADD = 0xfd1a73e7; // 4246369255
ContractOpcodes.SINKV3_TEST_GAS = 0x7337ed7; // 120815319
ContractOpcodes.SINKV3_DUMMY = 0xfffffeee; // 4294967022
ContractOpcodes.TONPROXY_MINTER_PROVIDE_WALLET_ADDRESS = 0x2c76b973; // 745978227
ContractOpcodes.TONPROXY_MINTER_TAKE_WALLET_ADDRESS = 0xd1735400; // 3513996288
ContractOpcodes.TONPROXY_MINTER_DEPLOY_WALLET = 0xcf5f4313; // 3479126803
ContractOpcodes.TONPROXY_MINTER_INTERNAL_DEPLOY = 0x6540cf85; // 1698746245
ContractOpcodes.TONPROXY_MINTER_TON_TRANSFER = 0x1f3835d; // 32736093
ContractOpcodes.TONPROXY_MINTER_RESET_GAS = 0x29d22935; // 701638965
ContractOpcodes.TONPROXY_MINTER_TON_REFUND = 0xae25d79e; // 2921715614
var OpcodesLookup = {
  0x15: 'JETTON_MINT',
  0x1f3835d: 'TONPROXY_MINTER_TON_TRANSFER',
  0x5138d91: 'NFT_OWNERSHIP_ASSIGNED,POSITIONNFTV3_OWNERSHIP_ASSIGNED',
  0x5e74697: 'POOLV3_LOCK',
  0x7337ed7: 'SINKV3_TEST_GAS',
  0xb3bc094: 'ROUTERTV3_CHANGE_ADMIN',
  0xbf3f447: 'ACCOUNTV3_REFUND_ME',
  0xf8a7ea5: 'JETTON_TRANSFER',
  0x178d4519: 'JETTON_INTERNAL_TRANSFER',
  0x1a0b9d51: 'NFT_EDIT_CONTENT,POSITIONNFTV3_EDIT_CONTENT',
  0x1c04412a: 'NFT_TRANSFER_EDITORSHIP,POSITIONNFTV3_TRANSFER_EDITORSHIP',
  0x1d439ae0: 'ACCOUNTV3_GETTER_LP_ACCOUNT_DATA',
  0x29d22935: 'TONPROXY_MINTER_RESET_GAS',
  0x2c76b973: 'JETTON_PROVIDE_WALLET_ADDRESS,TONPROXY_MINTER_PROVIDE_WALLET_ADDRESS',
  0x2e3034ef: 'ROUTERV3_CREATE_POOL',
  0x2fcb26a2: 'NFT_GET_STATIC_DATA,POSITIONNFTV3_GET_STATIC_DATA',
  0x3205adbd: 'POOLV3_UNLOCK',
  0x3ebe5431: 'ACCOUNTV3_ADD_LIQUIDITY',
  0x42a0fb43: 'ACCOUNTV3_RESET_GAS,POOL_FACTORY_RESET_GAS,POOLV3_RESET_GAS,ROUTERV3_RESET_GAS',
  0x441c39ed: 'POOLV3_INIT',
  0x4468de77: 'POOLV3_FUND_ACCOUNT',
  0x46ca335a: 'POSITIONNFTV3_POSITION_BURN',
  0x4cf82803: 'ACCOUNTV3_DIRECT_ADD_LIQUIDITY',
  0x511a4463: 'NFT_EDITORSHIP_ASSIGNED,POSITIONNFTV3_EDITORSHIP_ASSIGNED',
  0x530b5f2c: 'POOLV3_START_BURN',
  0x56dfeb8a: 'ACCOUNTV3_CB_ADD_LIQUIDITY',
  0x595f07bc: 'JETTON_BURN',
  0x5bcb5a84: 'ROUTERTV3_ADD_POOL',
  0x5ee6039f: 'POSITIONNFTV3_FEE_COLLECTED',
  0x5fcc3d14: 'NFT_TRANSFER,POSITIONNFTV3_NFT_TRANSFER',
  0x6540cf85: 'TONPROXY_MINTER_INTERNAL_DEPLOY',
  0x693d3950: 'NFT_GET_ROYALTY_PARAMS,POSITIONNFTV3_GET_ROYALTY_PARAMS',
  0x6bdcbeb8: 'POOLV3_SET_FEE',
  0x7362d09c: 'JETTON_TRANSFER_NOTIFICATION',
  0x7bdd97de: 'JETTON_BURN_NOTIFICATION',
  0x80139ad6: 'POOLV3_FILL_TICK_M',
  0x81702ef8: 'POOLV3_MINT',
  0x87ffe363: 'ROUTERV3_CHANGE_PARAMS',
  0x89446a42: 'ACCOUNTV3_CB_REFUND_ME',
  0x8b771735: 'NFT_REPORT_STATIC_DATA,POSITIONNFTV3_REPORT_STATIC_DATA',
  0x8b85de63: 'POOL_FACTORY_ORDER_INIT',
  0x98bac405: 'ROUTERV3_CHANGE_ADMIN_COMMIT',
  0x9e9a8f7f: 'POOL_FACTORY_CREATE_POOL',
  0xa1daa96d: 'ROUTERV3_PAY_TO',
  0xa7fb58f8: 'POOLV3_SWAP',
  0xa8cb00ad: 'NFT_REPORT_ROYALTY_PARAMS,POSITIONNFTV3_REPORT_ROYALTY_PARAMS',
  0xaa0db3d7: 'POOL_FACTORY_CHANGE_PARAMS',
  0xae25d79e: 'TONPROXY_MINTER_TON_REFUND',
  0xcf5f4313: 'TONPROXY_MINTER_DEPLOY_WALLET',
  0xd1735400: 'JETTON_TAKE_WALLET_ADDRESS,TONPROXY_MINTER_TAKE_WALLET_ADDRESS',
  0xd3f8a538: 'POOLV3_COLLECT_PROTOCOL',
  0xd4b33b0a: 'POOL_FACTORY_EXECUTE',
  0xd4deb03b: 'ROUTERV3_CHANGE_ADMIN_START',
  0xd53276db: 'JETTON_EXCESSES,NFT_EXCESSES,POSITIONNFTV3_EXCESSES',
  0xd5ecca2a: 'POSITIONNFTV3_POSITION_INIT',
  0xd73ac09d: 'POOLV3_BURN',
  0xdb913023: 'POOLV3_SWAP_M',
  0xdbb7bb55: 'POOLV3_MINT_M',
  0xe61425dc: 'SINKV3_SET',
  0xe639646c: 'POOLV3_BURN_M',
  0xf58760ef: 'POSITIONNFTV3_OWNERSHIP_ASSIGNED_NOTIFY',
  0xfd1a73e7: 'SINKV3_ADD',
  0xfffffeee: 'SINKV3_DUMMY'
};
var ContractErrors = function ContractErrors() {};
ContractErrors.COMMON_WRONG_OP = 65535; // 0xffff
ContractErrors.COMMON_WRONG_WORKCHAIN = 333; // 0x14d
ContractErrors.JETTON_INVALID_OP = 709; // 0x2c5
ContractErrors.JETTON_NOT_ADMIN = 73; // 0x49
ContractErrors.JETTON_UNOUTHORIZED_BURN = 74; // 0x4a
ContractErrors.JETTON_DISCOVERY_FEE_NOT_MATCHED = 75; // 0x4b
ContractErrors.JETTON_NOT_OWNER = 705; // 0x2c1
ContractErrors.JETTON_NOT_ENOUGH_TON = 709; // 0x2c5
ContractErrors.JETTON_NOT_ENOUGH_GAS = 707; // 0x2c3
ContractErrors.JETTON_NOT_VALID_WALLET = 707; // 0x2c3
ContractErrors.JETTON_BALANCE_ERROR = 706; // 0x2c2
ContractErrors.NFT_NOT_OWNER = 401; // 0x191
ContractErrors.POOL_FACTORY_INVALID_AMOUNT = 110; // 0x6e
ContractErrors.POOL_FACTORY_INVALID_CALLER = 111; // 0x6f
ContractErrors.POOL_FACTORY_POOL_ILLEGAL_PARAMS = 112; // 0x70
ContractErrors.POOL_FACTORY_INSUFFICIENT_GAS = 113; // 0x71
ContractErrors.POOLV3_NO_LIQUIDITY = 80; // 0x50
ContractErrors.POOLV3_ZERO_OUTPUT = 81; // 0x51
ContractErrors.POOLV3_INVALID_CALLER = 82; // 0x52
ContractErrors.POOLV3_INSUFFICIENT_GAS = 83; // 0x53
ContractErrors.POOLV3_INVALID_TOKEN = 86; // 0x56
ContractErrors.POOLV3_LOW_AMOUNT = 87; // 0x57
ContractErrors.POOLV3_MATH_ERROR = 90; // 0x5a
ContractErrors.POOLV3_TICK_IMPOSSIBLE_LOW = 91; // 0x5b
ContractErrors.POOLV3_TICK_IMPOSSIBLE_HIGH = 92; // 0x5c
ContractErrors.POOLV3_PRICE_IMPOSSIBLE_LOW = 93; // 0x5d
ContractErrors.POOLV3_PRICE_IMPOSSIBLE_HIGH = 94; // 0x5e
ContractErrors.POOLV3_PRICE_LIMIT_WRONG = 95; // 0x5f
ContractErrors.POOLV3_LOWER_THEN_MIN_OUT = 96; // 0x60
ContractErrors.POOLV3_INVALID_RECIPIENT = 100; // 0x64
ContractErrors.POOLV3_POOL_UNDEPLOYED = 101; // 0x65
ContractErrors.POOLV3_POOL_INACTIVE = 102; // 0x66
ContractErrors.POOLV3_FORGED_NFT = 103; // 0x67
ContractErrors.POOLV3_BURN_PARAMETERS_WRONG = 104; // 0x68
ContractErrors.POOLV3_RESERVES_PROTECTION_ERROR_SIGN = 105; // 0x69
ContractErrors.POOLV3_RESERVES_PROTECTION_ERROR_DRAIN = 106; // 0x6a
ContractErrors.POOLV3_POOL_MALFORMED = 107; // 0x6b
ContractErrors.POOLV3_RESULT_SWAP_OK = 200; // 0xc8
ContractErrors.POOLV3_RESULT_BURN_OK = 201; // 0xc9
ContractErrors.POOLV3_RESULT_MINT_OK = 202; // 0xca
ContractErrors.POOLV3_RESULT_COLLECT_OK = 203; // 0xcb
ContractErrors.POOLV3_RESULT_SWAP_OUTPUT_TOO_SMALL = 230; // 0xe6
ContractErrors.POOLV3_RESULT_TICK_IMPOSSIBLE_LOW = 220; // 0xdc
ContractErrors.POOLV3_RESULT_TICK_IMPOSSIBLE_HIGH = 221; // 0xdd
ContractErrors.POOLV3_RESULT_WRONG_TICK_SPACING = 222; // 0xde
ContractErrors.POOLV3_RESULT_TOO_MANY_TICKS = 223; // 0xdf
ContractErrors.POOLV3_RESULT_TOO_MUCH_LIQUIDITY = 224; // 0xe0
ContractErrors.POOLV3_RESULT_NOT_ENOUGH_COINS = 225; // 0xe1
ContractErrors.POOLV3_RESULT_NO_LIQUIDITY = 226; // 0xe2
ContractErrors.POSITIONNFTV3_INVALID_CALLER = 82; // 0x52
ContractErrors.POSITIONNFTV3_INIT_NOT_BY_COLLECTION = 405; // 0x195
ContractErrors.POSITIONNFTV3_NOT_AN_OWNER = 401; // 0x191
ContractErrors.POSITIONNFTV3_ALREADY_BURNED = 408; // 0x198
ContractErrors.POSITIONNFTV3_WRONG_BURN_TICKS = 409; // 0x199
ContractErrors.POSITIONNFTV3_MESSAGE_TOO_LONG = 708; // 0x2c4
ContractErrors.ROUTERV3_INVALID_AMOUNT = 110; // 0x6e
ContractErrors.ROUTERV3_INVALID_CALLER = 111; // 0x6f
ContractErrors.ROUTERV3_POOL_ILLEGAL_PARAMS = 112; // 0x70
ContractErrors.ROUTERV3_INSUFFICIENT_GAS = 113; // 0x71
ContractErrors.ROUTERV3_TIMELOCK_NOT_RESPECTED = 114; // 0x72
var ErrorsLookup = {
  73: 'JETTON_NOT_ADMIN',
  74: 'JETTON_UNOUTHORIZED_BURN',
  75: 'JETTON_DISCOVERY_FEE_NOT_MATCHED',
  80: 'POOLV3_NO_LIQUIDITY',
  81: 'POOLV3_ZERO_OUTPUT',
  82: 'POOLV3_INVALID_CALLER,POSITIONNFTV3_INVALID_CALLER',
  83: 'POOLV3_INSUFFICIENT_GAS',
  86: 'POOLV3_INVALID_TOKEN',
  87: 'POOLV3_LOW_AMOUNT',
  90: 'POOLV3_MATH_ERROR',
  91: 'POOLV3_TICK_IMPOSSIBLE_LOW',
  92: 'POOLV3_TICK_IMPOSSIBLE_HIGH',
  93: 'POOLV3_PRICE_IMPOSSIBLE_LOW',
  94: 'POOLV3_PRICE_IMPOSSIBLE_HIGH',
  95: 'POOLV3_PRICE_LIMIT_WRONG',
  96: 'POOLV3_LOWER_THEN_MIN_OUT',
  100: 'POOLV3_INVALID_RECIPIENT',
  101: 'POOLV3_POOL_UNDEPLOYED',
  102: 'POOLV3_POOL_INACTIVE',
  103: 'POOLV3_FORGED_NFT',
  104: 'POOLV3_BURN_PARAMETERS_WRONG',
  105: 'POOLV3_RESERVES_PROTECTION_ERROR_SIGN',
  106: 'POOLV3_RESERVES_PROTECTION_ERROR_DRAIN',
  107: 'POOLV3_POOL_MALFORMED',
  110: 'POOL_FACTORY_INVALID_AMOUNT,ROUTERV3_INVALID_AMOUNT',
  111: 'POOL_FACTORY_INVALID_CALLER,ROUTERV3_INVALID_CALLER',
  112: 'POOL_FACTORY_POOL_ILLEGAL_PARAMS,ROUTERV3_POOL_ILLEGAL_PARAMS',
  113: 'POOL_FACTORY_INSUFFICIENT_GAS,ROUTERV3_INSUFFICIENT_GAS',
  114: 'ROUTERV3_TIMELOCK_NOT_RESPECTED',
  200: 'POOLV3_RESULT_SWAP_OK',
  201: 'POOLV3_RESULT_BURN_OK',
  202: 'POOLV3_RESULT_MINT_OK',
  203: 'POOLV3_RESULT_COLLECT_OK',
  220: 'POOLV3_RESULT_TICK_IMPOSSIBLE_LOW',
  221: 'POOLV3_RESULT_TICK_IMPOSSIBLE_HIGH',
  222: 'POOLV3_RESULT_WRONG_TICK_SPACING',
  223: 'POOLV3_RESULT_TOO_MANY_TICKS',
  224: 'POOLV3_RESULT_TOO_MUCH_LIQUIDITY',
  225: 'POOLV3_RESULT_NOT_ENOUGH_COINS',
  226: 'POOLV3_RESULT_NO_LIQUIDITY',
  230: 'POOLV3_RESULT_SWAP_OUTPUT_TOO_SMALL',
  333: 'COMMON_WRONG_WORKCHAIN',
  401: 'NFT_NOT_OWNER,POSITIONNFTV3_NOT_AN_OWNER',
  405: 'POSITIONNFTV3_INIT_NOT_BY_COLLECTION',
  408: 'POSITIONNFTV3_ALREADY_BURNED',
  409: 'POSITIONNFTV3_WRONG_BURN_TICKS',
  705: 'JETTON_NOT_OWNER',
  706: 'JETTON_BALANCE_ERROR',
  707: 'JETTON_NOT_ENOUGH_GAS,JETTON_NOT_VALID_WALLET',
  708: 'POSITIONNFTV3_MESSAGE_TOO_LONG',
  709: 'JETTON_INVALID_OP,JETTON_NOT_ENOUGH_TON',
  65535: 'COMMON_WRONG_OP'
};

// TODO: In file
//   - Rework code doubling
//   - functions packing and unpacking 5 field structures should not be async
var defaultJettonKeys = ['uri', 'name', 'description', 'image', 'image_data', 'symbol', 'decimals', 'amount_style'];
var defaultNftKeys = ['uri', 'name', 'description', 'image', 'image_data', 'content_url', 'cover_image', 'attributes'];
var keyTypes = {
  name: 'utf8',
  description: 'utf8',
  image: 'ascii',
  decimals: 'utf8',
  symbol: 'utf8',
  image_data: undefined,
  uri: 'ascii',
  content_url: 'ascii',
  cover_image: 'ascii',
  attributes: 'ascii'
};
function getKeyType(key) {
  if (key in keyTypes) {
    return keyTypes[key];
  }
  return undefined;
}
var ONCHAIN_CONTENT_PREFIX = 0x00;
var OFFCHAIN_CONTENT_PREFIX = 0x01;
var contentValue = {
  serialize: function serialize(src, builder) {
    builder.storeRef(beginCell().storeUint(0, 8).storeStringTail(src).endCell());
  },
  parse: function parse(src) {
    var sc = src.loadRef().beginParse();
    var prefix = sc.loadUint(8);
    if (prefix == 0) {
      return sc.loadStringTail();
    } else if (prefix == 1) {
      // Not really tested, but feels like it should work
      var chunkDict = Dictionary.loadDirect(Dictionary.Keys.Uint(32), Dictionary.Values.Cell(), sc);
      return chunkDict.values().map(function (x) {
        return x.beginParse().loadStringTail();
      }).join('');
    } else {
      throw Error("Prefix " + prefix + " is not supported yet");
    }
  }
};
function displayContentCell(content, jetton, additional) {
  if (jetton === void 0) {
    jetton = true;
  }
  var cs = content.beginParse();
  var contentType = cs.loadUint(8);
  if (contentType == OFFCHAIN_CONTENT_PREFIX) {
    var noData = cs.remainingBits == 0;
    if (noData && cs.remainingRefs == 0) {
      console.log('No data in content cell!\n');
    } else {
      var contentUrl = noData ? cs.loadStringRefTail() : cs.loadStringTail();
      console.log("Content metadata url:" + contentUrl + "\n");
    }
  } else if (contentType == ONCHAIN_CONTENT_PREFIX) {
    var contentKeys;
    var hasAdditional = additional !== undefined && additional.length > 0;
    var contentDict = Dictionary.load(Dictionary.Keys.BigUint(256), contentValue, cs);
    var contentMap = {};
    if (jetton) {
      contentKeys = hasAdditional ? [].concat(defaultJettonKeys, additional) : defaultJettonKeys;
    } else {
      contentKeys = hasAdditional ? [].concat(defaultNftKeys, additional) : defaultNftKeys;
    }
    for (var _iterator = _createForOfIteratorHelperLoose(contentKeys), _step; !(_step = _iterator()).done;) {
      var name = _step.value;
      // I know we should pre-compute hashed keys for known values... just not today.
      var dictKey = BigInt('0x' + sha256_sync(name).toString('hex'));
      var dictValue = contentDict.get(dictKey);
      if (dictValue !== undefined) {
        contentMap[name] = dictValue;
      }
    }
    console.log("Content:" + JSON.stringify(contentMap, null, 2));
  } else {
    console.log("Unknown content format indicator:" + contentType + "\n");
  }
}
function unpackJettonOnchainMetadata(content, jetton, additional) {
  if (jetton === void 0) {
    jetton = true;
  }
  var cs = content.beginParse();
  var contentType = cs.loadUint(8);
  if (contentType == 1) {
    var noData = cs.remainingBits == 0;
    if (noData && cs.remainingRefs == 0) {
      console.log('No data in content cell!\n');
      return {};
    } else {
      var contentUrl = noData ? cs.loadStringRefTail() : cs.loadStringTail();
      console.log("Content metadata url:" + contentUrl + "\n");
      return {
        uri: contentUrl
      };
    }
  } else if (contentType == 0) {
    var contentKeys;
    var hasAdditional = additional !== undefined && additional.length > 0;
    var contentDict = Dictionary.load(Dictionary.Keys.BigUint(256), contentValue, cs);
    var contentMap = {};
    if (jetton) {
      contentKeys = hasAdditional ? [].concat(defaultJettonKeys, additional) : defaultJettonKeys;
    } else {
      contentKeys = hasAdditional ? [].concat(defaultNftKeys, additional) : defaultNftKeys;
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(contentKeys), _step2; !(_step2 = _iterator2()).done;) {
      var name = _step2.value;
      //console.log(`Checking ${name}`)
      var dictKey = BigInt('0x' + sha256_sync(name).toString('hex'));
      var dictValue = contentDict.get(dictKey);
      if (dictValue !== undefined) {
        contentMap[name] = dictValue;
      }
    }
    return contentMap;
  } else {
    console.log("Unknown content format indicator:" + contentType + "\n");
    return {};
  }
}
function packOffchainMetadata(data) {
  var result = beginCell().storeInt(OFFCHAIN_CONTENT_PREFIX, 8).storeStringTail(data).endCell();
  return result;
}
function packJettonOnchainMetadata(data) {
  var records = Dictionary.empty(Dictionary.Keys.BigUint(256), contentValue);
  for (var k in data) {
    var v = data[k];
    if (!getKeyType(k)) throw new Error("Unsupported onchain key: " + k);
    if (v === undefined || v === '') continue;
    var bufferToStore = Buffer.from(v, getKeyType(k));
    var hash = sha256_sync(k);
    var hashStr = '0x' + hash.toString('hex');
    // console.log("Adding value: ", hashStr, " ==> ", bufferToStore.toString())
    records.set(BigInt(hashStr), bufferToStore.toString());
  }
  var result = beginCell().storeInt(ONCHAIN_CONTENT_PREFIX, 8).storeDict(records).endCell();
  return result;
}

var TickInfoWrapper = function TickInfoWrapper(liquidityGross, liquidityNet, outerFeeGrowth0Token, outerFeeGrowth1Token) {
  if (liquidityGross === void 0) {
    liquidityGross = BigInt(0);
  }
  if (liquidityNet === void 0) {
    liquidityNet = BigInt(0);
  }
  if (outerFeeGrowth0Token === void 0) {
    outerFeeGrowth0Token = BigInt(0);
  }
  if (outerFeeGrowth1Token === void 0) {
    outerFeeGrowth1Token = BigInt(0);
  }
  this.liquidityGross = liquidityGross;
  this.liquidityNet = liquidityNet;
  this.outerFeeGrowth0Token = outerFeeGrowth0Token;
  this.outerFeeGrowth1Token = outerFeeGrowth1Token;
};
var DictionaryTickInfo = {
  serialize: function serialize(src, builder) {
    builder.storeUint(src.liquidityGross, 256);
    builder.storeInt(src.liquidityNet, 128);
    builder.storeUint(src.outerFeeGrowth0Token, 256);
    builder.storeUint(src.outerFeeGrowth1Token, 256);
  },
  parse: function parse(src) {
    var tickInfo = new TickInfoWrapper();
    tickInfo.liquidityGross = src.loadUintBig(256);
    tickInfo.liquidityNet = src.loadIntBig(128);
    tickInfo.outerFeeGrowth0Token = src.loadUintBig(256);
    tickInfo.outerFeeGrowth1Token = src.loadUintBig(256);
    return tickInfo;
  }
};
function embedJettonData(content, jetton0Name, decimals0, jetton1Name, decimals1) {
  var p = content.beginParse();
  //console.log("embedJettonData l0 ", Buffer.from(jetton0Name).length )
  //console.log("embedJettonData l1 ", Buffer.from(jetton1Name).length )
  var result = beginCell().storeInt(p.loadUint(8), 8).storeMaybeRef(p.loadRef()).storeUint(decimals0, 6).storeUint(Buffer.from(jetton0Name).length, 8).storeBuffer(Buffer.from(jetton0Name)).storeUint(decimals1, 6).storeUint(Buffer.from(jetton1Name).length, 8).storeBuffer(Buffer.from(jetton1Name)).endCell();
  return result;
}
var nftContentToPack = {
  name: 'AMM Pool Minter',
  description: 'AMM Pool LP Minter',
  cover_image: 'https://tonco.io/static/tonco-cover.jpeg',
  image: 'https://tonco.io/static/tonco-astro.png'
};
//export const nftContentPackedDefault: Cell =  embedJettonData(packJettonOnchainMetadata(nftContentToPack), "jetton0", 10, "jetton1", 11)
var nftContentPackedDefault = /*#__PURE__*/packJettonOnchainMetadata(nftContentToPack);
var nftItemContentToPack = {
  name: 'AMM Pool Position',
  description: 'LP Position',
  image: 'https://tonco.io/static/tonco-astro.png'
};
var nftItemContentPackedDefault = /*#__PURE__*/packJettonOnchainMetadata(nftItemContentToPack);
//const nftItemContentPacked: Cell =  packOffchainMetadata (nftItemContent1ToPack)
/* This function creates the config only form the values that affect the address */
function poolv3StateInitConfig(jetton0Wallet, jetton1Wallet, accountV3Code, positionNftV3Code, routerAddress) {
  var order = PoolV3Contract.orderJettonId(jetton0Wallet, jetton1Wallet);
  var config = {
    router_address: routerAddress,
    jetton0_wallet: order ? jetton0Wallet : jetton1Wallet,
    jetton1_wallet: order ? jetton1Wallet : jetton0Wallet,
    accountv3_code: accountV3Code,
    position_nftv3_code: positionNftV3Code
  };
  return config;
}
function poolv3ContractConfigToCell(config) {
  var _config$lp_fee_base, _config$protocol_fee, _config$lp_fee_curren, _config$tick_spacing, _config$tick, _config$price_sqrt, _config$liquidity, _config$admin_address, _config$nftContent, _config$nftItemConten;
  var ticks = Dictionary.empty(Dictionary.Keys.Int(24), DictionaryTickInfo);
  return beginCell().storeAddress(config.router_address).storeUint((_config$lp_fee_base = config.lp_fee_base) != null ? _config$lp_fee_base : 30, 16).storeUint((_config$protocol_fee = config.protocol_fee) != null ? _config$protocol_fee : 30, 16).storeUint((_config$lp_fee_curren = config.lp_fee_current) != null ? _config$lp_fee_curren : 30, 16).storeAddress(config.jetton0_wallet).storeAddress(config.jetton1_wallet).storeUint((_config$tick_spacing = config.tick_spacing) != null ? _config$tick_spacing : 1, 24).storeUint(0, 64) // poolv3::seqno
  .storeRef(beginCell().storeUint(BigInt(0), 256) // poolv3::feeGrowthGlobal0X128
  .storeUint(BigInt(0), 256) // poolv3::feeGrowthGlobal1X128
  .storeUint(BigInt(0), 128) // poolv3::collectedProtocolFee0
  .storeUint(BigInt(0), 128) // poolv3::collectedProtocolFee1
  .storeCoins(BigInt(0)) // poolv3::reserve0
  .storeCoins(BigInt(0)) // poolv3::reserve1
  .endCell()).storeRef(beginCell().storeUint(0, 1).storeInt((_config$tick = config.tick) != null ? _config$tick : 0, 24).storeUint((_config$price_sqrt = config.price_sqrt) != null ? _config$price_sqrt : 0, 160).storeUint((_config$liquidity = config.liquidity) != null ? _config$liquidity : 0, 128).storeUint(0, 24) // Occupied ticks
  .storeUint(0, 64) // NFT Inital counter
  .storeUint(0, 64) // NFT Active counter
  .storeAddress((_config$admin_address = config.admin_address) != null ? _config$admin_address : BLACK_HOLE_ADDRESS).storeAddress(BLACK_HOLE_ADDRESS) // poolv3::controller_address
  .storeRef(beginCell().storeAddress(BLACK_HOLE_ADDRESS) // poolv3::jetton0_minter
  .storeAddress(BLACK_HOLE_ADDRESS) // poolv3::jetton1_minter
  .endCell()).endCell()).storeRef(beginCell().storeDict(ticks).endCell()).storeRef(beginCell().storeRef(config.accountv3_code).storeRef(config.position_nftv3_code).storeRef((_config$nftContent = config.nftContent) != null ? _config$nftContent : new Cell()).storeRef((_config$nftItemConten = config.nftItemContent) != null ? _config$nftItemConten : new Cell()).endCell()).endCell();
}
/** Pool  **/
var PoolV3Contract = /*#__PURE__*/function () {
  function PoolV3Contract(address, init) {
    this.address = address;
    this.init = init;
  }
  PoolV3Contract.orderJettonId = function orderJettonId(jetton0Wallet, jetton1Wallet) {
    // let result1 =  beginCell().storeAddress(jetton0Wallet).endCell().hash() > beginCell().storeAddress(jetton1Wallet).endCell().hash()
    var strHex0 = beginCell().storeAddress(jetton0Wallet).endCell().hash().toString('hex');
    var strHex1 = beginCell().storeAddress(jetton1Wallet).endCell().hash().toString('hex');
    var result2 = BigInt('0x' + strHex0) > BigInt('0x' + strHex1);
    //if (result1 != result2) throw Error("Unexpected")
    return result2;
  };
  PoolV3Contract.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = poolv3ContractConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new PoolV3Contract(address, init);
  };
  var _proto = PoolV3Contract.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value, tickSpacing, sqrtPriceX96, opts) {
      var _opts$nftContentPacke, _opts$nftItemContentP;
      var minterCell, body;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!opts.activate_pool) {
              opts.activate_pool = false;
            }
            minterCell = null;
            if (opts.jetton0Minter && opts.jetton0Minter) {
              minterCell = beginCell().storeAddress(opts.jetton0Minter).storeAddress(opts.jetton1Minter).endCell();
            }
            if (opts.is_from_admin == undefined) {
              opts.is_from_admin = true;
            }
            body = beginCell().storeUint(ContractOpcodes.POOLV3_INIT, 32) // OP code
            .storeUint(0, 64) // query_id
            .storeUint(opts.is_from_admin ? 1 : 0, 1) // is from admin.
            .storeUint(opts.admin ? 1 : 0, 1).storeAddress(opts.admin) // null is an invalid Address, but valid slice
            .storeUint(opts.controller ? 1 : 0, 1).storeAddress(opts.controller).storeUint(1, 1).storeUint(tickSpacing, 24).storeUint(1, 1).storeUint(sqrtPriceX96, 160).storeUint(1, 1).storeUint(opts.activate_pool ? 1 : 0, 1).storeUint(opts.protocolFee ? opts.protocolFee : IMPOSSIBLE_FEE, 16).storeUint(opts.lpFee ? opts.lpFee : IMPOSSIBLE_FEE, 16).storeUint(opts.currentFee ? opts.currentFee : IMPOSSIBLE_FEE, 16).storeRef((_opts$nftContentPacke = opts.nftContentPacked) != null ? _opts$nftContentPacke : nftContentPackedDefault).storeRef((_opts$nftItemContentP = opts.nftItemContentPacked) != null ? _opts$nftItemContentP : nftItemContentPackedDefault).storeMaybeRef(minterCell).endCell();
            _context.next = 7;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: body
            });
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3, _x4, _x5, _x6) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  PoolV3Contract.reinitMessage = function reinitMessage(opts) {
    var _opts$tickSpacing, _opts$sqrtPriceX, _opts$nftContentPacke2, _opts$nftItemContentP2;
    if (opts.is_from_admin == undefined) {
      opts.is_from_admin = true;
    }
    var minterCell = null;
    if (opts.jetton0Minter && opts.jetton0Minter) {
      minterCell = beginCell().storeAddress(opts.jetton0Minter).storeAddress(opts.jetton1Minter).endCell();
    }
    var body = beginCell().storeUint(ContractOpcodes.POOLV3_INIT, 32) // OP code
    .storeUint(0, 64) // query_id
    .storeUint(opts.is_from_admin ? 1 : 0, 1) // is_from_admin
    .storeUint(opts.admin == undefined ? 0 : 1, 1).storeAddress(opts.admin) // null is an invalid Address, but valid slice
    .storeUint(opts.controller == undefined ? 0 : 1, 1).storeAddress(opts.controller).storeUint(opts.tickSpacing == undefined ? 0 : 1, 1).storeUint((_opts$tickSpacing = opts.tickSpacing) != null ? _opts$tickSpacing : 0, 24).storeUint(opts.sqrtPriceX96 == undefined ? 0 : 1, 1).storeUint((_opts$sqrtPriceX = opts.sqrtPriceX96) != null ? _opts$sqrtPriceX : 0, 160).storeUint(opts.activate_pool == undefined ? 0 : 1, 1).storeUint(opts.activate_pool ? 1 : 0, 1).storeUint(opts.protocolFee ? opts.protocolFee : IMPOSSIBLE_FEE, 16).storeUint(opts.lpFee ? opts.lpFee : IMPOSSIBLE_FEE, 16).storeUint(opts.currentFee ? opts.currentFee : IMPOSSIBLE_FEE, 16).storeRef((_opts$nftContentPacke2 = opts.nftContentPacked) != null ? _opts$nftContentPacke2 : beginCell().endCell()).storeRef((_opts$nftItemContentP2 = opts.nftItemContentPacked) != null ? _opts$nftItemContentP2 : beginCell().endCell()).storeMaybeRef(minterCell).endCell();
    return body;
  };
  PoolV3Contract.unpackReinitMessage = function unpackReinitMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    var query_id = s.loadUint(64);
    var is_from_admin = s.loadUint(1) != 0;
    var setAdmin = s.loadUint(1);
    var admin = setAdmin == 1 ? s.loadAddress() : undefined;
    if (setAdmin == 0) {
      s.loadUint(2);
    }
    var setControl = s.loadUint(1);
    var controller = setControl == 1 ? s.loadAddress() : undefined;
    if (setControl == 0) {
      s.loadUint(2);
    }
    var setTickSpacing = s.loadUint(1);
    var tickSpacingV = s.loadUint(24);
    var tickSpacing = setTickSpacing != 0 ? tickSpacingV : undefined;
    var setPrice = s.loadUint(1);
    var sqrtPriceX96V = s.loadUintBig(160);
    var sqrtPriceX96 = setPrice != 0 ? sqrtPriceX96V : undefined;
    var setActive = s.loadUint(1);
    var activate_poolV = s.loadUint(1) == 1;
    var activate_pool = setActive != 0 ? activate_poolV : undefined;
    var protocolFeeV = s.loadUint(16);
    var protocolFee = protocolFeeV < IMPOSSIBLE_FEE ? protocolFeeV : undefined;
    var lpFeeV = s.loadUint(16);
    var lpFee = lpFeeV < IMPOSSIBLE_FEE ? lpFeeV : undefined;
    var currentFeeV = s.loadUint(16);
    var currentFee = currentFeeV < IMPOSSIBLE_FEE ? currentFeeV : undefined;
    var nftContentPacked = s.loadRef();
    var nftItemContentPacked = s.loadRef();
    return {
      is_from_admin: is_from_admin,
      admin: admin,
      controller: controller,
      tickSpacing: tickSpacing,
      sqrtPriceX96: sqrtPriceX96,
      activate_pool: activate_pool,
      nftContentPacked: nftContentPacked,
      nftItemContentPacked: nftItemContentPacked,
      protocolFee: protocolFee,
      lpFee: lpFee,
      currentFee: currentFee
    };
  };
  _proto.sendReinit = /*#__PURE__*/function () {
    var _sendReinit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, via, value, opts) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: PoolV3Contract.reinitMessage(opts)
            });
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function sendReinit(_x7, _x8, _x9, _x10) {
      return _sendReinit.apply(this, arguments);
    }
    return sendReinit;
  }();
  PoolV3Contract.messageSetFees = function messageSetFees(protocolFee, lpFee, currentFee) {
    return beginCell().storeUint(ContractOpcodes.POOLV3_SET_FEE, 32) // OP code
    .storeUint(0, 64) // query_id
    .storeUint(protocolFee, 16).storeUint(lpFee, 16).storeUint(currentFee, 16).endCell();
  };
  PoolV3Contract.unpackSetFeesMessage = function unpackSetFeesMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.POOLV3_SET_FEE) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    var protocolFee = s.loadUint(16);
    var lpFee = s.loadUint(16);
    var currentFee = s.loadUint(16);
    return {
      protocolFee: protocolFee,
      lpFee: lpFee,
      currentFee: currentFee
    };
  };
  _proto.sendSetFees = /*#__PURE__*/function () {
    var _sendSetFees = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, sender, value, protocolFee, lpFee, currentFee) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            msg_body = PoolV3Contract.messageSetFees(protocolFee, lpFee, currentFee);
            _context3.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function sendSetFees(_x11, _x12, _x13, _x14, _x15, _x16) {
      return _sendSetFees.apply(this, arguments);
    }
    return sendSetFees;
  }();
  _proto.sendLockPool = /*#__PURE__*/function () {
    var _sendLockPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.POOLV3_LOCK, 32) // OP code
            .storeUint(0, 64) // query_id
            .endCell();
            _context4.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendLockPool(_x17, _x18, _x19) {
      return _sendLockPool.apply(this, arguments);
    }
    return sendLockPool;
  }();
  _proto.sendUnlockPool = /*#__PURE__*/function () {
    var _sendUnlockPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.POOLV3_UNLOCK, 32) // OP code
            .storeUint(0, 64) // query_id
            .endCell();
            _context5.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendUnlockPool(_x20, _x21, _x22) {
      return _sendUnlockPool.apply(this, arguments);
    }
    return sendUnlockPool;
  }();
  PoolV3Contract.messageCollectProtocol = function messageCollectProtocol() {
    return beginCell().storeUint(ContractOpcodes.POOLV3_COLLECT_PROTOCOL, 32) // OP code
    .storeUint(0, 64) // query_id
    .endCell();
  };
  PoolV3Contract.unpackCollectProtocolMessage = function unpackCollectProtocolMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.POOLV3_COLLECT_PROTOCOL) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
  };
  _proto.sendCollectProtocol = /*#__PURE__*/function () {
    var _sendCollectProtocol = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider, sender, value) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: PoolV3Contract.messageCollectProtocol()
            });
          case 2:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function sendCollectProtocol(_x23, _x24, _x25) {
      return _sendCollectProtocol.apply(this, arguments);
    }
    return sendCollectProtocol;
  }();
  _proto.sendBurn = /*#__PURE__*/function () {
    var _sendBurn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider, via, value, nftIndex, tickLower, tickUpper, liquidity2Burn) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return provider.internal(via, {
              value: value,
              body: beginCell().storeUint(ContractOpcodes.POOLV3_START_BURN, 32) // op
              .storeUint(0, 64) // query id
              .storeUint(nftIndex, 64).storeUint(liquidity2Burn, 128).storeInt(tickLower, 24).storeInt(tickUpper, 24).endCell()
            });
          case 2:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function sendBurn(_x26, _x27, _x28, _x29, _x30, _x31, _x32) {
      return _sendBurn.apply(this, arguments);
    }
    return sendBurn;
  }() /** Getters **/;
  _proto.getIsActive =
  /*#__PURE__*/
  function () {
    var _getIsActive = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(provider) {
      var _yield$provider$get, stack;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return provider.get('getIsActive', []);
          case 2:
            _yield$provider$get = _context8.sent;
            stack = _yield$provider$get.stack;
            return _context8.abrupt("return", stack.readBoolean());
          case 5:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function getIsActive(_x33) {
      return _getIsActive.apply(this, arguments);
    }
    return getIsActive;
  }() /* If not debug, it can actually would throw the exception */;
  _proto.getIsDebug =
  /*#__PURE__*/
  function () {
    var _getIsDebug = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(provider) {
      var _yield$provider$get2, stack;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.prev = 0;
            _context9.next = 3;
            return provider.get('isDebugBuild', []);
          case 3:
            _yield$provider$get2 = _context9.sent;
            stack = _yield$provider$get2.stack;
            return _context9.abrupt("return", stack.readBoolean());
          case 8:
            _context9.prev = 8;
            _context9.t0 = _context9["catch"](0);
            return _context9.abrupt("return", false);
          case 11:
          case "end":
            return _context9.stop();
        }
      }, _callee9, null, [[0, 8]]);
    }));
    function getIsDebug(_x34) {
      return _getIsDebug.apply(this, arguments);
    }
    return getIsDebug;
  }();
  _proto.getPoolStateAndConfiguration = /*#__PURE__*/function () {
    var _getPoolStateAndConfiguration = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {
      var _yield$provider$get3, stack;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return provider.get('getPoolStateAndConfiguration', []);
          case 2:
            _yield$provider$get3 = _context10.sent;
            stack = _yield$provider$get3.stack;
            return _context10.abrupt("return", {
              router_address: stack.readAddress(),
              admin_address: stack.readAddress(),
              controller_address: stack.readAddress(),
              jetton0_wallet: stack.readAddress(),
              jetton1_wallet: stack.readAddress(),
              jetton0_minter: stack.readAddress(),
              jetton1_minter: stack.readAddress(),
              pool_active: stack.readBoolean(),
              tick_spacing: stack.readNumber(),
              lp_fee_base: stack.readNumber(),
              protocol_fee: stack.readNumber(),
              lp_fee_current: stack.readNumber(),
              tick: stack.readNumber(),
              price_sqrt: stack.readBigNumber(),
              liquidity: stack.readBigNumber(),
              feeGrowthGlobal0X128: stack.readBigNumber(),
              feeGrowthGlobal1X128: stack.readBigNumber(),
              collectedProtocolFee0: stack.readBigNumber(),
              collectedProtocolFee1: stack.readBigNumber(),
              nftv3item_counter: stack.readBigNumber(),
              reserve0: stack.readBigNumber(),
              reserve1: stack.readBigNumber(),
              nftv3items_active: stack.readBigNumber(),
              ticks_occupied: stack.readNumber(),
              seqno: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function getPoolStateAndConfiguration(_x35) {
      return _getPoolStateAndConfiguration.apply(this, arguments);
    }
    return getPoolStateAndConfiguration;
  }()
  /* Tick related getters */
  /**
   *  Returns a tick by tickNumber. If tick not inited - tick filled with zero will be returned.
   *  Also pervious tick and next tick numbers are returned
   *
   *
   *  @param provider   blockchain access provider
   *  @param tickNumber Tick to extract data for
   *
   **/
  ;
  _proto.getTickInfo =
  /*#__PURE__*/
  function () {
    var _getTickInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(provider, tickNumber) {
      var _result$0$outerFeeGro, _result$0$outerFeeGro2;
      var result, tickInfo;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return this.getTickInfosFromArr(provider, tickNumber - 1, 1, false, true);
          case 2:
            result = _context11.sent;
            if (!(result.length == 0 || result[0].tickNum != tickNumber)) {
              _context11.next = 5;
              break;
            }
            return _context11.abrupt("return", new TickInfoWrapper());
          case 5:
            tickInfo = new TickInfoWrapper();
            tickInfo.liquidityGross = result[0].liquidityGross;
            tickInfo.liquidityNet = result[0].liquidityNet;
            tickInfo.outerFeeGrowth0Token = (_result$0$outerFeeGro = result[0].outerFeeGrowth0Token) != null ? _result$0$outerFeeGro : BigInt(0);
            tickInfo.outerFeeGrowth1Token = (_result$0$outerFeeGro2 = result[0].outerFeeGrowth1Token) != null ? _result$0$outerFeeGro2 : BigInt(0);
            return _context11.abrupt("return", tickInfo);
          case 11:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function getTickInfo(_x36, _x37) {
      return _getTickInfo.apply(this, arguments);
    }
    return getTickInfo;
  }();
  _proto.getTickInfosAll = /*#__PURE__*/function () {
    var _getTickInfosAll = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(provider) {
      var _yield$provider$get4, stack, valueReader, dict, result, tickKeys, _iterator, _step, key, info;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return provider.get('getAllTickInfos', []);
          case 2:
            _yield$provider$get4 = _context12.sent;
            stack = _yield$provider$get4.stack;
            if (!(stack.peek().type !== 'cell')) {
              _context12.next = 6;
              break;
            }
            return _context12.abrupt("return", []);
          case 6:
            valueReader = stack.readCell();
            dict = Dictionary.loadDirect(Dictionary.Keys.Int(24), DictionaryTickInfo, valueReader);
            result = [];
            tickKeys = dict.keys();
            tickKeys.sort(function (a, b) {
              return a - b;
            });
            for (_iterator = _createForOfIteratorHelperLoose(tickKeys); !(_step = _iterator()).done;) {
              key = _step.value;
              info = dict.get(key);
              result.push({
                tickNum: key,
                liquidityGross: info.liquidityGross,
                liquidityNet: info.liquidityNet,
                outerFeeGrowth0Token: info.outerFeeGrowth0Token,
                outerFeeGrowth1Token: info.outerFeeGrowth1Token
              });
            }
            return _context12.abrupt("return", result);
          case 13:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    function getTickInfosAll(_x38) {
      return _getTickInfosAll.apply(this, arguments);
    }
    return getTickInfosAll;
  }()
  /**
   *  Returns a hash object of ticks infos with all internal data starting from key >=tickNumber  or key <= tickNumber
   *  and no more then number. Unfortunately there is an internal limit of 255 tickInfos
   *
   *
   *  @param provider   blockchain access provider
   *  @param tickNumber Starting tick. Ticks greater or equal will be returned with back == false, with back == true - less or equal keys will be enumerated
   *  @param amount     Number of tick infos to be returned
   *  @param back       directions of ticks
   *  @param full       should fee related fields be filled
   *
   *
   **/
  ;
  _proto.getTickInfosFromArr =
  /*#__PURE__*/
  function () {
    var _getTickInfosFromArr = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(provider, tickNumber, amount, back, full) {
      var _yield$provider$get5, stack, valueReader, result, internalReader, infoTuple, tickInfo;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            if (back === void 0) {
              back = false;
            }
            if (full === void 0) {
              full = false;
            }
            _context13.next = 4;
            return provider.get('getTickInfosFrom', [{
              type: 'int',
              value: BigInt(tickNumber)
            }, {
              type: 'int',
              value: BigInt(amount)
            }, {
              type: 'int',
              value: BigInt(back ? 1 : 0)
            }, {
              type: 'int',
              value: BigInt(full ? 1 : 0)
            }]);
          case 4:
            _yield$provider$get5 = _context13.sent;
            stack = _yield$provider$get5.stack;
            if (!(stack.peek().type !== 'tuple')) {
              _context13.next = 8;
              break;
            }
            return _context13.abrupt("return", []);
          case 8:
            valueReader = stack.readTuple();
            result = [];
            while (valueReader.remaining) {
              // console.log("Outer iteration")
              internalReader = valueReader.readTuple();
              while (internalReader.remaining) {
                // console.log("Inner iteration")
                infoTuple = internalReader.readTuple();
                tickInfo = {
                  tickNum: infoTuple.readNumber(),
                  liquidityGross: infoTuple.readBigNumber(),
                  liquidityNet: infoTuple.readBigNumber(),
                  outerFeeGrowth0Token: full ? infoTuple.readBigNumber() : BigInt(0),
                  outerFeeGrowth1Token: full ? infoTuple.readBigNumber() : BigInt(0)
                };
                result.push(tickInfo);
              }
            }
            return _context13.abrupt("return", result);
          case 12:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    }));
    function getTickInfosFromArr(_x39, _x40, _x41, _x42, _x43) {
      return _getTickInfosFromArr.apply(this, arguments);
    }
    return getTickInfosFromArr;
  }();
  _proto.getMintEstimate = /*#__PURE__*/function () {
    var _getMintEstimate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(provider, tickLower, tickUpper, liquidity) {
      var _yield$provider$get6, stack;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return provider.get('getMintEstimate', [{
              type: 'int',
              value: BigInt(tickLower)
            }, {
              type: 'int',
              value: BigInt(tickUpper)
            }, {
              type: 'int',
              value: BigInt(liquidity)
            }]);
          case 2:
            _yield$provider$get6 = _context14.sent;
            stack = _yield$provider$get6.stack;
            return _context14.abrupt("return", {
              amount0: stack.readBigNumber(),
              amount1: stack.readBigNumber(),
              mintErrors: stack.readNumber()
            });
          case 5:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    }));
    function getMintEstimate(_x44, _x45, _x46, _x47) {
      return _getMintEstimate.apply(this, arguments);
    }
    return getMintEstimate;
  }();
  _proto.getSwapEstimate = /*#__PURE__*/function () {
    var _getSwapEstimate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(provider, zeroForOne, amount, sqrtPriceLimitX96, minOutAmount, gasLimit) {
      var _yield$provider$get7, stack;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            if (minOutAmount === void 0) {
              minOutAmount = /*#__PURE__*/BigInt(0);
            }
            if (gasLimit === void 0) {
              gasLimit = /*#__PURE__*/BigInt(0);
            }
            _context15.next = 4;
            return provider.get('getSwapEstimateGas', [{
              type: 'int',
              value: BigInt(zeroForOne ? 1 : 0)
            }, {
              type: 'int',
              value: BigInt(amount)
            }, {
              type: 'int',
              value: BigInt(sqrtPriceLimitX96)
            }, {
              type: 'int',
              value: BigInt(minOutAmount)
            }, {
              type: 'int',
              value: BigInt(gasLimit)
            }]);
          case 4:
            _yield$provider$get7 = _context15.sent;
            stack = _yield$provider$get7.stack;
            return _context15.abrupt("return", {
              amount0: stack.readBigNumber(),
              amount1: stack.readBigNumber()
            });
          case 7:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    }));
    function getSwapEstimate(_x48, _x49, _x50, _x51, _x52, _x53) {
      return _getSwapEstimate.apply(this, arguments);
    }
    return getSwapEstimate;
  }();
  _proto.getCollectedFees = /*#__PURE__*/function () {
    var _getCollectedFees = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(provider, tickLower, tickUpper, posLiquidityDelta, posFeeGrowthInside0X128, posFeeGrowthInside1X128) {
      var _yield$provider$get8, stack;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return provider.get('getCollectedFees', [{
              type: 'int',
              value: BigInt(tickLower)
            }, {
              type: 'int',
              value: BigInt(tickUpper)
            }, {
              type: 'int',
              value: BigInt(posLiquidityDelta)
            }, {
              type: 'int',
              value: BigInt(posFeeGrowthInside0X128)
            }, {
              type: 'int',
              value: BigInt(posFeeGrowthInside1X128)
            }]);
          case 2:
            _yield$provider$get8 = _context16.sent;
            stack = _yield$provider$get8.stack;
            return _context16.abrupt("return", {
              amount0: stack.readBigNumber(),
              amount1: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    }));
    function getCollectedFees(_x54, _x55, _x56, _x57, _x58, _x59) {
      return _getCollectedFees.apply(this, arguments);
    }
    return getCollectedFees;
  }();
  _proto.getFeeGrowthInside = /*#__PURE__*/function () {
    var _getFeeGrowthInside = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(provider, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
      var _yield$provider$get9, stack;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return provider.get('getFeeGrowthInside', [{
              type: 'int',
              value: BigInt(tickLower)
            }, {
              type: 'int',
              value: BigInt(tickUpper)
            }, {
              type: 'int',
              value: BigInt(tickCurrent)
            }, {
              type: 'int',
              value: BigInt(feeGrowthGlobal0X128)
            }, {
              type: 'int',
              value: BigInt(feeGrowthGlobal1X128)
            }]);
          case 2:
            _yield$provider$get9 = _context17.sent;
            stack = _yield$provider$get9.stack;
            return _context17.abrupt("return", {
              feeGrowthInside0X128: stack.readBigNumber(),
              feeGrowthInside1X128: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    }));
    function getFeeGrowthInside(_x60, _x61, _x62, _x63, _x64, _x65) {
      return _getFeeGrowthInside.apply(this, arguments);
    }
    return getFeeGrowthInside;
  }() /* Subcontracts getters */;
  _proto.getUserAccountAddress =
  /*#__PURE__*/
  function () {
    var _getUserAccountAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(provider, owner) {
      var res;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return provider.get('getUserAccountAddress', [{
              type: 'slice',
              cell: beginCell().storeAddress(owner).endCell()
            }]);
          case 2:
            res = _context18.sent;
            return _context18.abrupt("return", res.stack.readAddress());
          case 4:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    }));
    function getUserAccountAddress(_x66, _x67) {
      return _getUserAccountAddress.apply(this, arguments);
    }
    return getUserAccountAddress;
  }();
  _proto.getNFTAddressByIndex = /*#__PURE__*/function () {
    var _getNFTAddressByIndex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(provider, index) {
      var res;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return provider.get('get_nft_address_by_index', [{
              type: 'int',
              value: BigInt(index)
            }]);
          case 2:
            res = _context19.sent;
            return _context19.abrupt("return", res.stack.readAddress());
          case 4:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    }));
    function getNFTAddressByIndex(_x68, _x69) {
      return _getNFTAddressByIndex.apply(this, arguments);
    }
    return getNFTAddressByIndex;
  }();
  _proto.getNFTCollectionContent = /*#__PURE__*/function () {
    var _getNFTCollectionContent = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(provider) {
      var res;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return provider.get('get_collection_data', []);
          case 2:
            res = _context20.sent;
            return _context20.abrupt("return", {
              nftv3item_counter: res.stack.readBigNumber(),
              nftv3_content: res.stack.readCell(),
              router_address: res.stack.readAddress()
            });
          case 4:
          case "end":
            return _context20.stop();
        }
      }, _callee20);
    }));
    function getNFTCollectionContent(_x70) {
      return _getNFTCollectionContent.apply(this, arguments);
    }
    return getNFTCollectionContent;
  }();
  _proto.getNFTContent = /*#__PURE__*/function () {
    var _getNFTContent = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(provider, index, nftItemContent) {
      var res;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return provider.get('get_nft_content', [{
              type: 'int',
              value: BigInt(index)
            }, {
              type: 'cell',
              cell: nftItemContent
            }]);
          case 2:
            res = _context21.sent;
            return _context21.abrupt("return", res.stack.readCell());
          case 4:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    }));
    function getNFTContent(_x71, _x72, _x73) {
      return _getNFTContent.apply(this, arguments);
    }
    return getNFTContent;
  }() /* Access code of subcontracts */;
  _proto.getChildContracts =
  /*#__PURE__*/
  function () {
    var _getChildContracts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(provider) {
      var _yield$provider$get10, stack;
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            _context22.next = 2;
            return provider.get('getChildContracts', []);
          case 2:
            _yield$provider$get10 = _context22.sent;
            stack = _yield$provider$get10.stack;
            return _context22.abrupt("return", {
              accountCode: stack.readCell(),
              positionNFTCode: stack.readCell(),
              nftCollectionContent: stack.readCell(),
              nftItemContent: stack.readCell()
            });
          case 5:
          case "end":
            return _context22.stop();
        }
      }, _callee22);
    }));
    function getChildContracts(_x74) {
      return _getChildContracts.apply(this, arguments);
    }
    return getChildContracts;
  }();
  return PoolV3Contract;
}();

function packPoolData(jetton0Wallet, jetton1Wallet, accountV3Code, positionNftV3Code, routerAddress) {
  var config = {
    router_address: routerAddress,
    jetton0_wallet: jetton0Wallet,
    jetton1_wallet: jetton1Wallet,
    accountv3_code: accountV3Code,
    position_nftv3_code: positionNftV3Code
  };
  return poolv3ContractConfigToCell(config);
}
function calculatePoolStateInit(jetton0Address, jetton1Address, poolCode, accountV3Code, positionNftV3Code, routerAddress) {
  var poolData;
  if (PoolV3Contract.orderJettonId(jetton0Address, jetton1Address)) {
    poolData = packPoolData(jetton0Address, jetton1Address, accountV3Code, positionNftV3Code, routerAddress);
  } else {
    poolData = packPoolData(jetton1Address, jetton0Address, accountV3Code, positionNftV3Code, routerAddress);
  }
  return beginCell().storeUint(0, 2).storeMaybeRef(poolCode).storeMaybeRef(poolData).storeUint(0, 1).endCell();
}
function calculateAddress(stateInit, workchain) {
  return new Address(workchain, stateInit.hash());
}
function computePoolAddress(jettonWallet0, jettonWallet1) {
  var routerAddress = Address.parse(ROUTER);
  var stateInit = calculatePoolStateInit(jettonWallet0, jettonWallet1, POOLV3_CODE, ACCOUNTV3_CODE, POSITIONV3_CODE, routerAddress);
  return calculateAddress(stateInit, routerAddress.workChain);
}

/**
 * By default, pools will not allow operations that require ticks.
 */
var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/new NoTickDataProvider();
/**
 * Represents a V3 pool
 */
var Pool = /*#__PURE__*/function () {
  /**
   * Construct a pool
   * @param tokenA One of the tokens in the pool
   * @param tokenB The other token in the pool
   * @param fee The fee in hundredths of a bips of the input amount of every swap that is collected by the pool
   * @param sqrtRatioX96 The sqrt of the current ratio of amounts of token1 to token0
   * @param liquidity The current value of in range liquidity
   * @param tickCurrent The current tick of the pool
   * @param ticks The current state of the pool ticks or a data provider that can return tick data
   * @param _tickSpacing The spacing between ticks
   */
  function Pool(jettonA, jettonB, fee, sqrtRatioX96, liquidity, tickCurrent, _tickSpacing, ticks, jetton0_wallet, jetton1_wallet) {
    if (ticks === void 0) {
      ticks = NO_TICK_DATA_PROVIDER_DEFAULT;
    }
    !(Number.isInteger(fee) && fee < 1000000) ? process.env.NODE_ENV !== "production" ? invariant(false, 'FEE') : invariant(false) : void 0;
    var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent);
    var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1);
    !(JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) && JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PRICE_BOUNDS') : invariant(false) : void 0;
    // always create a copy of the list since we want the pool's tick list to be immutable
    var _ref = [jettonA, jettonB];
    this.jetton0 = _ref[0];
    this.jetton1 = _ref[1];
    var _ref2 = [jetton0_wallet, jetton1_wallet];
    this.jetton0_wallet = _ref2[0];
    this.jetton1_wallet = _ref2[1];
    this.fee = fee;
    this.sqrtRatioX96 = JSBI.BigInt(sqrtRatioX96);
    this.liquidity = JSBI.BigInt(liquidity);
    this.tickCurrent = tickCurrent;
    this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, _tickSpacing) : ticks;
    this._tickSpacing = _tickSpacing;
  }
  /**
   * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
   */
  Pool.getAddress = function getAddress(token0_wallet, token1_wallet) {
    if (!token0_wallet || !token1_wallet) return Address.parse(ADDRESS_ZERO);
    return computePoolAddress(Address.parse(token0_wallet), Address.parse(token1_wallet));
  }
  /**
   * Returns true if the token is either token0 or token1
   * @param token The token to check
   * @returns True if token is either token0 or token
   */;
  var _proto = Pool.prototype;
  _proto.involvesToken = function involvesToken(jetton) {
    return jetton.equals(this.jetton0) || jetton.equals(this.jetton1);
  }
  /**
   * Return the price of the given token in terms of the other token in the pool.
   * @param token The token to return price of
   * @returns The price of the given token, in terms of the other.
   */;
  _proto.priceOf = function priceOf(jetton) {
    !this.involvesToken(jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
    return jetton.equals(this.jetton0) ? this.jetton0Price : this.jetton1Price;
  }
  /**
   * Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
   * @param inputAmount The input amount for which to quote the output amount
   * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit
   * @returns The output amount and the pool with updated state
   */;
  _proto.getOutputAmount =
  /*#__PURE__*/
  function () {
    var _getOutputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
      var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            !this.involvesToken(inputAmount.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
            zeroForOne = inputAmount.jetton.equals(this.jetton0);
            _context.next = 4;
            return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96);
          case 4:
            _yield$this$swap = _context.sent;
            outputAmount = _yield$this$swap.amountCalculated;
            sqrtRatioX96 = _yield$this$swap.sqrtRatioX96;
            liquidity = _yield$this$swap.liquidity;
            tickCurrent = _yield$this$swap.tickCurrent;
            outputToken = zeroForOne ? this.jetton1 : this.jetton0;
            return _context.abrupt("return", [JettonAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)), new Pool(this.jetton0, this.jetton1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickSpacing, this.tickDataProvider)]);
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getOutputAmount(_x, _x2) {
      return _getOutputAmount.apply(this, arguments);
    }
    return getOutputAmount;
  }()
  /**
   * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
   * @param outputAmount the output amount for which to quote the input amount
   * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap
   * @returns The input amount and the pool with updated state
   */
  ;
  _proto.getInputAmount =
  /*#__PURE__*/
  function () {
    var _getInputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
      var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            !this.involvesToken(outputAmount.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
            zeroForOne = outputAmount.jetton.equals(this.jetton1);
            _context2.next = 4;
            return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96);
          case 4:
            _yield$this$swap2 = _context2.sent;
            inputAmount = _yield$this$swap2.amountCalculated;
            sqrtRatioX96 = _yield$this$swap2.sqrtRatioX96;
            liquidity = _yield$this$swap2.liquidity;
            tickCurrent = _yield$this$swap2.tickCurrent;
            inputToken = zeroForOne ? this.jetton0 : this.jetton1;
            return _context2.abrupt("return", [JettonAmount.fromRawAmount(inputToken, inputAmount), new Pool(this.jetton0, this.jetton1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickSpacing, this.tickDataProvider)]);
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getInputAmount(_x3, _x4) {
      return _getInputAmount.apply(this, arguments);
    }
    return getInputAmount;
  }()
  /**
   * Executes a swap
   * @param zeroForOne Whether the amount in is token0 or token1
   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
   * @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap
   * @returns amountCalculated
   * @returns sqrtRatioX96
   * @returns liquidity
   * @returns tickCurrent
   */
  ;
  _proto.swap =
  /*#__PURE__*/
  function () {
    var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
      var exactInput, state, step, _yield$this$tickDataP, _SwapMath$computeSwap, liquidityNet;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!sqrtPriceLimitX96) sqrtPriceLimitX96 = zeroForOne ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE) : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE);
            if (zeroForOne) {
              !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_MIN') : invariant(false) : void 0;
              !JSBI.lessThan(sqrtPriceLimitX96, this.sqrtRatioX96) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_CURRENT') : invariant(false) : void 0;
            } else {
              !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_MAX') : invariant(false) : void 0;
              !JSBI.greaterThan(sqrtPriceLimitX96, this.sqrtRatioX96) ? process.env.NODE_ENV !== "production" ? invariant(false, 'RATIO_CURRENT') : invariant(false) : void 0;
            }
            exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO); // keep track of swap state
            state = {
              amountSpecifiedRemaining: amountSpecified,
              amountCalculated: ZERO,
              sqrtPriceX96: this.sqrtRatioX96,
              tick: this.tickCurrent,
              liquidity: this.liquidity
            }; // start swap while loop
          case 4:
            if (!(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 != sqrtPriceLimitX96)) {
              _context3.next = 35;
              break;
            }
            step = {};
            step.sqrtPriceStartX96 = state.sqrtPriceX96;
            // because each iteration of the while loop rounds, we can't optimize this code (relative to the smart contract)
            // by simply traversing to the next available tick, we instead need to exactly replicate
            // tickBitmap.nextInitializedTickWithinOneWord
            _context3.next = 9;
            return this.tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, this.tickSpacing);
          case 9:
            _yield$this$tickDataP = _context3.sent;
            step.tickNext = _yield$this$tickDataP[0];
            step.initialized = _yield$this$tickDataP[1];
            if (step.tickNext < TickMath.MIN_TICK) {
              step.tickNext = TickMath.MIN_TICK;
            } else if (step.tickNext > TickMath.MAX_TICK) {
              step.tickNext = TickMath.MAX_TICK;
            }
            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
            _SwapMath$computeSwap = SwapMath.computeSwapStep(state.sqrtPriceX96, (zeroForOne ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96) : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining, this.fee);
            state.sqrtPriceX96 = _SwapMath$computeSwap[0];
            step.amountIn = _SwapMath$computeSwap[1];
            step.amountOut = _SwapMath$computeSwap[2];
            step.feeAmount = _SwapMath$computeSwap[3];
            if (exactInput) {
              state.amountSpecifiedRemaining = JSBI.subtract(state.amountSpecifiedRemaining, JSBI.add(step.amountIn, step.feeAmount));
              state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut);
            } else {
              state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut);
              state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount));
            }
            // TODO
            if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
              _context3.next = 32;
              break;
            }
            if (!step.initialized) {
              _context3.next = 29;
              break;
            }
            _context3.t0 = JSBI;
            _context3.next = 25;
            return this.tickDataProvider.getTick(step.tickNext);
          case 25:
            _context3.t1 = _context3.sent.liquidityNet;
            liquidityNet = _context3.t0.BigInt.call(_context3.t0, _context3.t1);
            // if we're moving leftward, we interpret liquidityNet as the opposite sign
            // safe because liquidityNet cannot be type(int128).min
            if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE);
            state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
          case 29:
            state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
            _context3.next = 33;
            break;
          case 32:
            if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
              // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
              state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
            }
          case 33:
            _context3.next = 4;
            break;
          case 35:
            return _context3.abrupt("return", {
              amountCalculated: state.amountCalculated,
              sqrtRatioX96: state.sqrtPriceX96,
              liquidity: state.liquidity,
              tickCurrent: state.tick
            });
          case 36:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function swap(_x5, _x6, _x7) {
      return _swap.apply(this, arguments);
    }
    return swap;
  }();
  _createClass(Pool, [{
    key: "jetton0Price",
    get: function get() {
      var _this$_jetton0Price;
      return (_this$_jetton0Price = this._jetton0Price) != null ? _this$_jetton0Price : this._jetton0Price = new Price(this.jetton0, this.jetton1, Q192, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96));
    }
    /**
     * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
     */
  }, {
    key: "jetton1Price",
    get: function get() {
      var _this$_jetton1Price;
      return (_this$_jetton1Price = this._jetton1Price) != null ? _this$_jetton1Price : this._jetton1Price = new Price(this.jetton1, this.jetton0, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96), Q192);
    }
  }, {
    key: "tickSpacing",
    get: function get() {
      return this._tickSpacing;
    }
  }]);
  return Pool;
}();

var MAX_SAFE_INTEGER = /*#__PURE__*/JSBI.BigInt(Number.MAX_SAFE_INTEGER);
var ZERO$1 = /*#__PURE__*/JSBI.BigInt(0);
var ONE$1 = /*#__PURE__*/JSBI.BigInt(1);
var TWO$1 = /*#__PURE__*/JSBI.BigInt(2);
/**
 * Computes floor(sqrt(value))
 * @param value the value for which to compute the square root, rounded down
 */
function sqrt(value) {
  !JSBI.greaterThanOrEqual(value, ZERO$1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'NEGATIVE') : invariant(false) : void 0;
  // rely on built in sqrt if possible
  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {
    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));
  }
  var z;
  var x;
  z = value;
  x = JSBI.add(JSBI.divide(value, TWO$1), ONE$1);
  while (JSBI.lessThan(x, z)) {
    z = x;
    x = JSBI.divide(JSBI.add(JSBI.divide(value, x), x), TWO$1);
  }
  return z;
}

/**
 * Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0
 * @param amount1 The numerator amount i.e., the amount of token1
 * @param amount0 The denominator amount i.e., the amount of token0
 * @returns The sqrt ratio
 */
function encodeSqrtRatioX96(amount1, amount0) {
  var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));
  var denominator = JSBI.BigInt(amount0);
  var ratioX192 = JSBI.divide(numerator, denominator);
  return sqrt(ratioX192);
}

/**
 * Returns a price object corresponding to the input tick and the base/quote token
 * Inputs must be tokens because the address order is used to interpret the price represented by the tick
 * @param baseToken the base token of the price
 * @param quoteToken the quote token of the price
 * @param tick the tick for which to return the price
 */
function tickToPrice(baseToken, quoteToken, tick, isSorted) {
  if (isSorted === void 0) {
    isSorted = true;
  }
  var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);
  // return new Price(baseToken, quoteToken, Q192, ratioX192);
  return isSorted ? new Price(baseToken, quoteToken, Q192, ratioX192) : new Price(baseToken, quoteToken, ratioX192, Q192);
}
/**
 * Returns the first tick for which the given price is greater than or equal to the tick price
 * @param price for which to return the closest tick that represents a price less than or equal to the input price,
 * i.e. the price of the returned tick is less than or equal to the input price
 */
function priceToClosestTick(price) {
  var sqrtRatioX96 =  encodeSqrtRatioX96(price.numerator, price.denominator) ;
  var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);
  var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);
  {
    if (!price.lessThan(nextTickPrice)) {
      tick++;
    }
  }
  return tick;
}

/**
 * Returns an imprecise maximum amount of liquidity received for a given amount of token 0.
 * This function is available to accommodate LiquidityAmounts#getLiquidityForAmount0 in the v3 periphery,
 * which could be more precise by at least 32 bits by dividing by Q64 instead of Q96 in the intermediate step,
 * and shifting the subtracted ratio left by 32 bits. This imprecise calculation will likely be replaced in a future
 * v3 router contract.
 * @param sqrtRatioAX96 The price at the lower boundary
 * @param sqrtRatioBX96 The price at the upper boundary
 * @param amount0 The token0 amount
 * @returns liquidity for amount0, imprecise
 */
function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref[0];
    sqrtRatioBX96 = _ref[1];
  }
  var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);
  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
}
/**
 * Returns a precise maximum amount of liquidity received for a given amount of token 0 by dividing by Q64 instead of Q96 in the intermediate step,
 * and shifting the subtracted ratio left by 32 bits.
 * @param sqrtRatioAX96 The price at the lower boundary
 * @param sqrtRatioBX96 The price at the upper boundary
 * @param amount0 The token0 amount
 * @returns liquidity for amount0, precise
 */
function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref2[0];
    sqrtRatioBX96 = _ref2[1];
  }
  var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);
  var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
  return JSBI.divide(numerator, denominator);
}
/**
 * Computes the maximum amount of liquidity received for a given amount of token1
 * @param sqrtRatioAX96 The price at the lower tick boundary
 * @param sqrtRatioBX96 The price at the upper tick boundary
 * @param amount1 The token1 amount
 * @returns liquidity for amount1
 */
function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref3 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref3[0];
    sqrtRatioBX96 = _ref3[1];
  }
  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
}
/**
 * Computes the maximum amount of liquidity received for a given amount of token0, token1,
 * and the prices at the tick boundaries.
 * @param sqrtRatioCurrentX96 the current price
 * @param sqrtRatioAX96 price at lower boundary
 * @param sqrtRatioBX96 price at upper boundary
 * @param amount0 token0 amount
 * @param amount1 token1 amount
 * @param useFullPrecision if false, liquidity will be maximized according to what the router can calculate,
 * not what core can theoretically support
 */
function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision) {
  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
    var _ref4 = [sqrtRatioBX96, sqrtRatioAX96];
    sqrtRatioAX96 = _ref4[0];
    sqrtRatioBX96 = _ref4[1];
  }
  var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;
  if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {
    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
  }
  if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {
    var liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0);
    var liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1);
    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1;
  }
  return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
}

var ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(100));
/**
 * Converts a fraction to a percent
 * @param fraction the fraction to convert
 */
function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
}
var Percent = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(Percent, _Fraction);
  function Percent(numerator, denominator) {
    var _this;
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    /**
     * This boolean prevents a fraction from being interpreted as a Percent
     */
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent.prototype;
  _proto.add = function add(other) {
    return toPercent(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract(other) {
    return toPercent(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide(other) {
    return toPercent(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
  };
  return Percent;
}(Fraction);

/**
 * Represents a position on a Algebra Pool
 */
var Position = /*#__PURE__*/function () {
  /**
   * Constructs a position for a given pool with the given liquidity
   * @param pool For which pool the liquidity is assigned
   * @param liquidity The amount of liquidity that is in the position
   * @param tickLower The lower tick of the position
   * @param tickUpper The upper tick of the position
   */
  function Position(_ref) {
    var pool = _ref.pool,
      liquidity = _ref.liquidity,
      tickLower = _ref.tickLower,
      tickUpper = _ref.tickUpper;
    // cached resuts for the getters
    this._token0Amount = null;
    this._token1Amount = null;
    this._mintAmounts = null;
    !(tickLower < tickUpper) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_ORDER') : invariant(false) : void 0;
    !(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_LOWER') : invariant(false) : void 0;
    !(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_UPPER') : invariant(false) : void 0;
    this.pool = pool;
    this.tickLower = tickLower;
    this.tickUpper = tickUpper;
    this.liquidity = JSBI.BigInt(liquidity);
  }
  /**
   * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
   * the current price for the pool
   */
  /**
   * Computes the maximum amount of liquidity received for a given amount of token0, token1,
   * and the prices at the tick boundaries.
   * @param pool The pool for which the position should be created
   * @param tickLower The lower tick of the position
   * @param tickUpper The upper tick of the position
   * @param amount0 token0 amount
   * @param amount1 token1 amount
   * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,
   * not what core can theoretically support
   * @returns The amount of liquidity for the position
   */
  Position.fromAmounts = function fromAmounts(_ref2) {
    var pool = _ref2.pool,
      tickLower = _ref2.tickLower,
      tickUpper = _ref2.tickUpper,
      amount0 = _ref2.amount0,
      amount1 = _ref2.amount1,
      useFullPrecision = _ref2.useFullPrecision;
    var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
    var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
    return new Position({
      pool: pool,
      tickLower: tickLower,
      tickUpper: tickUpper,
      liquidity: maxLiquidityForAmounts(pool.sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision)
    });
  }
  /**
   * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1
   * @param pool The pool for which the position is created
   * @param tickLower The lower tick
   * @param tickUpper The upper tick
   * @param amount0 The desired amount of token0
   * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
   * not what core can theoretically support
   * @returns The position
   */;
  Position.fromAmount0 = function fromAmount0(_ref3) {
    var pool = _ref3.pool,
      tickLower = _ref3.tickLower,
      tickUpper = _ref3.tickUpper,
      amount0 = _ref3.amount0,
      useFullPrecision = _ref3.useFullPrecision;
    return Position.fromAmounts({
      pool: pool,
      tickLower: tickLower,
      tickUpper: tickUpper,
      amount0: amount0,
      amount1: MaxUint256,
      useFullPrecision: useFullPrecision
    });
  }
  /**
   * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0
   * @param pool The pool for which the position is created
   * @param tickLower The lower tick
   * @param tickUpper The upper tick
   * @param amount1 The desired amount of token1
   * @returns The position
   */;
  Position.fromAmount1 = function fromAmount1(_ref4) {
    var pool = _ref4.pool,
      tickLower = _ref4.tickLower,
      tickUpper = _ref4.tickUpper,
      amount1 = _ref4.amount1;
    // this function always uses full precision,
    return Position.fromAmounts({
      pool: pool,
      tickLower: tickLower,
      tickUpper: tickUpper,
      amount0: MaxUint256,
      amount1: amount1,
      useFullPrecision: true
    });
  }
  /**
   * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
   * with the given slippage tolerance
   * @param slippageTolerance Tolerance of unfavorable slippage from the current price
   * @returns The amounts, with slippage
   */;
  var _proto = Position.prototype;
  _proto.mintAmountsWithSlippage = function mintAmountsWithSlippage(slippageTolerance) {
    // get lower/upper prices
    var _this$ratiosAfterSlip = this.ratiosAfterSlippage(slippageTolerance),
      sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper,
      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower;
    // construct counterfactual pools
    var poolLower = new Pool(this.pool.jetton0, this.pool.jetton1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower), this.pool.tickSpacing);
    var poolUpper = new Pool(this.pool.jetton0, this.pool.jetton1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper), this.pool.tickSpacing);
    // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
    var positionThatWillBeCreated = Position.fromAmounts(_extends({
      pool: this.pool,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }, this.mintAmounts, {
      useFullPrecision: false
    }));
    // we want the smaller amounts...
    // ...which occurs at the upper price for amount0...
    var amount0 = new Position({
      pool: poolUpper,
      liquidity: positionThatWillBeCreated.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).mintAmounts.amount0;
    // ...and the lower for amount1
    var amount1 = new Position({
      pool: poolLower,
      liquidity: positionThatWillBeCreated.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).mintAmounts.amount1;
    return {
      amount0: amount0,
      amount1: amount1
    };
  }
  /**
   * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the
   * position with the given slippage tolerance
   * @param slippageTolerance tolerance of unfavorable slippage from the current price
   * @returns The amounts, with slippage
   */;
  _proto.burnAmountsWithSlippage = function burnAmountsWithSlippage(slippageTolerance) {
    // get lower/upper prices
    var _this$ratiosAfterSlip2 = this.ratiosAfterSlippage(slippageTolerance),
      sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper,
      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower;
    // construct counterfactual pools
    var poolLower = new Pool(this.pool.jetton0, this.pool.jetton1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower), this.pool.tickSpacing);
    var poolUpper = new Pool(this.pool.jetton0, this.pool.jetton1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper), this.pool.tickSpacing);
    // we want the smaller amounts...
    // ...which occurs at the upper price for amount0...
    var amount0 = new Position({
      pool: poolUpper,
      liquidity: this.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).amount0;
    // ...and the lower for amount1
    var amount1 = new Position({
      pool: poolLower,
      liquidity: this.liquidity,
      tickLower: this.tickLower,
      tickUpper: this.tickUpper
    }).amount1;
    return {
      amount0: amount0.quotient,
      amount1: amount1.quotient
    };
  }
  /**
   * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
   * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
   * @returns The sqrt ratios after slippage
   */;
  _proto.ratiosAfterSlippage = function ratiosAfterSlippage(slippageTolerance) {
    var priceLower = this.pool.jetton0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance));
    var priceUpper = this.pool.jetton0Price.asFraction.multiply(slippageTolerance.add(1));
    var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);
    if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {
      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));
    }
    var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);
    if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {
      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));
    }
    return {
      sqrtRatioX96Lower: sqrtRatioX96Lower,
      sqrtRatioX96Upper: sqrtRatioX96Upper
    };
  };
  _createClass(Position, [{
    key: "mintAmounts",
    get: function get() {
      if (this._mintAmounts === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          return {
            amount0: SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
            amount1: ZERO
          };
        }
        if (this.pool.tickCurrent < this.tickUpper) {
          return {
            amount0: SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),
            amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, true)
          };
        }
        return {
          amount0: ZERO,
          amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true)
        };
      }
      return this._mintAmounts;
    }
    /**
     * Returns the price of token0 at the lower tick
     */
  }, {
    key: "token0PriceLower",
    get: function get() {
      return tickToPrice(this.pool.jetton0, this.pool.jetton1, this.tickLower);
    }
    /**
     * Returns the price of token0 at the upper tick
     */
  }, {
    key: "token0PriceUpper",
    get: function get() {
      return tickToPrice(this.pool.jetton0, this.pool.jetton1, this.tickUpper);
    }
    /**
     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
     */
  }, {
    key: "amount0",
    get: function get() {
      if (this._token0Amount === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          this._token0Amount = JettonAmount.fromRawAmount(this.pool.jetton0, SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        } else if (this.pool.tickCurrent < this.tickUpper) {
          this._token0Amount = JettonAmount.fromRawAmount(this.pool.jetton0, SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        } else {
          this._token0Amount = JettonAmount.fromRawAmount(this.pool.jetton0, ZERO);
        }
      }
      return this._token0Amount;
    }
    /**
     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
     */
  }, {
    key: "amount1",
    get: function get() {
      if (this._token1Amount === null) {
        if (this.pool.tickCurrent < this.tickLower) {
          this._token1Amount = JettonAmount.fromRawAmount(this.pool.jetton1, ZERO);
        } else if (this.pool.tickCurrent < this.tickUpper) {
          this._token1Amount = JettonAmount.fromRawAmount(this.pool.jetton1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, false));
        } else {
          this._token1Amount = JettonAmount.fromRawAmount(this.pool.jetton1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
        }
      }
      return this._token1Amount;
    }
  }]);
  return Position;
}();

/**
 * Represents a list of pools through which a swap can occur
 * @template TInput The input token
 * @template TOutput The output token
 */
var Route = /*#__PURE__*/function () {
  /**
   * Creates an instance of route.
   * @param pools An array of `Pool` objects, ordered by the route the swap will take
   * @param input The input token
   * @param output The output token
   */
  function Route(pools, input, output) {
    this._midPrice = null;
    !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
    // const chainId = pools[0].chainId;
    // const allOnSameChain = pools.every(pool => pool.chainId === chainId);
    // invariant(allOnSameChain, 'CHAIN_IDS');
    var wrappedInput = input;
    !pools[0].involvesToken(wrappedInput) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
    !pools[pools.length - 1].involvesToken(output) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
    /**
     * Normalizes token0-token1 order and selects the next token/fee step to add to the path
     * */
    var tokenPath = [wrappedInput];
    for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
        i = _step$value[0],
        pool = _step$value[1];
      var currentInputToken = tokenPath[i];
      !(currentInputToken.equals(pool.jetton0) || currentInputToken.equals(pool.jetton1)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PATH') : invariant(false) : void 0;
      var nextToken = currentInputToken.equals(pool.jetton0) ? pool.jetton1 : pool.jetton0;
      tokenPath.push(nextToken);
    }
    this.pools = pools;
    this.tokenPath = tokenPath;
    this.input = input;
    this.output = output != null ? output : tokenPath[tokenPath.length - 1];
  }
  /**
   * Returns the mid price of the route
   */
  _createClass(Route, [{
    key: "midPrice",
    get: function get() {
      if (this._midPrice !== null) return this._midPrice;
      var price = this.pools.slice(1).reduce(function (_ref, pool) {
        var nextInput = _ref.nextInput,
          price = _ref.price;
        return nextInput.equals(pool.jetton0) ? {
          nextInput: pool.jetton1,
          price: price.multiply(pool.jetton0Price)
        } : {
          nextInput: pool.jetton0,
          price: price.multiply(pool.jetton1Price)
        };
      }, this.pools[0].jetton0.equals(this.input) ? {
        nextInput: this.pools[0].jetton1,
        price: this.pools[0].jetton0Price
      } : {
        nextInput: this.pools[0].jetton0,
        price: this.pools[0].jetton1Price
      }).price;
      return this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator);
    }
  }]);
  return Route;
}();

// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to
// `maxSize` by removing the last item
function sortedInsert(items, add, maxSize, comparator) {
  !(maxSize > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX_SIZE_ZERO') : invariant(false) : void 0;
  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize
  !(items.length <= maxSize) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ITEMS_SIZE') : invariant(false) : void 0;
  // short circuit first item add
  if (items.length === 0) {
    items.push(add);
    return null;
  }
  var isFull = items.length === maxSize;
  // short circuit if full and the additional item does not come before the last item
  if (isFull && comparator(items[items.length - 1], add) <= 0) {
    return add;
  }
  var lo = 0;
  var hi = items.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (comparator(items[mid], add) <= 0) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  items.splice(lo, 0, add);
  return isFull ? items.pop() : null;
}

/**
 * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them
 * @template TInput The input token, either Ether or an ERC-20
 * @template TOutput The output token, either Ether or an ERC-20
 * @template TTradeType The trade type, either exact input or exact output
 * @param a The first trade to compare
 * @param b The second trade to compare
 * @returns A sorted ordering for two neighboring elements in a trade array
 */
function tradeComparator(a, b) {
  // must have same input and output token for comparison
  !a.inputAmount.jetton.equals(b.inputAmount.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT_CURRENCY') : invariant(false) : void 0;
  !a.outputAmount.jetton.equals(b.outputAmount.jetton) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT_CURRENCY') : invariant(false) : void 0;
  if (a.outputAmount.equalTo(b.outputAmount)) {
    if (a.inputAmount.equalTo(b.inputAmount)) {
      // consider the number of hops since each hop costs gas
      var aHops = a.swaps.reduce(function (total, cur) {
        return total + cur.route.tokenPath.length;
      }, 0);
      var bHops = b.swaps.reduce(function (total, cur) {
        return total + cur.route.tokenPath.length;
      }, 0);
      return aHops - bHops;
    }
    // trade A requires less input than trade B, so A should come first
    if (a.inputAmount.lessThan(b.inputAmount)) {
      return -1;
    }
    return 1;
  }
  // tradeA has less output than trade B, so should come second
  if (a.outputAmount.lessThan(b.outputAmount)) {
    return 1;
  }
  return -1;
}
/**
 * Represents a trade executed against a set of routes where some percentage of the input is
 * split across each route.
 *
 * Each route has its own set of pools. Pools can not be re-used across routes.
 *
 * Does not account for slippage, i.e., changes in price environment that can occur between
 * the time the trade is submitted and when it is executed.
 * @template TInput The input token, either Ether or an ERC-20
 * @template TOutput The output token, either Ether or an ERC-20
 * @template TTradeType The trade type, either exact input or exact output
 */
var Trade = /*#__PURE__*/function () {
  /**
   * Construct a trade by passing in the pre-computed property values
   * @param routes The routes through which the trade occurs
   * @param tradeType The type of trade, exact input or exact output
   */
  function Trade(_ref) {
    var routes = _ref.routes,
      tradeType = _ref.tradeType;
    var inputCurrency = routes[0].inputAmount.jetton;
    var outputCurrency = routes[0].outputAmount.jetton;
    !routes.every(function (_ref2) {
      var route = _ref2.route;
      return inputCurrency.equals(route.input);
    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT_CURRENCY_MATCH') : invariant(false) : void 0;
    !routes.every(function (_ref3) {
      var route = _ref3.route;
      return outputCurrency.equals(route.output);
    }) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT_CURRENCY_MATCH') : invariant(false) : void 0;
    var numPools = routes.map(function (_ref4) {
      var route = _ref4.route;
      return route.pools.length;
    }).reduce(function (total, cur) {
      return total + cur;
    }, 0);
    var poolAddressSet = new Set();
    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {
      var route = _step.value.route;
      for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done;) {
        var pool = _step2.value;
        poolAddressSet.add(computePoolAddress(Address.parse(pool.jetton0_wallet), Address.parse(pool.jetton1_wallet)).toString());
      }
    }
    !(numPools == poolAddressSet.size) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS_DUPLICATED') : invariant(false) : void 0;
    this.swaps = routes;
    this.tradeType = tradeType;
  }
  /**
   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes
   * this will return an error.
   *
   * When the trade consists of just a single route, this returns the route of the trade,
   * i.e. which pools the trade goes through.
   */
  /**
   * Constructs an exact in trade with the given amount in and route
   * @template TInput The input token, either Ether or an ERC-20
   * @template TOutput The output token, either Ether or an ERC-20
   * @param route The route of the exact in trade
   * @param amountIn The amount being passed in
   * @returns The exact in trade
   */
  Trade.exactIn =
  /*#__PURE__*/
  function () {
    var _exactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(route, amountIn) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function exactIn(_x, _x2) {
      return _exactIn.apply(this, arguments);
    }
    return exactIn;
  }()
  /**
   * Constructs an exact out trade with the given amount out and route
   * @template TInput The input token, either Ether or an ERC-20
   * @template TOutput The output token, either Ether or an ERC-20
   * @param route The route of the exact out trade
   * @param amountOut The amount returned by the trade
   * @returns The exact out trade
   */
  ;
  Trade.exactOut =
  /*#__PURE__*/
  function () {
    var _exactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(route, amountOut) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function exactOut(_x3, _x4) {
      return _exactOut.apply(this, arguments);
    }
    return exactOut;
  }()
  /**
   * Constructs a trade by simulating swaps through the given route
   * @template TInput The input token, either Ether or an ERC-20.
   * @template TOutput The output token, either Ether or an ERC-20.
   * @template TTradeType The type of the trade, either exact in or exact out.
   * @param route route to swap through
   * @param amount the amount specified, either input or output, depending on tradeType
   * @param tradeType whether the trade is an exact input or exact output swap
   * @returns The route
   */
  ;
  Trade.fromRoute =
  /*#__PURE__*/
  function () {
    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
      var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            amounts = new Array(route.tokenPath.length);
            if (!(tradeType === TradeType.EXACT_INPUT)) {
              _context3.next = 19;
              break;
            }
            !amount.jetton.equals(route.input) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
            amounts[0] = amount.wrapped;
            i = 0;
          case 5:
            if (!(i < route.tokenPath.length - 1)) {
              _context3.next = 15;
              break;
            }
            pool = route.pools[i];
            _context3.next = 9;
            return pool.getOutputAmount(amounts[i]);
          case 9:
            _yield$pool$getOutput = _context3.sent;
            _outputAmount = _yield$pool$getOutput[0];
            amounts[i + 1] = _outputAmount;
          case 12:
            i++;
            _context3.next = 5;
            break;
          case 15:
            inputAmount = JettonAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
            outputAmount = JettonAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
            _context3.next = 34;
            break;
          case 19:
            !amount.jetton.equals(route.output) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
            amounts[amounts.length - 1] = amount.wrapped;
            _i = route.tokenPath.length - 1;
          case 22:
            if (!(_i > 0)) {
              _context3.next = 32;
              break;
            }
            _pool = route.pools[_i - 1];
            _context3.next = 26;
            return _pool.getInputAmount(amounts[_i]);
          case 26:
            _yield$_pool$getInput = _context3.sent;
            _inputAmount = _yield$_pool$getInput[0];
            amounts[_i - 1] = _inputAmount;
          case 29:
            _i--;
            _context3.next = 22;
            break;
          case 32:
            inputAmount = JettonAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
            outputAmount = JettonAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
          case 34:
            return _context3.abrupt("return", new Trade({
              routes: [{
                inputAmount: inputAmount,
                outputAmount: outputAmount,
                route: route
              }],
              tradeType: tradeType
            }));
          case 35:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function fromRoute(_x5, _x6, _x7) {
      return _fromRoute.apply(this, arguments);
    }
    return fromRoute;
  }()
  /**
   * Constructs a trade from routes by simulating swaps
   *
   * @template TInput The input token, either Ether or an ERC-20.
   * @template TOutput The output token, either Ether or an ERC-20.
   * @template TTradeType The type of the trade, either exact in or exact out.
   * @param routes the routes to swap through and how much of the amount should be routed through each
   * @param tradeType whether the trade is an exact input or exact output swap
   * @returns The trade
   */
  ;
  Trade.fromRoutes =
  /*#__PURE__*/
  function () {
    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(routes, tradeType) {
      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            populatedRoutes = [];
            _iterator3 = _createForOfIteratorHelperLoose(routes);
          case 2:
            if ((_step3 = _iterator3()).done) {
              _context4.next = 43;
              break;
            }
            _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;
            amounts = new Array(route.tokenPath.length);
            inputAmount = void 0;
            outputAmount = void 0;
            if (!(tradeType === TradeType.EXACT_INPUT)) {
              _context4.next = 25;
              break;
            }
            !amount.jetton.equals(route.input) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INPUT') : invariant(false) : void 0;
            inputAmount = JettonAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
            amounts[0] = JettonAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
            i = 0;
          case 12:
            if (!(i < route.tokenPath.length - 1)) {
              _context4.next = 22;
              break;
            }
            pool = route.pools[i];
            _context4.next = 16;
            return pool.getOutputAmount(amounts[i]);
          case 16:
            _yield$pool$getOutput2 = _context4.sent;
            _outputAmount2 = _yield$pool$getOutput2[0];
            amounts[i + 1] = _outputAmount2;
          case 19:
            i++;
            _context4.next = 12;
            break;
          case 22:
            outputAmount = JettonAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
            _context4.next = 40;
            break;
          case 25:
            !amount.jetton.equals(route.output) ? process.env.NODE_ENV !== "production" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;
            outputAmount = JettonAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
            amounts[amounts.length - 1] = JettonAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
            _i2 = route.tokenPath.length - 1;
          case 29:
            if (!(_i2 > 0)) {
              _context4.next = 39;
              break;
            }
            _pool2 = route.pools[_i2 - 1];
            _context4.next = 33;
            return _pool2.getInputAmount(amounts[_i2]);
          case 33:
            _yield$_pool2$getInpu = _context4.sent;
            _inputAmount2 = _yield$_pool2$getInpu[0];
            amounts[_i2 - 1] = _inputAmount2;
          case 36:
            _i2--;
            _context4.next = 29;
            break;
          case 39:
            inputAmount = JettonAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
          case 40:
            populatedRoutes.push({
              route: route,
              inputAmount: inputAmount,
              outputAmount: outputAmount
            });
          case 41:
            _context4.next = 2;
            break;
          case 43:
            return _context4.abrupt("return", new Trade({
              routes: populatedRoutes,
              tradeType: tradeType
            }));
          case 44:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function fromRoutes(_x8, _x9) {
      return _fromRoutes.apply(this, arguments);
    }
    return fromRoutes;
  }()
  /**
   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
   * elsewhere and do not have any tick data
   * @template TInput The input token, either Ether or an ERC-20
   * @template TOutput The output token, either Ether or an ERC-20
   * @template TTradeType The type of the trade, either exact in or exact out
   * @param constructorArguments The arguments passed to the trade constructor
   * @returns The unchecked trade
   */
  ;
  Trade.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {
    return new Trade(_extends({}, constructorArguments, {
      routes: [{
        inputAmount: constructorArguments.inputAmount,
        outputAmount: constructorArguments.outputAmount,
        route: constructorArguments.route
      }]
    }));
  }
  /**
   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade
   * elsewhere and do not have any tick data
   * @template TInput The input token, either Ether or an ERC-20
   * @template TOutput The output token, either Ether or an ERC-20
   * @template TTradeType The type of the trade, either exact in or exact out
   * @param constructorArguments The arguments passed to the trade constructor
   * @returns The unchecked trade
   */;
  Trade.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {
    return new Trade(constructorArguments);
  }
  /**
   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
   * amount to an output token, making at most `maxHops` hops.
   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
   * the amount in among multiple routes.
   * @param pools the pools to consider in finding the best trade
   * @param nextAmountIn exact amount of input currency to spend
   * @param currencyOut the desired currency out
   * @param maxNumResults maximum number of results to return
   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool
   * @param currentPools used in recursion; the current list of pools
   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter
   * @param bestTrades used in recursion; the current list of best trades
   * @returns The exact in trade
   */;
  Trade.bestTradeExactIn =
  /*#__PURE__*/
  function () {
    var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp,
    // used in recursion.
    currentPools, nextAmountIn, bestTrades) {
      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, error, poolsExcludingThisPool;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;
            if (currentPools === void 0) {
              currentPools = [];
            }
            if (nextAmountIn === void 0) {
              nextAmountIn = currencyAmountIn;
            }
            if (bestTrades === void 0) {
              bestTrades = [];
            }
            !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
            !(maxHops > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;
            !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;
            amountIn = nextAmountIn;
            tokenOut = currencyOut;
            i = 0;
          case 10:
            if (!(i < pools.length)) {
              _context5.next = 46;
              break;
            }
            pool = pools[i]; // pool irrelevant
            if (!(!pool.jetton0.equals(amountIn.jetton) && !pool.jetton1.equals(amountIn.jetton))) {
              _context5.next = 14;
              break;
            }
            return _context5.abrupt("continue", 43);
          case 14:
            amountOut = void 0;
            _context5.prev = 15;
            _context5.next = 18;
            return pool.getOutputAmount(amountIn);
          case 18:
            _yield$pool$getOutput3 = _context5.sent;
            amountOut = _yield$pool$getOutput3[0];
            _context5.next = 28;
            break;
          case 22:
            _context5.prev = 22;
            _context5.t0 = _context5["catch"](15);
            error = _context5.t0; // input too low
            if (!error.isInsufficientInputAmountError) {
              _context5.next = 27;
              break;
            }
            return _context5.abrupt("continue", 43);
          case 27:
            throw error;
          case 28:
            if (!(amountOut.jetton.isToken && amountOut.jetton.equals(tokenOut))) {
              _context5.next = 39;
              break;
            }
            _context5.t1 = sortedInsert;
            _context5.t2 = bestTrades;
            _context5.next = 33;
            return Trade.fromRoute(new Route([].concat(currentPools, [pool]), currencyAmountIn.jetton, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT);
          case 33:
            _context5.t3 = _context5.sent;
            _context5.t4 = maxNumResults;
            _context5.t5 = tradeComparator;
            (0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5);
            _context5.next = 43;
            break;
          case 39:
            if (!(maxHops > 1 && pools.length > 1)) {
              _context5.next = 43;
              break;
            }
            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
            _context5.next = 43;
            return Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {
              maxNumResults: maxNumResults,
              maxHops: maxHops - 1
            }, [].concat(currentPools, [pool]), amountOut, bestTrades);
          case 43:
            i++;
            _context5.next = 10;
            break;
          case 46:
            return _context5.abrupt("return", bestTrades);
          case 47:
          case "end":
            return _context5.stop();
        }
      }, _callee5, null, [[15, 22]]);
    }));
    function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
      return _bestTradeExactIn.apply(this, arguments);
    }
    return bestTradeExactIn;
  }()
  /**
   * similar to the above method but instead targets a fixed output amount
   * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
   * to an output token amount, making at most `maxHops` hops
   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
   * the amount in among multiple routes.
   * @param pools the pools to consider in finding the best trade
   * @param currencyIn the currency to spend
   * @param currencyAmountOut the desired currency amount out
   * @param nextAmountOut the exact amount of currency out
   * @param maxNumResults maximum number of results to return
   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool
   * @param currentPools used in recursion; the current list of pools
   * @param bestTrades used in recursion; the current list of best trades
   * @returns The exact out trade
   */
  ;
  Trade.bestTradeExactOut =
  /*#__PURE__*/
  function () {
    var _bestTradeExactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2,
    // used in recursion.
    currentPools, nextAmountOut, bestTrades) {
      var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i, pool, amountIn, _yield$pool$getInputA, error, poolsExcludingThisPool;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$maxNumResults = _ref6.maxNumResults, maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults, _ref6$maxHops = _ref6.maxHops, maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops;
            if (currentPools === void 0) {
              currentPools = [];
            }
            if (nextAmountOut === void 0) {
              nextAmountOut = currencyAmountOut;
            }
            if (bestTrades === void 0) {
              bestTrades = [];
            }
            !(pools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'POOLS') : invariant(false) : void 0;
            !(maxHops > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;
            !(currencyAmountOut === nextAmountOut || currentPools.length > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;
            amountOut = nextAmountOut;
            tokenIn = currencyIn;
            i = 0;
          case 10:
            if (!(i < pools.length)) {
              _context6.next = 46;
              break;
            }
            pool = pools[i]; // pool irrelevant
            if (!(!pool.jetton0.equals(amountOut.jetton) && !pool.jetton1.equals(amountOut.jetton))) {
              _context6.next = 14;
              break;
            }
            return _context6.abrupt("continue", 43);
          case 14:
            amountIn = void 0;
            _context6.prev = 15;
            _context6.next = 18;
            return pool.getInputAmount(amountOut);
          case 18:
            _yield$pool$getInputA = _context6.sent;
            amountIn = _yield$pool$getInputA[0];
            _context6.next = 28;
            break;
          case 22:
            _context6.prev = 22;
            _context6.t0 = _context6["catch"](15);
            // not enough liquidity in this pool
            error = _context6.t0;
            if (!error.isInsufficientReservesError) {
              _context6.next = 27;
              break;
            }
            return _context6.abrupt("continue", 43);
          case 27:
            throw error;
          case 28:
            if (!amountIn.jetton.equals(tokenIn)) {
              _context6.next = 39;
              break;
            }
            _context6.t1 = sortedInsert;
            _context6.t2 = bestTrades;
            _context6.next = 33;
            return Trade.fromRoute(new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.jetton), currencyAmountOut, TradeType.EXACT_OUTPUT);
          case 33:
            _context6.t3 = _context6.sent;
            _context6.t4 = maxNumResults;
            _context6.t5 = tradeComparator;
            (0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5);
            _context6.next = 43;
            break;
          case 39:
            if (!(maxHops > 1 && pools.length > 1)) {
              _context6.next = 43;
              break;
            }
            poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
            _context6.next = 43;
            return Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {
              maxNumResults: maxNumResults,
              maxHops: maxHops - 1
            }, [pool].concat(currentPools), amountIn, bestTrades);
          case 43:
            i++;
            _context6.next = 10;
            break;
          case 46:
            return _context6.abrupt("return", bestTrades);
          case 47:
          case "end":
            return _context6.stop();
        }
      }, _callee6, null, [[15, 22]]);
    }));
    function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
      return _bestTradeExactOut.apply(this, arguments);
    }
    return bestTradeExactOut;
  }()
  /**
   * Get the minimum amount that must be received from this trade for the given slippage tolerance
   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
   * @returns The amount out
   */
  ;
  var _proto = Trade.prototype;
  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {
    if (amountOut === void 0) {
      amountOut = this.outputAmount;
    }
    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;
    if (this.tradeType === TradeType.EXACT_OUTPUT) {
      return amountOut;
    }
    var slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;
    return JettonAmount.fromRawAmount(amountOut.jetton, slippageAdjustedAmountOut);
  }
  /**
   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
   * @returns The amount in
   */;
  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {
    if (amountIn === void 0) {
      amountIn = this.inputAmount;
    }
    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;
    if (this.tradeType === TradeType.EXACT_INPUT) {
      return amountIn;
    }
    var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;
    return JettonAmount.fromRawAmount(amountIn.jetton, slippageAdjustedAmountIn);
  }
  /**
   * Return the execution price after accounting for slippage tolerance
   * @param slippageTolerance the allowed tolerated slippage
   * @returns The execution price
   */;
  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
    return new Price(this.inputAmount.jetton, this.outputAmount.jetton, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
  };
  _createClass(Trade, [{
    key: "route",
    get: function get() {
      !(this.swaps.length == 1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'MULTIPLE_ROUTES') : invariant(false) : void 0;
      return this.swaps[0].route;
    }
    /**
     * The input amount for the trade assuming no slippage.
     */
  }, {
    key: "inputAmount",
    get: function get() {
      if (this._inputAmount) {
        return this._inputAmount;
      }
      var inputCurrency = this.swaps[0].inputAmount.jetton;
      var totalInputFromRoutes = this.swaps.map(function (_ref7) {
        var inputAmount = _ref7.inputAmount;
        return inputAmount;
      }).reduce(function (total, cur) {
        return total.add(cur);
      }, JettonAmount.fromRawAmount(inputCurrency, 0));
      this._inputAmount = totalInputFromRoutes;
      return this._inputAmount;
    }
    /**
     * The output amount for the trade assuming no slippage.
     */
  }, {
    key: "outputAmount",
    get: function get() {
      if (this._outputAmount) {
        return this._outputAmount;
      }
      var outputCurrency = this.swaps[0].outputAmount.jetton;
      var totalOutputFromRoutes = this.swaps.map(function (_ref8) {
        var outputAmount = _ref8.outputAmount;
        return outputAmount;
      }).reduce(function (total, cur) {
        return total.add(cur);
      }, JettonAmount.fromRawAmount(outputCurrency, 0));
      this._outputAmount = totalOutputFromRoutes;
      return this._outputAmount;
    }
    /**
     * The price expressed in terms of output amount/input amount.
     */
  }, {
    key: "executionPrice",
    get: function get() {
      var _this$_executionPrice;
      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new Price(this.inputAmount.jetton, this.outputAmount.jetton, this.inputAmount.quotient, this.outputAmount.quotient);
    }
    /**
     * Returns the percent difference between the route's mid price and the price impact
     */
  }, {
    key: "priceImpact",
    get: function get() {
      if (this._priceImpact) {
        return this._priceImpact;
      }
      var spotOutputAmount = JettonAmount.fromRawAmount(this.outputAmount.jetton, 0);
      for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
          route = _step4$value.route,
          inputAmount = _step4$value.inputAmount;
        var midPrice = route.midPrice;
        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));
      }
      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);
      this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator);
      return this._priceImpact;
    }
  }]);
  return Trade;
}();

/**
 * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies
 */
var AbstractJetton =
/**
 * Constructs an instance of the base class `BaseCurrency`.
 * @param chainId the chain ID on which this currency resides
 * @param decimals decimals of the currency
 * @param symbol symbol of the currency
 * @param name of the currency
 */
function AbstractJetton(decimals, symbol, name, image) {
  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
  this.decimals = decimals;
  this.symbol = symbol;
  this.name = name;
  this.image = image;
};

function validateAndParseAddress(address) {
  try {
    return Address$1.parse(address).toString();
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}

/**
 * Represents an ERC20 token with a unique address and some metadata.
 */
var Jetton = /*#__PURE__*/function (_AbstractJetton) {
  _inheritsLoose(Jetton, _AbstractJetton);
  function Jetton(address, decimals, symbol, name, image) {
    var _this;
    _this = _AbstractJetton.call(this, decimals, symbol, name, image) || this;
    _this.isToken = true;
    _this.address = validateAndParseAddress(address);
    return _this;
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
   * @param other other token to compare
   */
  var _proto = Jetton.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && Address.parse(this.address).equals(Address.parse(other.address));
  };
  return Jetton;
}(AbstractJetton);
//   /**
//    * Returns true if the address of this token sorts before the address of the other token
//    * @param other other token to compare
//    * @throws if the tokens have the same address
//    * @throws if the tokens are on different chains
//    */
//   public sortsBefore(other: Jetton): boolean {
//     invariant(this.address !== other.address, 'ADDRESSES');
//     return this.address.toLowerCase() < other.address.toLowerCase();
//   }
// }
//   /**
//    * Return this token, which does not need to be wrapped
//    */
//   public get wrapped(): Token {
//     return this;
//   }
// }
/**
 * Compares two currencies for equality
 */
function currencyEquals(jettonA, jettonB) {
  if (jettonA instanceof Jetton && jettonB instanceof Jetton) {
    return jettonA.equals(jettonB);
  }
  if (jettonA instanceof Jetton) {
    return false;
  }
  if (jettonB instanceof Jetton) {
    return false;
  }
  return jettonA === jettonB;
}

/**
 * Returns the closest tick that is nearest a given tick and usable for the given tick spacing
 * @param tick the target tick
 * @param tickSpacing the spacing of the pool
 */
function nearestUsableTick(tick, tickSpacing) {
  !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'INTEGERS') : invariant(false) : void 0;
  !(tickSpacing > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_SPACING') : invariant(false) : void 0;
  !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TICK_BOUND') : invariant(false) : void 0;
  var rounded = Math.round(tick / tickSpacing) * tickSpacing;
  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;
  if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;
  return rounded;
}

function getTickToPrice(baseToken, quoteToken, tick, isSorted) {
  if (isSorted === void 0) {
    isSorted = true;
  }
  if (!baseToken || !quoteToken || typeof tick !== 'number') {
    return undefined;
  }
  return tickToPrice(baseToken, quoteToken, tick, isSorted);
}

var Q256 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(256));
function subIn256(x, y) {
  var difference = JSBI.subtract(x, y);
  if (JSBI.lessThan(difference, ZERO)) {
    return JSBI.add(Q256, difference);
  }
  return difference;
}
var TickLibrary = /*#__PURE__*/function () {
  /**
   * Cannot be constructed.
   */
  function TickLibrary() {}
  TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
    var feeGrowthBelow0X128;
    var feeGrowthBelow1X128;
    if (tickCurrent >= tickLower) {
      feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128;
      feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128;
    } else {
      feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128);
      feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128);
    }
    var feeGrowthAbove0X128;
    var feeGrowthAbove1X128;
    if (tickCurrent < tickUpper) {
      feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128;
      feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128;
    } else {
      feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128);
      feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128);
    }
    return [subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128), subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)];
  };
  return TickLibrary;
}();

var Q128 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128));
var PositionLibrary = /*#__PURE__*/function () {
  /**
   * Cannot be constructed.
   */
  function PositionLibrary() {}
  // replicates the portions of Position#update required to compute unaccounted fees
  PositionLibrary.getTokensOwed = function getTokensOwed(feeGrowthInside0LastX128, feeGrowthInside1LastX128, liquidity, feeGrowthInside0X128, feeGrowthInside1X128) {
    var tokensOwed0 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity), Q128);
    var tokensOwed1 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity), Q128);
    return [tokensOwed0, tokensOwed1];
  };
  return PositionLibrary;
}();

var MIN_NATIVE_CURRENCY_FOR_GAS = /*#__PURE__*/JSBI.multiply( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(10), /*#__PURE__*/JSBI.BigInt(7)), /*#__PURE__*/JSBI.BigInt(61)); // 0.61 TON
/**
 * Given some token amount, return the max that can be spent of it
 * @param currencyAmount to return max of
 */
function maxAmountSpend(currencyAmount) {
  if (!currencyAmount) return undefined;
  var isNative = Address.parse(currencyAmount.jetton.address).equals(Address.parse(pTON_MINTER));
  if (isNative) {
    if (JSBI.greaterThan(currencyAmount.quotient, MIN_NATIVE_CURRENCY_FOR_GAS)) {
      return JettonAmount.fromRawAmount(currencyAmount.jetton, JSBI.subtract(currencyAmount.quotient, MIN_NATIVE_CURRENCY_FOR_GAS));
    }
    return JettonAmount.fromRawAmount(currencyAmount.jetton, JSBI.BigInt(0));
  }
  return currencyAmount;
}

function parseUnits(amount, decimals) {
  var amountNum = Number(amount);
  if (isNaN(amountNum)) return BigInt(0);
  return BigInt(Math.round(amountNum * Math.pow(10, decimals)));
}

var parseBalance = function parseBalance(value, decimals) {
  if (decimals === void 0) {
    decimals = 18;
  }
  return parseUnits(value || '0', decimals);
};
// try to parse a user entered amount for a given token
function tryParseAmount(value, currency) {
  if (!value || !currency) {
    return undefined;
  }
  try {
    var typedValueParsed = parseUnits(value, currency.decimals).toString();
    if (typedValueParsed !== '0') {
      return JettonAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed));
    }
  } catch (error) {
    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)
    console.debug("Failed to parse input amount: \"" + value + "\"", error);
  }
  // necessary for all paths to return a value
  return undefined;
}

function tryParsePrice(baseToken, quoteToken, value) {
  var _fraction$length;
  if (!baseToken || !quoteToken || !value) {
    return undefined;
  }
  if (!value.match(/^\d*\.?\d+$/)) {
    return undefined;
  }
  var _value$split = value.split('.'),
    whole = _value$split[0],
    fraction = _value$split[1];
  var decimals = (_fraction$length = fraction == null ? void 0 : fraction.length) != null ? _fraction$length : 0;
  var withoutDecimals = JSBI.BigInt((whole != null ? whole : '') + (fraction != null ? fraction : ''));
  return new Price(baseToken, quoteToken, JSBI.multiply(JSBI.BigInt(Math.pow(10, decimals)), JSBI.BigInt(Math.pow(10, baseToken.decimals))), JSBI.multiply(withoutDecimals, JSBI.BigInt(Math.pow(10, quoteToken.decimals))));
}
function tryParseTick(baseToken, quoteToken, value, tickSpacing) {
  if (!baseToken || !quoteToken || !value || !tickSpacing) {
    return undefined;
  }
  var price = tryParsePrice(baseToken, quoteToken, value);
  if (!price) {
    return undefined;
  }
  var tick;
  // check price is within min/max bounds, if outside return min/max
  var sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);
  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {
    tick = TickMath.MAX_TICK;
  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {
    tick = TickMath.MIN_TICK;
  } else {
    // this function is agnostic to the base, will always return the correct tick
    tick = priceToClosestTick(price);
  }
  return nearestUsableTick(tick, tickSpacing);
}

var WalletVersion;
(function (WalletVersion) {
  WalletVersion[WalletVersion["V3R1"] = 0] = "V3R1";
  WalletVersion[WalletVersion["V3R2"] = 1] = "V3R2";
  WalletVersion[WalletVersion["V4R1"] = 2] = "V4R1";
  WalletVersion[WalletVersion["V4R2"] = 3] = "V4R2";
  WalletVersion[WalletVersion["V5_BETA"] = 4] = "V5_BETA";
  WalletVersion[WalletVersion["V5R1"] = 5] = "V5R1";
})(WalletVersion || (WalletVersion = {}));

function parseWalletVersion(walletVersion) {
  switch (walletVersion) {
    case 'wallet_v5r1':
      return WalletVersion.V5R1;
    case 'wallet_v5':
      return WalletVersion.V5_BETA;
    case 'wallet_v4r2':
      return WalletVersion.V4R2;
    case 'wallet_v4r1':
      return WalletVersion.V4R1;
    case 'wallet_v3r2':
      return WalletVersion.V3R2;
    case 'wallet_v3r1':
      return WalletVersion.V3R1;
    default:
      console.error("Unsupported wallet version: " + walletVersion);
      return;
  }
}

var emojiBigArray = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
function xorBuffers(buffers) {
  var length = buffers[0].length;
  var result = Buffer.alloc(length);
  for (var i = 0; i < length; i++) {
    // Perform XOR for each corresponding byte from the buffers
    for (var j = 0; j < buffers.length; j++) result[i] = result[i] ^ buffers[j][i];
  }
  return result;
}
function bigIntPow(base, exponent) {
  var result = BigInt(1);
  for (var i = BigInt(0); i < exponent; i++) {
    result *= base;
  }
  return result;
}
var toncoCells = [ROUTERV3_CODE, POOLV3_CODE, ACCOUNTV3_CODE, POSITIONV3_CODE];
function getEmojiHash() {
  var toncoHashes = [];
  for (var _iterator = _createForOfIteratorHelperLoose(toncoCells), _step; !(_step = _iterator()).done;) {
    var contractCell = _step.value;
    toncoHashes.push(contractCell.hash(0));
  }
  var mainHash = xorBuffers(Object.values(toncoHashes));
  var shortHash = BigInt("0x" + mainHash.toString('hex')) % bigIntPow(BigInt(2), BigInt(42));
  var base = BigInt(emojiBigArray.length);
  var result = '';
  for (var i = 0; i < 4; i++) {
    result += emojiBigArray[Number(shortHash % base)];
    shortHash /= base;
  }
  return result;
}

var WalletContract = function WalletContract() {};
WalletContract.create = function (workchain, publicKey, version) {
  switch (version) {
    case WalletVersion.V3R1:
      return WalletContractV3R1.create({
        workchain: workchain,
        publicKey: publicKey
      });
    case WalletVersion.V3R2:
      return WalletContractV3R2.create({
        workchain: workchain,
        publicKey: publicKey
      });
    case WalletVersion.V4R1:
      throw new Error('Unsupported wallet contract version - v4R1');
    case WalletVersion.V4R2:
      return WalletContractV4.create({
        workchain: workchain,
        publicKey: publicKey
      });
    case WalletVersion.V5R1:
      return WalletContractV5R1.create({
        workchain: workchain,
        publicKey: publicKey
      });
    default:
      throw new Error("Unsupported wallet contract version - " + version);
  }
};

var signer = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", sign(message.hash(), Buffer.alloc(64)));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function signer(_x) {
    return _ref.apply(this, arguments);
  };
}();
var externalMessage = function externalMessage(contract, seqno, body) {
  return beginCell$1().storeWritable(storeMessage(external({
    to: contract.address,
    init: seqno === 0 ? contract.init : undefined,
    body: body
  }))).endCell();
};
function emulateMessage(_x2, _x3, _x4, _x5, _x6) {
  return _emulateMessage.apply(this, arguments);
}
function _emulateMessage() {
  _emulateMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(client, messages, wallet, walletPubKey, walletVersion) {
    var walletContract, seqno, secretKey, transfer, msgCell, emulation;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(!wallet || !messages || !messages[0].body || !walletVersion || !walletPubKey)) {
            _context2.next = 2;
            break;
          }
          return _context2.abrupt("return");
        case 2:
          walletContract = WalletContract.create(Address$1.parse(wallet).workChain, Buffer.from(walletPubKey, 'hex'), walletVersion);
          _context2.next = 5;
          return client.wallet.getAccountSeqno(wallet);
        case 5:
          seqno = _context2.sent.seqno;
          _context2.next = 8;
          return signer(messages[0].body);
        case 8:
          secretKey = _context2.sent;
          _context2.next = 11;
          return walletContract.createTransfer({
            seqno: seqno,
            signer: signer,
            secretKey: secretKey,
            timeout: 0,
            sendMode: SendMode$1.PAY_GAS_SEPARATELY + SendMode$1.IGNORE_ERRORS,
            messages: messages.map(function (message) {
              var _message$init$code, _message$init, _message$init$data, _message$init2;
              return internal({
                to: message.to,
                bounce: true,
                value: message.value,
                init: {
                  code: (_message$init$code = (_message$init = message.init) == null ? void 0 : _message$init.code) != null ? _message$init$code : null,
                  data: (_message$init$data = (_message$init2 = message.init) == null ? void 0 : _message$init2.data) != null ? _message$init$data : null
                },
                body: message.body
              });
            })
          });
        case 11:
          transfer = _context2.sent;
          msgCell = externalMessage(walletContract, seqno, transfer).toBoc({
            idx: false
          });
          _context2.next = 15;
          return client.wallet.emulateMessageToWallet({
            boc: msgCell.toString('base64')
          });
        case 15:
          emulation = _context2.sent;
          return _context2.abrupt("return", emulation);
        case 17:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _emulateMessage.apply(this, arguments);
}

var Op = function Op() {};
Op.transfer = 0xf8a7ea5;
Op.transfer_notification = 0x7362d09c;
Op.internal_transfer = 0x178d4519;
Op.excesses = 0xd53276db;
Op.burn = 0x595f07bc;
Op.burn_notification = 0x7bdd97de;
Op.provide_wallet_address = 0x2c76b973;
Op.take_wallet_address = 0xd1735400;
Op.mint = 21;
Op.change_admin = 3;
Op.change_content = 4;
var Errors = function Errors() {};
Errors.invalid_op = 709;
Errors.not_admin = 73;
Errors.unouthorized_burn = 74;
Errors.discovery_fee_not_matched = 75;
Errors.wrong_op = 0xffff;
Errors.not_owner = 705;
Errors.not_enough_ton = 709;
Errors.not_enough_gas = 707;
Errors.not_valid_wallet = 707;
Errors.wrong_workchain = 333;
Errors.balance_error = 706;

function jettonMinterConfigToCell(config) {
  return beginCell().storeCoins(0).storeAddress(config.admin).storeRef(config.content).storeRef(config.wallet_code).endCell();
}
function jettonContentToCell(content) {
  return beginCell().storeUint(content.type, 8).storeStringTail(content.uri) //Snake logic under the hood
  .endCell();
}
var JettonMinter = /*#__PURE__*/function () {
  function JettonMinter(address, init) {
    this.address = address;
    this.init = init;
  }
  JettonMinter.createFromAddress = function createFromAddress(address) {
    return new JettonMinter(address);
  };
  JettonMinter.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = jettonMinterConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new JettonMinter(address, init);
  };
  var _proto = JettonMinter.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  JettonMinter.jettonInternalTransfer = function jettonInternalTransfer(jetton_amount, forward_ton_amount, response_addr, query_id) {
    if (query_id === void 0) {
      query_id = 0;
    }
    return beginCell().storeUint(Op.internal_transfer, 32).storeUint(query_id, 64).storeCoins(jetton_amount).storeAddress(null).storeAddress(response_addr).storeCoins(forward_ton_amount).storeBit(false).endCell();
  };
  JettonMinter.mintMessage = function mintMessage(from, to, jetton_amount, forward_ton_amount, total_ton_amount, query_id) {
    if (query_id === void 0) {
      query_id = 0;
    }
    var mintMsg = beginCell().storeUint(Op.internal_transfer, 32).storeUint(0, 64).storeCoins(jetton_amount).storeAddress(null).storeAddress(from) // Response addr
    .storeCoins(forward_ton_amount).storeMaybeRef(null).endCell();
    return beginCell().storeUint(Op.mint, 32).storeUint(query_id, 64) // op, queryId
    .storeAddress(to).storeCoins(total_ton_amount).storeCoins(jetton_amount).storeRef(mintMsg).endCell();
  };
  _proto.sendMint = /*#__PURE__*/function () {
    var _sendMint = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, via, to, jetton_amount, forward_ton_amount, total_ton_amount) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (!(total_ton_amount <= forward_ton_amount)) {
              _context2.next = 2;
              break;
            }
            throw new Error('Total ton amount should be > forward amount');
          case 2:
            _context2.next = 4;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonMinter.mintMessage(this.address, to, jetton_amount, forward_ton_amount, total_ton_amount),
              value: total_ton_amount
            });
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function sendMint(_x4, _x5, _x6, _x7, _x8, _x9) {
      return _sendMint.apply(this, arguments);
    }
    return sendMint;
  }()
  /* provide_wallet_address#2c76b973 query_id:uint64 owner_address:MsgAddress include_address:Bool = InternalMsgBody;
   */
  ;
  JettonMinter.discoveryMessage = function discoveryMessage(owner, include_address) {
    return beginCell().storeUint(0x2c76b973, 32).storeUint(0, 64) // op, queryId
    .storeAddress(owner).storeBit(include_address).endCell();
  };
  _proto.sendDiscovery = /*#__PURE__*/function () {
    var _sendDiscovery = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, via, owner, include_address, value) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (value === void 0) {
              value = /*#__PURE__*/toNano('0.1');
            }
            _context3.next = 3;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonMinter.discoveryMessage(owner, include_address),
              value: value
            });
          case 3:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function sendDiscovery(_x10, _x11, _x12, _x13, _x14) {
      return _sendDiscovery.apply(this, arguments);
    }
    return sendDiscovery;
  }();
  JettonMinter.changeAdminMessage = function changeAdminMessage(newOwner) {
    return beginCell().storeUint(Op.change_admin, 32).storeUint(0, 64) // op, queryId
    .storeAddress(newOwner).endCell();
  };
  _proto.sendChangeAdmin = /*#__PURE__*/function () {
    var _sendChangeAdmin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, via, newOwner) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonMinter.changeAdminMessage(newOwner),
              value: toNano('0.05')
            });
          case 2:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendChangeAdmin(_x15, _x16, _x17) {
      return _sendChangeAdmin.apply(this, arguments);
    }
    return sendChangeAdmin;
  }();
  JettonMinter.changeContentMessage = function changeContentMessage(content) {
    return beginCell().storeUint(Op.change_content, 32).storeUint(0, 64) // op, queryId
    .storeRef(content).endCell();
  };
  _proto.sendChangeContent = /*#__PURE__*/function () {
    var _sendChangeContent = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, via, content) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonMinter.changeContentMessage(content),
              value: toNano('0.05')
            });
          case 2:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendChangeContent(_x18, _x19, _x20) {
      return _sendChangeContent.apply(this, arguments);
    }
    return sendChangeContent;
  }();
  _proto.getWalletAddress = /*#__PURE__*/function () {
    var _getWalletAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider, owner) {
      var res;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return provider.get('get_wallet_address', [{
              type: 'slice',
              cell: beginCell().storeAddress(owner).endCell()
            }]);
          case 2:
            res = _context6.sent;
            return _context6.abrupt("return", res.stack.readAddress());
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function getWalletAddress(_x21, _x22) {
      return _getWalletAddress.apply(this, arguments);
    }
    return getWalletAddress;
  }();
  _proto.getJettonData = /*#__PURE__*/function () {
    var _getJettonData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider) {
      var res, totalSupply, mintable, adminAddress, content, walletCode;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return provider.get('get_jetton_data', []);
          case 2:
            res = _context7.sent;
            totalSupply = res.stack.readBigNumber();
            mintable = res.stack.readBoolean(); // let adminAddress = res.stack.readAddress(); Well.....
            adminAddress = res.stack.readAddressOpt();
            content = res.stack.readCell();
            walletCode = res.stack.readCell();
            return _context7.abrupt("return", {
              totalSupply: totalSupply,
              mintable: mintable,
              adminAddress: adminAddress,
              content: content,
              walletCode: walletCode
            });
          case 9:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function getJettonData(_x23) {
      return _getJettonData.apply(this, arguments);
    }
    return getJettonData;
  }();
  _proto.getTotalSupply = /*#__PURE__*/function () {
    var _getTotalSupply = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(provider) {
      var res;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.getJettonData(provider);
          case 2:
            res = _context8.sent;
            return _context8.abrupt("return", res.totalSupply);
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function getTotalSupply(_x24) {
      return _getTotalSupply.apply(this, arguments);
    }
    return getTotalSupply;
  }();
  _proto.getAdminAddress = /*#__PURE__*/function () {
    var _getAdminAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(provider) {
      var res;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.getJettonData(provider);
          case 2:
            res = _context9.sent;
            return _context9.abrupt("return", res.adminAddress);
          case 4:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getAdminAddress(_x25) {
      return _getAdminAddress.apply(this, arguments);
    }
    return getAdminAddress;
  }();
  _proto.getContent = /*#__PURE__*/function () {
    var _getContent = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {
      var res;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return this.getJettonData(provider);
          case 2:
            res = _context10.sent;
            return _context10.abrupt("return", res.content);
          case 4:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function getContent(_x26) {
      return _getContent.apply(this, arguments);
    }
    return getContent;
  }();
  return JettonMinter;
}();

function jettonWalletConfigToCell(config) {
  console.log(config);
  return beginCell().endCell();
}
var JettonWallet = /*#__PURE__*/function () {
  function JettonWallet(address, init) {
    this.address = address;
    this.init = init;
  }
  JettonWallet.createFromAddress = function createFromAddress(address) {
    return new JettonWallet(address);
  };
  JettonWallet.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = jettonWalletConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    return new JettonWallet(contractAddress(workchain, init), init);
  };
  var _proto = JettonWallet.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  _proto.getJettonBalance = /*#__PURE__*/function () {
    var _getJettonBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider) {
      var state, res;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return provider.getState();
          case 2:
            state = _context2.sent;
            if (!(state.state.type !== 'active')) {
              _context2.next = 5;
              break;
            }
            return _context2.abrupt("return", 0n);
          case 5:
            _context2.next = 7;
            return provider.get('get_wallet_data', []);
          case 7:
            res = _context2.sent;
            return _context2.abrupt("return", res.stack.readBigNumber());
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function getJettonBalance(_x4) {
      return _getJettonBalance.apply(this, arguments);
    }
    return getJettonBalance;
  }();
  _proto.getJettonMinterAddress = /*#__PURE__*/function () {
    var _getJettonMinterAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider) {
      var res, jettonMinterAddress;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return provider.get('get_wallet_data', []);
          case 2:
            res = _context3.sent;
            res.stack.skip(2);
            jettonMinterAddress = res.stack.readAddress();
            return _context3.abrupt("return", jettonMinterAddress);
          case 6:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function getJettonMinterAddress(_x5) {
      return _getJettonMinterAddress.apply(this, arguments);
    }
    return getJettonMinterAddress;
  }();
  JettonWallet.transferMessage = function transferMessage(jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload) {
    return beginCell().storeUint(0xf8a7ea5, 32).storeUint(0, 64) // op, queryId
    .storeCoins(jetton_amount).storeAddress(to).storeAddress(responseAddress).storeMaybeRef(customPayload).storeCoins(forward_ton_amount).storeMaybeRef(forwardPayload).endCell();
  };
  _proto.sendTransfer = /*#__PURE__*/function () {
    var _sendTransfer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, via, value, jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonWallet.transferMessage(jetton_amount, to, responseAddress, customPayload, forward_ton_amount, forwardPayload),
              value: value
            });
          case 2:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendTransfer(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {
      return _sendTransfer.apply(this, arguments);
    }
    return sendTransfer;
  }()
  /*
      burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
                    response_destination:MsgAddress custom_payload:(Maybe ^Cell)
                    = InternalMsgBody;
    */
  ;
  JettonWallet.burnMessage = function burnMessage(jetton_amount, responseAddress, customPayload) {
    return beginCell().storeUint(0x595f07bc, 32).storeUint(0, 64) // op, queryId
    .storeCoins(jetton_amount).storeAddress(responseAddress).storeMaybeRef(customPayload).endCell();
  };
  _proto.sendBurn = /*#__PURE__*/function () {
    var _sendBurn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, via, value, jetton_amount, responseAddress, customPayload) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonWallet.burnMessage(jetton_amount, responseAddress, customPayload),
              value: value
            });
          case 2:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendBurn(_x15, _x16, _x17, _x18, _x19, _x20) {
      return _sendBurn.apply(this, arguments);
    }
    return sendBurn;
  }()
  /*
      withdraw_tons#107c49ef query_id:uint64 = InternalMsgBody;
    */
  ;
  JettonWallet.withdrawTonsMessage = function withdrawTonsMessage() {
    return beginCell().storeUint(0x6d8e5e3c, 32).storeUint(0, 64) // op, queryId
    .endCell();
  };
  _proto.sendWithdrawTons = /*#__PURE__*/function () {
    var _sendWithdrawTons = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider, via) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonWallet.withdrawTonsMessage(),
              value: toNano('0.1')
            });
          case 2:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function sendWithdrawTons(_x21, _x22) {
      return _sendWithdrawTons.apply(this, arguments);
    }
    return sendWithdrawTons;
  }()
  /*
      withdraw_jettons#10 query_id:uint64 wallet:MsgAddressInt amount:Coins = InternalMsgBody;
    */
  ;
  JettonWallet.withdrawJettonsMessage = function withdrawJettonsMessage(from, amount) {
    return beginCell().storeUint(0x768a50b2, 32).storeUint(0, 64) // op, queryId
    .storeAddress(from).storeCoins(amount).storeMaybeRef(null).endCell();
  };
  _proto.sendWithdrawJettons = /*#__PURE__*/function () {
    var _sendWithdrawJettons = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider, via, from, amount) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return provider.internal(via, {
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: JettonWallet.withdrawJettonsMessage(from, amount),
              value: toNano('0.1')
            });
          case 2:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function sendWithdrawJettons(_x23, _x24, _x25, _x26) {
      return _sendWithdrawJettons.apply(this, arguments);
    }
    return sendWithdrawJettons;
  }();
  _proto.getWalletData = /*#__PURE__*/function () {
    var _getWalletData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(provider) {
      var result;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return provider.get('get_wallet_data', []);
          case 2:
            result = _context8.sent;
            return _context8.abrupt("return", {
              balance: result.stack.readBigNumber(),
              ownerAddress: result.stack.readAddress(),
              jettonMasterAddress: result.stack.readAddress(),
              jettonWalletCode: result.stack.readCell()
            });
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    function getWalletData(_x27) {
      return _getWalletData.apply(this, arguments);
    }
    return getWalletData;
  }();
  return JettonWallet;
}();

function walletConfigToCell(config) {
  return beginCell().storeCoins(config.balance).storeAddress(config.ownerAddress).storeAddress(config.minterAddress).endCell();
}
var jWalletOpcodes = {
  transfer: 0xf8a7ea5,
  internalTransfer: 0x178d4519,
  burn: 0x595f07bc
};
var proxyWalletOpcodesV2 = /*#__PURE__*/_extends({}, jWalletOpcodes, {
  resetGas: 0x29d22935,
  tonTransfer: 0x01f3835d
});
// export class PTonWalletV2 extends JettonWalletContractBase<
//   typeof proxyWalletOpcodesV2
// > {
//   constructor(
//     readonly address: Address,
//     readonly init?: { code: Cell; data: Cell }
//   ) {
//     super(proxyWalletOpcodesV2, address, init);
//   }
//   static createFromConfig(config: WalletConfig, code: Cell, workchain = 0) {
//     return this.createFromConfigBase(
//       config,
//       walletConfigToCell,
//       code,
//       workchain
//     );
//   }
//   async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {
//     await provider.internal(via, {
//       value,
//       sendMode: SendMode.PAY_GAS_SEPARATELY,
//       body: beginCell().endCell(),
//     });
//   }
//   static tonTransferMessage(opts: {
//     tonAmount: bigint;
//     refundAddress: Address | ExternalAddress | null;
//     fwdPayload: Cell | Slice;
//     gas: bigint;
//     noPayloadOverride?: boolean; // only used to test refund
//   }) {
//     let msg_builder = beginMessage(proxyWalletOpcodesV2.tonTransfer)
//       .storeCoins(opts.tonAmount)
//       .storeAddress(opts.refundAddress);
//     if (!opts.noPayloadOverride) {
//       if (opts.fwdPayload instanceof Cell) {
//         msg_builder = msg_builder.storeUint(1, 1).storeRef(opts.fwdPayload);
//       } else {
//         msg_builder = msg_builder.storeUint(0, 1).storeSlice(opts.fwdPayload);
//       }
//     }
//     return msg_builder.endCell();
//   }
//   async sendTonTransfer(
//     provider: ContractProvider,
//     via: Sender,
//     opts: {
//       tonAmount: bigint;
//       refundAddress: Address | ExternalAddress | null;
//       fwdPayload: Cell | Slice;
//       gas: bigint;
//       noPayloadOverride?: boolean; // only used to test refund
//     },
//     value?: bigint
//   ) {
//     if (!opts.gas) throw new Error('gas is 0');
//     let msg_builder = beginMessage(this.opCodes.tonTransfer)
//       .storeCoins(opts.tonAmount)
//       .storeAddress(opts.refundAddress);
//     let msg: Cell;
//     if (opts.noPayloadOverride) {
//       msg = msg_builder.endCell();
//     } else {
//       if (opts.fwdPayload instanceof Cell) {
//         msg = msg_builder.storeUint(1, 1).storeRef(opts.fwdPayload).endCell();
//       } else {
//         msg = msg_builder.storeUint(0, 1).storeSlice(opts.fwdPayload).endCell();
//       }
//     }
//     await provider.internal(via, {
//       value: value ?? opts.tonAmount + opts.gas,
//       sendMode: SendMode.PAY_GAS_SEPARATELY,
//       body: msg,
//     });
//   }
//   async sendResetGas(provider: ContractProvider, via: Sender, value: bigint) {
//     await provider.internal(via, {
//       value: value,
//       sendMode: SendMode.PAY_GAS_SEPARATELY,
//       body: beginMessage(this.opCodes.resetGas).endCell(),
//     });
//   }
// }

function positionNFTv3ContractConfigToCell(config) {
  return beginCell().storeAddress(config.poolAddress).storeAddress(config.userAddress).storeUint(config.liquidity, 128).storeInt(config.tickLow, 24).storeInt(config.tickHigh, 24).storeRef(beginCell().storeUint(config.feeGrowthInside0LastX128, 256).storeUint(config.feeGrowthInside1LastX128, 256).endCell()).endCell();
}
var PositionNFTV3Contract = /*#__PURE__*/function () {
  function PositionNFTV3Contract(address, init) {
    this.address = address;
    this.init = init;
  }
  PositionNFTV3Contract.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = positionNFTv3ContractConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new PositionNFTV3Contract(address, init);
  };
  var _proto = PositionNFTV3Contract.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  _proto.sendTransfer = /*#__PURE__*/function () {
    var _sendTransfer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, via, params) {
      var _params$value, _params$forwardAmount;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return provider.internal(via, {
              value: (_params$value = params.value) != null ? _params$value : toNano('0.05'),
              body: beginCell().storeUint(ContractOpcodes.POSITIONNFTV3_NFT_TRANSFER, 32) // op
              .storeUint(0, 64) // query id
              .storeAddress(params.to).storeAddress(params.responseTo).storeBit(false) // custom payload
              .storeCoins((_params$forwardAmount = params.forwardAmount) != null ? _params$forwardAmount : BigInt(0)).storeMaybeRef(params.forwardBody).endCell()
            });
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function sendTransfer(_x4, _x5, _x6) {
      return _sendTransfer.apply(this, arguments);
    }
    return sendTransfer;
  }() /** Getters * */;
  _proto.getBalance =
  /*#__PURE__*/
  function () {
    var _getBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider) {
      var _yield$provider$get, stack;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return provider.get('balance', []);
          case 2:
            _yield$provider$get = _context3.sent;
            stack = _yield$provider$get.stack;
            return _context3.abrupt("return", {
              number: stack.readNumber()
            });
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function getBalance(_x7) {
      return _getBalance.apply(this, arguments);
    }
    return getBalance;
  }();
  _proto.getUserAddress = /*#__PURE__*/function () {
    var _getUserAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider) {
      var _yield$provider$get2, stack;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return provider.get('getUserAddress', []);
          case 2:
            _yield$provider$get2 = _context4.sent;
            stack = _yield$provider$get2.stack;
            return _context4.abrupt("return", stack.readAddress());
          case 5:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function getUserAddress(_x8) {
      return _getUserAddress.apply(this, arguments);
    }
    return getUserAddress;
  }();
  _proto.getPoolAddress = /*#__PURE__*/function () {
    var _getPoolAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider) {
      var _yield$provider$get3, stack;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return provider.get('getPoolAddress', []);
          case 2:
            _yield$provider$get3 = _context5.sent;
            stack = _yield$provider$get3.stack;
            return _context5.abrupt("return", stack.readAddress());
          case 5:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function getPoolAddress(_x9) {
      return _getPoolAddress.apply(this, arguments);
    }
    return getPoolAddress;
  }();
  _proto.getPositionInfo = /*#__PURE__*/function () {
    var _getPositionInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider) {
      var _yield$provider$get4, stack;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return provider.get('getPositionInfo', []);
          case 2:
            _yield$provider$get4 = _context6.sent;
            stack = _yield$provider$get4.stack;
            return _context6.abrupt("return", {
              liquidity: stack.readBigNumber(),
              tickLow: stack.readNumber(),
              tickHigh: stack.readNumber(),
              feeGrowthInside0LastX128: stack.readBigNumber(),
              feeGrowthInside1LastX128: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function getPositionInfo(_x10) {
      return _getPositionInfo.apply(this, arguments);
    }
    return getPositionInfo;
  }() /* TODO: Should I use inheritance? */;
  _proto.getData =
  /*#__PURE__*/
  function () {
    var _getData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider) {
      var _yield$provider$get5, stack;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return provider.get('get_nft_data', []);
          case 2:
            _yield$provider$get5 = _context7.sent;
            stack = _yield$provider$get5.stack;
            return _context7.abrupt("return", {
              inited: stack.readBoolean(),
              index: stack.readNumber(),
              collection: stack.readAddressOpt(),
              owner: stack.readAddressOpt(),
              content: stack.readCellOpt()
            });
          case 5:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function getData(_x11) {
      return _getData.apply(this, arguments);
    }
    return getData;
  }();
  return PositionNFTV3Contract;
}();

/** Initial data structures and settings **/
var TIMELOCK_DELAY_DEFAULT = /*#__PURE__*/BigInt(2) * /*#__PURE__*/BigInt(24) * /*#__PURE__*/BigInt(60) * /*#__PURE__*/BigInt(60);
function routerv3ContractConfigToCell(config) {
  var _config$poolAdminAddr, _config$flags, _config$timelockDelay, _config$nonce;
  return beginCell().storeAddress(config.adminAddress).storeAddress((_config$poolAdminAddr = config.poolAdminAddress) != null ? _config$poolAdminAddr : config.adminAddress).storeAddress(config.poolFactoryAddress).storeUint((_config$flags = config.flags) != null ? _config$flags : 0, 64).storeUint(0, 64) // seqno
  .storeRef(beginCell().storeRef(config.poolv3_code).storeRef(config.accountv3_code).storeRef(config.position_nftv3_code).endCell()).storeRef(beginCell().storeUint((_config$timelockDelay = config.timelockDelay) != null ? _config$timelockDelay : TIMELOCK_DELAY_DEFAULT, 64) // timelock Delay
  .storeUint(0, 3) // 3 maybe refs for active timelocks
  .endCell()).storeUint((_config$nonce = config.nonce) != null ? _config$nonce : 0, 64).endCell();
}
function routerv3ContractCellToConfig(c) {
  var s = c.beginParse();
  var adminAddress = s.loadAddress();
  var poolAdminAddress = s.loadAddress();
  var poolFactoryAddress = s.loadAddress();
  var flags = s.loadUintBig(64);
  var seqno = s.loadUintBig(64);
  var subcodes = s.loadRef().beginParse();
  var poolv3_code = subcodes.loadRef();
  var accountv3_code = subcodes.loadRef();
  var position_nftv3_code = subcodes.loadRef();
  var timelocks = s.loadRef().beginParse();
  var timelockDelay = timelocks.loadUintBig(64);
  var nonce = undefined;
  if (s.remainingBits != 0) {
    nonce = s.loadUintBig(64);
  }
  return {
    adminAddress: adminAddress,
    poolAdminAddress: poolAdminAddress,
    poolFactoryAddress: poolFactoryAddress,
    flags: flags,
    poolv3_code: poolv3_code,
    accountv3_code: accountv3_code,
    position_nftv3_code: position_nftv3_code,
    timelockDelay: timelockDelay,
    nonce: nonce
  };
}
var RouterV3Contract = /*#__PURE__*/function () {
  function RouterV3Contract(address, init) {
    this.address = address;
    this.init = init;
  }
  RouterV3Contract.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = routerv3ContractConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new RouterV3Contract(address, init);
  };
  var _proto = RouterV3Contract.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  RouterV3Contract.deployPoolMessage = function deployPoolMessage(jetton0WalletAddr, jetton1WalletAddr, tickSpacing, sqrtPriceX96, activatePool, opts) {
    var _opts$nftContentPacke, _opts$nftItemContentP;
    var msg_body = beginCell().storeUint(ContractOpcodes.ROUTERV3_CREATE_POOL, 32) // OP code
    .storeUint(0, 64) // query_id
    .storeAddress(jetton0WalletAddr).storeAddress(jetton1WalletAddr).storeUint(tickSpacing, 24).storeUint(sqrtPriceX96, 160).storeUint(activatePool ? 1 : 0, 1).storeUint(opts.protocolFee ? opts.protocolFee : IMPOSSIBLE_FEE, 16).storeUint(opts.lpFee ? opts.lpFee : IMPOSSIBLE_FEE, 16).storeUint(opts.currentFee ? opts.currentFee : IMPOSSIBLE_FEE, 16).storeRef((_opts$nftContentPacke = opts.nftContentPacked) != null ? _opts$nftContentPacke : nftContentPackedDefault).storeRef((_opts$nftItemContentP = opts.nftItemContentPacked) != null ? _opts$nftItemContentP : nftItemContentPackedDefault).storeRef(beginCell().storeAddress(opts.jetton0Minter).storeAddress(opts.jetton1Minter).storeAddress(opts.controllerAddress).endCell()).endCell();
    return msg_body;
  }
  /* We need to rework printParsedInput not to double the code */;
  RouterV3Contract.unpackDeployPoolMessage = function unpackDeployPoolMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.ROUTERV3_CREATE_POOL) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    var jetton0WalletAddr = s.loadAddress();
    var jetton1WalletAddr = s.loadAddress();
    var tickSpacing = s.loadInt(24);
    var sqrtPriceX96 = s.loadUintBig(160);
    var activatePool = s.loadUint(1) != 0;
    var protocolFeeV = s.loadUint(16);
    var protocolFee = protocolFeeV < IMPOSSIBLE_FEE ? protocolFeeV : undefined;
    var lpFeeV = s.loadUint(16);
    var lpFee = lpFeeV < IMPOSSIBLE_FEE ? lpFeeV : undefined;
    var currentFeeV = s.loadUint(16);
    var currentFee = currentFeeV < IMPOSSIBLE_FEE ? currentFeeV : undefined;
    var nftContentPacked = s.loadRef();
    var nftItemContentPacked = s.loadRef();
    var s1 = s.loadRef().beginParse();
    var jetton0Minter = s1.loadAddress();
    var jetton1Minter = s1.loadAddress();
    var controllerAddress = s1.loadAddress();
    return {
      jetton0WalletAddr: jetton0WalletAddr,
      jetton1WalletAddr: jetton1WalletAddr,
      tickSpacing: tickSpacing,
      sqrtPriceX96: sqrtPriceX96,
      activatePool: activatePool,
      jetton0Minter: jetton0Minter,
      jetton1Minter: jetton1Minter,
      controllerAddress: controllerAddress,
      nftContentPacked: nftContentPacked,
      nftItemContentPacked: nftItemContentPacked,
      protocolFee: protocolFee,
      lpFee: lpFee,
      currentFee: currentFee
    };
  }
  /* Deploy pool */;
  _proto.sendDeployPool =
  /*#__PURE__*/
  function () {
    var _sendDeployPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, sender, value, jetton0WalletAddr, jetton1WalletAddr, tickSpacing, sqrtPriceX96, activatePool, opts) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            msg_body = RouterV3Contract.deployPoolMessage(jetton0WalletAddr, jetton1WalletAddr, tickSpacing, sqrtPriceX96, activatePool, opts);
            _context2.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function sendDeployPool(_x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
      return _sendDeployPool.apply(this, arguments);
    }
    return sendDeployPool;
  }();
  _proto.sendResetGas = /*#__PURE__*/function () {
    var _sendResetGas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.ROUTERV3_RESET_GAS, 32) // OP code
            .storeUint(0, 64) // QueryID what for?
            .endCell();
            _context3.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context3.abrupt("return", _context3.sent);
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function sendResetGas(_x13, _x14, _x15) {
      return _sendResetGas.apply(this, arguments);
    }
    return sendResetGas;
  }() /* =============  CHANGE ADMIN =============  */;
  RouterV3Contract.changeAdminStartMessage = function changeAdminStartMessage(opts) {
    var msg = beginCell().storeUint(ContractOpcodes.ROUTERV3_CHANGE_ADMIN_START, 32) // OP code
    .storeUint(0, 64); // QueryID what for?
    if (opts.newAdmin == undefined) {
      msg.storeUint(0, 1);
      msg.storeAddress(null);
    } else {
      msg.storeUint(1, 1);
      msg.storeAddress(opts.newAdmin);
    }
    if (opts.newFlags == undefined) {
      msg.storeUint(0, 1);
      msg.storeUint(0, 64);
    } else {
      msg.storeUint(1, 1);
      msg.storeUint(opts.newFlags, 64);
    }
    if (opts.newCode == undefined) {
      msg.storeUint(0, 1);
    } else {
      msg.storeMaybeRef(opts.newCode);
    }
    return msg.endCell();
  };
  RouterV3Contract.unpackChangeAdminStartMessage = function unpackChangeAdminStartMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.ROUTERV3_CHANGE_ADMIN_START) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    var setAdmin = s.loadBoolean();
    var newAdmin = setAdmin ? s.loadAddress() : undefined;
    if (!setAdmin) {
      s.loadUint(2);
    }
    var setFlags = s.loadBoolean();
    var newFlags = setFlags ? s.loadUintBig(64) : undefined;
    if (!setFlags) {
      s.loadUintBig(64);
    }
    var newCodeV = s.loadMaybeRef();
    var newCode = newCodeV != null ? newCodeV : undefined;
    return {
      newAdmin: newAdmin,
      newFlags: newFlags,
      newCode: newCode
    };
  };
  _proto.sendChangeAdminStart = /*#__PURE__*/function () {
    var _sendChangeAdminStart = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, sender, value, opts) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            msg_body = RouterV3Contract.changeAdminStartMessage(opts);
            _context4.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context4.abrupt("return", _context4.sent);
          case 4:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendChangeAdminStart(_x16, _x17, _x18, _x19) {
      return _sendChangeAdminStart.apply(this, arguments);
    }
    return sendChangeAdminStart;
  }();
  RouterV3Contract.changeAdminCommitMessage = function changeAdminCommitMessage() {
    var msg = beginCell().storeUint(ContractOpcodes.ROUTERV3_CHANGE_ADMIN_COMMIT, 32) // OP code
    .storeUint(0, 64) // QueryID what for?
    .endCell();
    return msg;
  };
  RouterV3Contract.unpackChangeAdminCommitMessage = function unpackChangeAdminCommitMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.ROUTERV3_CHANGE_ADMIN_COMMIT) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    return {};
  };
  _proto.sendChangeAdminCommit = /*#__PURE__*/function () {
    var _sendChangeAdminCommit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            msg_body = RouterV3Contract.changeAdminCommitMessage();
            _context5.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context5.abrupt("return", _context5.sent);
          case 4:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function sendChangeAdminCommit(_x20, _x21, _x22) {
      return _sendChangeAdminCommit.apply(this, arguments);
    }
    return sendChangeAdminCommit;
  }() /* =============  CHANGE PARAMS =============  */;
  RouterV3Contract.changeRouterParamMessage = function changeRouterParamMessage(opts) {
    var _opts$newPoolFactory, _opts$newPoolAdmin;
    return beginCell().storeUint(ContractOpcodes.ROUTERV3_CHANGE_PARAMS, 32) // OP code
    .storeUint(0, 64) // QueryID what for?
    //            .storeUint(opts.newFlags ? 1 : 0, 1)
    //            .storeUint(opts.newFlags ?? 0, 64)
    .storeUint(opts.newPoolFactory ? 1 : 0, 1).storeAddress((_opts$newPoolFactory = opts.newPoolFactory) != null ? _opts$newPoolFactory : BLACK_HOLE_ADDRESS).storeUint(opts.newPoolAdmin ? 1 : 0, 1).storeAddress((_opts$newPoolAdmin = opts.newPoolAdmin) != null ? _opts$newPoolAdmin : BLACK_HOLE_ADDRESS).endCell();
  };
  RouterV3Contract.unpackChangeRouterParamMessage = function unpackChangeRouterParamMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.ROUTERV3_CHANGE_PARAMS) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    //        const hasNewFlags = s.loadBit()
    //        const newFlags = hasNewFlags ? s.loadUintBig(64) : undefined
    var hasPoolFactory = s.loadBit();
    var newPoolFactoryV = s.loadAddress();
    var newPoolFactory = hasPoolFactory ? newPoolFactoryV : undefined;
    var hasPoolAdmin = s.loadBit();
    var newPoolAdminV = s.loadAddress();
    var newPoolAdmin = hasPoolAdmin ? newPoolAdminV : undefined;
    return {
      newPoolAdmin: newPoolAdmin,
      newPoolFactory: newPoolFactory
    };
  };
  _proto.sendChangeRouterParams = /*#__PURE__*/function () {
    var _sendChangeRouterParams = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider, sender, value, opts) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            msg_body = RouterV3Contract.changeRouterParamMessage(opts);
            _context6.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context6.abrupt("return", _context6.sent);
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function sendChangeRouterParams(_x23, _x24, _x25, _x26) {
      return _sendChangeRouterParams.apply(this, arguments);
    }
    return sendChangeRouterParams;
  }() /** Getters **/;
  _proto.getState =
  /*#__PURE__*/
  function () {
    var _getState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(provider) {
      var _yield$provider$get, stack;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return provider.get('getRouterState', []);
          case 2:
            _yield$provider$get = _context7.sent;
            stack = _yield$provider$get.stack;
            return _context7.abrupt("return", {
              admin: stack.readAddress(),
              pool_admin: stack.readAddress(),
              pool_factory: stack.readAddress(),
              flags: stack.readBigNumber(),
              pool_seqno: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    function getState(_x27) {
      return _getState.apply(this, arguments);
    }
    return getState;
  }();
  _proto.getAdminAddress = /*#__PURE__*/function () {
    var _getAdminAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(provider) {
      var state;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.getState(provider);
          case 2:
            state = _context8.sent;
            return _context8.abrupt("return", state.admin);
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function getAdminAddress(_x28) {
      return _getAdminAddress.apply(this, arguments);
    }
    return getAdminAddress;
  }();
  _proto.getPoolFactoryAddress = /*#__PURE__*/function () {
    var _getPoolFactoryAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(provider) {
      var state;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return this.getState(provider);
          case 2:
            state = _context9.sent;
            return _context9.abrupt("return", state.pool_factory);
          case 4:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getPoolFactoryAddress(_x29) {
      return _getPoolFactoryAddress.apply(this, arguments);
    }
    return getPoolFactoryAddress;
  }();
  _proto.getPoolAddress = /*#__PURE__*/function () {
    var _getPoolAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider, jetton0WalletAddr, jetton1WalletAddr) {
      var _yield$provider$get2, stack;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return provider.get('getPoolAddress', [{
              type: 'slice',
              cell: beginCell().storeAddress(jetton0WalletAddr).endCell()
            }, {
              type: 'slice',
              cell: beginCell().storeAddress(jetton1WalletAddr).endCell()
            }]);
          case 2:
            _yield$provider$get2 = _context10.sent;
            stack = _yield$provider$get2.stack;
            return _context10.abrupt("return", stack.readAddress());
          case 5:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    function getPoolAddress(_x30, _x31, _x32) {
      return _getPoolAddress.apply(this, arguments);
    }
    return getPoolAddress;
  }();
  _proto.getChildContracts = /*#__PURE__*/function () {
    var _getChildContracts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(provider) {
      var _yield$provider$get3, stack;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return provider.get('getChildContracts', []);
          case 2:
            _yield$provider$get3 = _context11.sent;
            stack = _yield$provider$get3.stack;
            return _context11.abrupt("return", {
              poolCode: stack.readCell(),
              accountCode: stack.readCell(),
              positionNFTCode: stack.readCell()
            });
          case 5:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    function getChildContracts(_x33) {
      return _getChildContracts.apply(this, arguments);
    }
    return getChildContracts;
  }();
  _proto.getPoolInitialData = /*#__PURE__*/function () {
    var _getPoolInitialData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(provider, jetton0WalletAddr, jetton1WalletAddr) {
      var _yield$provider$get4, stack;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return provider.get('getPoolInitialData', [{
              type: 'slice',
              cell: beginCell().storeAddress(jetton0WalletAddr).endCell()
            }, {
              type: 'slice',
              cell: beginCell().storeAddress(jetton1WalletAddr).endCell()
            }]);
          case 2:
            _yield$provider$get4 = _context12.sent;
            stack = _yield$provider$get4.stack;
            return _context12.abrupt("return", stack.readCell());
          case 5:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    function getPoolInitialData(_x34, _x35, _x36) {
      return _getPoolInitialData.apply(this, arguments);
    }
    return getPoolInitialData;
  }();
  _proto.getPoolStateInit = /*#__PURE__*/function () {
    var _getPoolStateInit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(provider, jetton0WalletAddr, jetton1WalletAddr) {
      var _yield$provider$get5, stack;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return provider.get('getPoolStateInit', [{
              type: 'slice',
              cell: beginCell().storeAddress(jetton0WalletAddr).endCell()
            }, {
              type: 'slice',
              cell: beginCell().storeAddress(jetton1WalletAddr).endCell()
            }]);
          case 2:
            _yield$provider$get5 = _context13.sent;
            stack = _yield$provider$get5.stack;
            return _context13.abrupt("return", stack.readCell());
          case 5:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    }));
    function getPoolStateInit(_x37, _x38, _x39) {
      return _getPoolStateInit.apply(this, arguments);
    }
    return getPoolStateInit;
  }();
  return RouterV3Contract;
}();
RouterV3Contract.RESULT_SWAP_OK = ContractErrors.POOLV3_RESULT_SWAP_OK;
RouterV3Contract.RESULT_BURN_OK = ContractErrors.POOLV3_RESULT_BURN_OK;

function accountv3ContractConfigToCell(config) {
  return beginCell().storeAddress(config.user).storeAddress(config.pool).storeRef(beginCell().storeCoins(config.stored0).storeCoins(config.stored1).storeCoins(config.enough0).storeCoins(config.enough1).endCell()).endCell();
}
var AccountV3Contract = /*#__PURE__*/function () {
  function AccountV3Contract(address, init) {
    this.address = address;
    this.init = init;
  }
  AccountV3Contract.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = accountv3ContractConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new AccountV3Contract(address, init);
  };
  var _proto = AccountV3Contract.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, sender, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  _proto.sendResetGas = /*#__PURE__*/function () {
    var _sendResetGas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.ACCOUNTV3_RESET_GAS, 32) // OP code
            .storeUint(0, 64) // QueryID what for?
            .endCell();
            _context2.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context2.abrupt("return", _context2.sent);
          case 4:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function sendResetGas(_x4, _x5, _x6) {
      return _sendResetGas.apply(this, arguments);
    }
    return sendResetGas;
  }() /* Test only : Would be accepted only from pool */;
  _proto.sendAddLiquidity =
  /*#__PURE__*/
  function () {
    var _sendAddLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, sender, value, newAmount0, newAmount1, minLPOut) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.ACCOUNTV3_ADD_LIQUIDITY, 32) // OP code
            .storeCoins(newAmount0).storeCoins(newAmount1).storeCoins(minLPOut).endCell();
            _context3.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context3.abrupt("return", _context3.sent);
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function sendAddLiquidity(_x7, _x8, _x9, _x10, _x11, _x12) {
      return _sendAddLiquidity.apply(this, arguments);
    }
    return sendAddLiquidity;
  }();
  _proto.sendRefundMe = /*#__PURE__*/function () {
    var _sendRefundMe = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.ACCOUNTV3_REFUND_ME, 32) // OP code
            .storeUint(0, 64) // query_id
            .endCell();
            _context4.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context4.abrupt("return", _context4.sent);
          case 4:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sendRefundMe(_x13, _x14, _x15) {
      return _sendRefundMe.apply(this, arguments);
    }
    return sendRefundMe;
  }();
  _proto.refundMe = /*#__PURE__*/function () {
    var _refundMe = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, sender, value) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            msg_body = beginCell().storeUint(ContractOpcodes.ACCOUNTV3_REFUND_ME, 32) // OP code
            .endCell();
            _context5.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
            return _context5.abrupt("return", _context5.sent);
          case 4:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function refundMe(_x16, _x17, _x18) {
      return _refundMe.apply(this, arguments);
    }
    return refundMe;
  }() /* Getters */;
  _proto.getAccountData =
  /*#__PURE__*/
  function () {
    var _getAccountData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(provider) {
      var _yield$provider$get, stack;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return provider.get('get_account_data', []);
          case 2:
            _yield$provider$get = _context6.sent;
            stack = _yield$provider$get.stack;
            return _context6.abrupt("return", {
              user_address: stack.readAddress(),
              pool_address: stack.readAddress(),
              amount0: stack.readBigNumber(),
              amount1: stack.readBigNumber(),
              enought0: stack.readBigNumber(),
              enought1: stack.readBigNumber()
            });
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function getAccountData(_x19) {
      return _getAccountData.apply(this, arguments);
    }
    return getAccountData;
  }();
  return AccountV3Contract;
}();

function poolFactoryContractConfigToCell(config) {
  return beginCell().storeAddress(config.adminAddress).storeAddress(config.routerAddress).storeRef(config.nftv3Content).storeRef(config.nftv3itemContent).endCell();
}
var PoolFactoryContract = /*#__PURE__*/function () {
  function PoolFactoryContract(address, init) {
    this.address = address;
    this.init = init;
  }
  PoolFactoryContract.createFromConfig = function createFromConfig(config, code, workchain) {
    if (workchain === void 0) {
      workchain = 0;
    }
    var data = poolFactoryContractConfigToCell(config);
    var init = {
      code: code,
      data: data
    };
    var address = contractAddress(workchain, init);
    return new PoolFactoryContract(address, init);
  };
  var _proto = PoolFactoryContract.prototype;
  _proto.sendDeploy = /*#__PURE__*/function () {
    var _sendDeploy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider, via, value) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return provider.internal(via, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: beginCell().endCell()
            });
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function sendDeploy(_x, _x2, _x3) {
      return _sendDeploy.apply(this, arguments);
    }
    return sendDeploy;
  }();
  PoolFactoryContract.deployPoolMessage = function deployPoolMessage(jetton0Minter, jetton1Minter, sqrtPriceX96, settings, jetton0Wallet, jetton1Wallet) {
    var msg_body = beginCell().storeUint(ContractOpcodes.POOL_FACTORY_CREATE_POOL, 32) // OP code
    .storeUint(0, 64) // query_id
    .storeAddress(jetton0Minter).storeAddress(jetton1Minter).storeUint(sqrtPriceX96, 160).storeUint(settings, 16).storeRef(beginCell().storeAddress(jetton0Wallet).storeAddress(jetton1Wallet).endCell()).endCell();
    return msg_body;
  }
  /* We need to rework printParsedInput not to double the code */;
  PoolFactoryContract.unpackDeployPoolMessage = function unpackDeployPoolMessage(body) {
    var s = body.beginParse();
    var op = s.loadUint(32);
    if (op != ContractOpcodes.ROUTERV3_CREATE_POOL) throw Error('Wrong opcode');
    var query_id = s.loadUint(64);
    var jetton0Minter = s.loadAddress();
    var jetton1Minter = s.loadAddress();
    var sqrtPriceX96 = s.loadUintBig(160);
    var settings = s.loadUintBig(16);
    var wallets = s.loadRef().beginParse();
    var jetton0Wallet = wallets.loadAddress();
    var jetton1Wallet = wallets.loadAddress();
    return {
      jetton0Minter: jetton0Minter,
      jetton1Minter: jetton1Minter,
      sqrtPriceX96: sqrtPriceX96,
      settings: settings,
      jetton0Wallet: jetton0Wallet,
      jetton1Wallet: jetton1Wallet
    };
  }
  /* Deploy pool */;
  _proto.sendDeployPool =
  /*#__PURE__*/
  function () {
    var _sendDeployPool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, sender, value, jetton0Minter, jetton1Minter, sqrtPriceX96, settings, jetton0Wallet, jetton1Wallet) {
      var msg_body;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            msg_body = PoolFactoryContract.deployPoolMessage(jetton0Minter, jetton1Minter, sqrtPriceX96, settings, jetton0Wallet, jetton1Wallet);
            _context2.next = 3;
            return provider.internal(sender, {
              value: value,
              sendMode: SendMode.PAY_GAS_SEPARATELY,
              body: msg_body
            });
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    function sendDeployPool(_x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12) {
      return _sendDeployPool.apply(this, arguments);
    }
    return sendDeployPool;
  }();
  _proto.sendNewData = /*#__PURE__*/function () {
    var _sendNewData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, via, value, routerAddress, nftv3Content, nftv3itemContent) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return provider.internal(via, {
              value: value,
              body: beginCell().storeUint(ContractOpcodes.POOL_FACTORY_CHANGE_PARAMS, 32) // op
              .storeUint(0, 64) // query id
              .storeAddress(routerAddress).storeRef(nftv3Content != null ? nftv3Content : Cell.EMPTY).storeRef(nftv3itemContent != null ? nftv3itemContent : Cell.EMPTY).endCell()
            });
          case 2:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function sendNewData(_x13, _x14, _x15, _x16, _x17, _x18) {
      return _sendNewData.apply(this, arguments);
    }
    return sendNewData;
  }() /* Getters */;
  _proto.getPoolFactoryData =
  /*#__PURE__*/
  function () {
    var _getPoolFactoryData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider) {
      var _yield$provider$get, stack;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return provider.get('getPoolFactoryData', []);
          case 2:
            _yield$provider$get = _context4.sent;
            stack = _yield$provider$get.stack;
            return _context4.abrupt("return", {
              admin_address: stack.readAddress(),
              router_address: stack.readAddress(),
              nftv3_content: stack.readCell(),
              nftv3item_content: stack.readCell()
            });
          case 5:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function getPoolFactoryData(_x19) {
      return _getPoolFactoryData.apply(this, arguments);
    }
    return getPoolFactoryData;
  }();
  return PoolFactoryContract;
}();

function getSwapEstimate(_x, _x2, _x3, _x4) {
  return _getSwapEstimate.apply(this, arguments);
}
function _getSwapEstimate() {
  _getSwapEstimate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(
  // inputJetton: Jetton,
  amountIn, poolAddress, zeroToOne, client) {
    var poolV3Contract, res, _res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          poolV3Contract = client.open(new PoolV3Contract(Address.parse(poolAddress))); // /* pool.jetton0 and pool.jetton1 are always sorted, so jetton0 is always first */
          // const zeroToOne = amountIn.jetton.equals(pool.jetton0);
          // or
          // const zeroToOne = PoolV3Contract.orderJettonId(jetton0RouterWallet, jetton1RouterWallet);
          // or
          // const { jetton0_minter } = await poolV3Contract.getPoolStateAndConfiguration();
          // const zeroToOne = Address.parse(inputJetton.address).equals(Address.parse(jetton0_minter));
          if (!zeroToOne) {
            _context.next = 8;
            break;
          }
          _context.next = 4;
          return poolV3Contract.getSwapEstimate(zeroToOne, amountIn, BigInt(TickMath.MIN_SQRT_RATIO.toString()) + BigInt(1));
        case 4:
          res = _context.sent;
          return _context.abrupt("return", -res.amount1);
        case 8:
          _context.next = 10;
          return poolV3Contract.getSwapEstimate(zeroToOne, amountIn, BigInt(TickMath.MAX_SQRT_RATIO.toString()) - BigInt(1));
        case 10:
          _res = _context.sent;
          return _context.abrupt("return", -_res.amount0);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getSwapEstimate.apply(this, arguments);
}

var SwapType;
(function (SwapType) {
  SwapType[SwapType["TON_TO_JETTON"] = 0] = "TON_TO_JETTON";
  SwapType[SwapType["JETTON_TO_TON"] = 1] = "JETTON_TO_TON";
  SwapType[SwapType["JETTON_TO_JETTON"] = 2] = "JETTON_TO_JETTON";
})(SwapType || (SwapType = {}));
var CollectType;
(function (CollectType) {
  CollectType[CollectType["TON"] = 0] = "TON";
  CollectType[CollectType["JETTON"] = 1] = "JETTON";
  CollectType[CollectType["TON_JETTON"] = 2] = "TON_JETTON";
  CollectType[CollectType["JETTON_TON"] = 3] = "JETTON_TON";
})(CollectType || (CollectType = {}));
var getTonRefundAmount = function getTonRefundAmount(trace) {
  var _in_msg_0$destination;
  var isForked = trace.length > 1;
  var in_msg_0 = trace[0].transaction.in_msg;
  if ((in_msg_0 == null ? void 0 : in_msg_0.op_code) === '0x0f8a7ea5' &&
  // "jetton_transfer"
  (in_msg_0 == null || (_in_msg_0$destination = in_msg_0.destination) == null ? void 0 : _in_msg_0$destination.address) === Address$1.parse(pTON_ROUTER_WALLET).toRawString()) {
    return BigInt(in_msg_0.decoded_body.amount);
  }
  if (isForked) {
    var _in_msg_1$destination;
    var in_msg_1 = trace[1].transaction.in_msg;
    if ((in_msg_1 == null ? void 0 : in_msg_1.op_code) === '0x0f8a7ea5' &&
    // "jetton_transfer"
    (in_msg_1 == null || (_in_msg_1$destination = in_msg_1.destination) == null ? void 0 : _in_msg_1$destination.address) === Address$1.parse(pTON_ROUTER_WALLET).toRawString()) {
      return BigInt(in_msg_1.decoded_body.amount);
    }
    if (!trace[1].children && trace[0].children) {
      var childResult = getTonRefundAmount(trace[0].children);
      if (childResult !== BigInt(0)) {
        return childResult;
      }
    } else if (trace[1].children && !trace[0].children) {
      var _childResult = getTonRefundAmount(trace[1].children);
      if (_childResult !== BigInt(0)) {
        return _childResult;
      }
    }
  } else {
    if (trace[0].children) {
      var _childResult2 = getTonRefundAmount(trace[0].children);
      if (_childResult2 !== BigInt(0)) {
        return _childResult2;
      }
    }
  }
  return BigInt(0);
};
function beginMessage(op) {
  return beginCell$1().storeUint(typeof op === 'string' ? crc32(op) : op, 32).storeUint(BigInt(Math.floor(Math.random() * Math.pow(2, 31))), 64);
}
var PoolMessageManager = /*#__PURE__*/function () {
  /**
   * Cannot be constructed.
   */
  function PoolMessageManager() {}
  PoolMessageManager.createDeployPoolMessage = function createDeployPoolMessage(jetton0Minter, jetton1Minter, sqrtPriceX96, settings, jetton0Wallet, jetton1Wallet) {
    var payload = PoolFactoryContract.deployPoolMessage(jetton0Minter, jetton1Minter, sqrtPriceX96, settings, jetton0Wallet, jetton1Wallet);
    var message = {
      to: Address$1.parse(POOL_FACTORY),
      value: this.gasUsage.DEPLOY_POOL_GAS,
      body: payload
    };
    return message;
  };
  PoolMessageManager.createMintMessage = function createMintMessage(routerJetton0Wallet, routerJetton1Wallet, userJetton0Wallet, userJetton1Wallet, position, recipient, slippage,
  // 1 %
  txFee,
  // 0.4
  forwardGas // 0.1 // 2 maximum transfers per 1 msg
  ) {
    if (slippage === void 0) {
      slippage = new Percent(1, 100);
    }
    if (txFee === void 0) {
      txFee = this.gasUsage.MINT_GAS;
    }
    if (forwardGas === void 0) {
      forwardGas = this.gasUsage.TRANSFER_GAS * BigInt(2);
    }
    !JSBI.greaterThan(position.liquidity, ZERO) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ZERO_LIQUIDITY') : invariant(false) : void 0;
    var mintPartGas = txFee / BigInt(2);
    var messages = [];
    var _position$mintAmounts = position.mintAmounts,
      amount0 = _position$mintAmounts.amount0,
      amount1 = _position$mintAmounts.amount1;
    var isSorted = PoolV3Contract.orderJettonId(routerJetton0Wallet, routerJetton1Wallet);
    var jetton0Amount = isSorted ? BigInt(amount0.toString()) : BigInt(amount1.toString());
    var jetton1Amount = isSorted ? BigInt(amount1.toString()) : BigInt(amount0.toString());
    var slippageMultiplier = slippage.add(ONE);
    /* to transfer with slippage */
    var amount0WithSlippage = BigInt(slippageMultiplier.multiply(jetton0Amount.toString()).quotient.toString());
    var amount1WithSlippage = BigInt(slippageMultiplier.multiply(jetton1Amount.toString()).quotient.toString());
    var isJetton0TON = routerJetton0Wallet.equals(Address$1.parse(pTON_ROUTER_WALLET));
    var isJetton1TON = routerJetton1Wallet.equals(Address$1.parse(pTON_ROUTER_WALLET));
    var mintRequest0;
    var mintRequest1;
    mintRequest0 = beginCell$1().storeUint(ContractOpcodes.POOLV3_FUND_ACCOUNT, 32) // Request to minting part 0
    .storeAddress(routerJetton1Wallet) // Jetton1 Wallet attached to Router is used to identify target token
    .storeCoins(jetton0Amount).storeCoins(jetton1Amount).storeUint(BigInt(position.liquidity.toString()), 128) // Liquidity. First transaction don't want actully to mint anything.
    .storeInt(BigInt(position.tickLower.toString()), 24) // Min tick.  Actually for the part 1 could be 0 it is ignored
    .storeInt(BigInt(position.tickUpper.toString()), 24) // Max tick.  Actually for the part 1 could be 0 it is ignored
    .endCell();
    mintRequest1 = beginCell$1().storeUint(ContractOpcodes.POOLV3_FUND_ACCOUNT, 32) // Request to minting part 1
    .storeAddress(routerJetton0Wallet) // Jetton0 Wallet attached to Router is used to identify target token
    .storeCoins(jetton1Amount).storeCoins(jetton0Amount).storeUint(BigInt(position.liquidity.toString()), 128) // Liquidity to mint
    .storeInt(BigInt(position.tickLower.toString()), 24) // Min tick.
    .storeInt(BigInt(position.tickUpper.toString()), 24) // Max tick.
    .endCell();
    if (isJetton0TON) {
      mintRequest0 = beginCell$1().storeUint(proxyWalletOpcodesV2.tonTransfer, 32).storeUint(0, 64) // query_id
      .storeCoins(jetton0Amount) // ton To Send. It would we wrapped and then lp minted from them
      .storeAddress(recipient) // refundAddress
      .storeUint(1, 1) // flag that shows that paylod is a cell
      .storeRef(mintRequest0) // Instructions for the pool
      .endCell();
    }
    // isTON
    if (isJetton1TON) {
      mintRequest1 = beginCell$1().storeUint(proxyWalletOpcodesV2.tonTransfer, 32).storeUint(0, 64) // query_id
      .storeCoins(jetton1Amount) // ton To Send. It would we wrapped and then lp minted from them
      .storeAddress(recipient) // refundAddress
      .storeUint(1, 1) // flag that shows that paylod is a cell
      .storeRef(mintRequest1) // Instructions for the pool
      .endCell();
    }
    var payload0 = JettonWallet.transferMessage(amount0WithSlippage, Address$1.parse(ROUTER), recipient, null, forwardGas,
    // 0.1
    mintRequest0);
    var payload1 = JettonWallet.transferMessage(amount1WithSlippage, Address$1.parse(ROUTER), recipient, null, forwardGas,
    // 0.1
    mintRequest1);
    if (isJetton1TON && amount1WithSlippage > BigInt(0)) {
      messages.push({
        to: Address$1.parse(pTON_ROUTER_WALLET),
        value: amount1WithSlippage + mintPartGas + forwardGas,
        body: mintRequest1
      });
    } else if (!isJetton1TON && jetton1Amount > BigInt(0)) {
      messages.push({
        to: userJetton1Wallet,
        value: mintPartGas + forwardGas,
        body: payload1
      });
    }
    if (isJetton0TON && amount0WithSlippage > BigInt(0)) {
      messages.push({
        to: Address$1.parse(pTON_ROUTER_WALLET),
        value: amount0WithSlippage + mintPartGas + forwardGas,
        body: mintRequest0
      });
    } else if (!isJetton0TON && jetton0Amount > BigInt(0)) {
      messages.push({
        to: userJetton0Wallet,
        value: mintPartGas + forwardGas,
        body: payload0
      });
    }
    return messages;
  };
  PoolMessageManager.createEmulatedMintMessage = /*#__PURE__*/function () {
    var _createEmulatedMintMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(routerJetton0Wallet, routerJetton1Wallet, userJetton0Wallet, userJetton1Wallet, position, recipient, slippage,
    // 1 %
    client,
    // ton api client
    wallet_public_key, walletVersion) {
      var txFee, forwardGas, messages, emulation, _emulation$event$acti, tonRevertedFromPool, emulatedGas, emulatedMessages;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (slippage === void 0) {
              slippage = /*#__PURE__*/new Percent(1, 100);
            }
            txFee = this.gasUsage.MINT_GAS; // 0.4
            forwardGas = this.gasUsage.TRANSFER_GAS * BigInt(2); // 0.1 // 2 maximum transfers per 1 msg
            messages = this.createMintMessage(routerJetton0Wallet, routerJetton1Wallet, userJetton0Wallet, userJetton1Wallet, position, recipient, slippage);
            /* emulate message */
            if (!(client && wallet_public_key && walletVersion)) {
              _context.next = 15;
              break;
            }
            _context.prev = 5;
            _context.next = 8;
            return emulateMessage(client, messages, recipient.toString(), wallet_public_key, walletVersion);
          case 8:
            emulation = _context.sent;
            if (emulation) {
              tonRevertedFromPool = (_emulation$event$acti = emulation.event.actions.find(function (event) {
                return event.TonTransfer;
              })) == null || (_emulation$event$acti = _emulation$event$acti.TonTransfer) == null ? void 0 : _emulation$event$acti.amount;
              emulatedGas = BigInt(Math.abs(emulation.event.extra));
              /* tx fee calc */
              if (tonRevertedFromPool) {
                txFee = emulatedGas - BigInt(tonRevertedFromPool || 0);
              } else {
                txFee = emulatedGas;
              }
              // const emulated = this.createMintMessage(
              //   routerJetton0Wallet,
              //   routerJetton1Wallet,
              //   userJetton0Wallet,
              //   userJetton1Wallet,
              //   position,
              //   recipient,
              //   slippage,
              //   messages.length === 1 ? txFee * BigInt(2) : txFee,
              //   forwardGas
              // );
            }
            _context.next = 15;
            break;
          case 12:
            _context.prev = 12;
            _context.t0 = _context["catch"](5);
            console.log('error emulation - ', _context.t0);
          case 15:
            emulatedMessages = {
              messages: messages,
              txFee: txFee,
              forwardGas: forwardGas * BigInt(messages.length),
              gasLimit: messages.length === 1 ? toNano$1(0.3) : toNano$1(0.6)
            };
            console.log('success emulation - ', emulatedMessages);
            return _context.abrupt("return", emulatedMessages);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[5, 12]]);
    }));
    function createEmulatedMintMessage(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
      return _createEmulatedMintMessage.apply(this, arguments);
    }
    return createEmulatedMintMessage;
  }();
  PoolMessageManager.createBurnMessage = function createBurnMessage(poolAddress, tokenId, tickLower, tickUpper, liquidityToBurn, txFee, forwardGas // gas slippage
  ) {
    if (txFee === void 0) {
      txFee = this.gasUsage.BURN_GAS;
    }
    if (forwardGas === void 0) {
      forwardGas = BigInt(0);
    }
    var payload = beginCell$1().storeUint(ContractOpcodes.POOLV3_START_BURN, 32) // op
    .storeUint(0, 64) // query id
    .storeUint(tokenId, 64).storeUint(liquidityToBurn, 128).storeInt(tickLower, 24).storeInt(tickUpper, 24).endCell();
    var message = {
      to: poolAddress,
      value: txFee + forwardGas,
      body: payload
    };
    return message;
  };
  PoolMessageManager.createEmulatedBurnMessage = /*#__PURE__*/function () {
    var _createEmulatedBurnMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(poolAddress, tokenId, tickLower, tickUpper, liquidityToBurn, amount0, amount1, feeAmount0, feeAmount1, client,
    // ton api client
    wallet, wallet_public_key, walletVersion) {
      var txFee, forwardGas, message, isJetton0TON, isJetton1TON, tonToBurn, emulation, emulatedGas, _emulation$event$acti2, isOnlyTon, tonRevertedFromPool, emulatedMessage;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            txFee = this.gasUsage.BURN_GAS; // 0.3
            forwardGas = BigInt(0);
            message = this.createBurnMessage(poolAddress, tokenId, tickLower, tickUpper, liquidityToBurn);
            isJetton0TON = amount0 && Address$1.parse(amount0.jetton.address).equals(Address$1.parse(pTON_MINTER));
            isJetton1TON = amount1 && Address$1.parse(amount1.jetton.address).equals(Address$1.parse(pTON_MINTER));
            tonToBurn = isJetton0TON ? BigInt(amount0.quotient.toString()) + BigInt((feeAmount0 == null ? void 0 : feeAmount0.quotient.toString()) || 0) : isJetton1TON ? BigInt(amount1.quotient.toString()) + BigInt((feeAmount1 == null ? void 0 : feeAmount1.quotient.toString()) || 0) : BigInt(0);
            if (!(wallet && client && wallet_public_key && walletVersion)) {
              _context2.next = 17;
              break;
            }
            _context2.prev = 7;
            _context2.next = 10;
            return emulateMessage(client, [message], wallet, wallet_public_key, walletVersion);
          case 10:
            emulation = _context2.sent;
            if (emulation) {
              emulatedGas = BigInt(Math.abs(emulation.event.extra));
              if (tonToBurn && tonToBurn > BigInt(0)) {
                isOnlyTon = isJetton0TON && (amount1 == null ? void 0 : amount1.quotient.toString()) === '0' && (feeAmount1 == null ? void 0 : feeAmount1.quotient.toString()) === '0' || isJetton1TON && (amount0 == null ? void 0 : amount0.quotient.toString()) === '0' && (feeAmount0 == null ? void 0 : feeAmount0.quotient.toString()) === '0';
                tonRevertedFromPool = (_emulation$event$acti2 = emulation.event.actions.find(function (event) {
                  return event.TonTransfer;
                })) == null || (_emulation$event$acti2 = _emulation$event$acti2.TonTransfer) == null ? void 0 : _emulation$event$acti2.amount;
                txFee = tonToBurn + (txFee - BigInt(tonRevertedFromPool || 0) - (isOnlyTon ? -emulatedGas : emulatedGas));
                // forwardGas = this.gasUsage.BURN_GAS_SLIPPAGE * BigInt(2); // 0.1
              } else {
                txFee = txFee - emulatedGas; // 0.3 - 0.25(approximately gas refund for tx)
                // forwardGas = this.gasUsage.BURN_GAS_SLIPPAGE; // 0.05
              }
              // message = this.createBurnMessage(
              //   poolAddress,
              //   tokenId,
              //   tickLower,
              //   tickUpper,
              //   liquidityToBurn,
              //   txFee,
              //   forwardGas
              // );
            }
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](7);
            console.log('error emulation - ', _context2.t0);
          case 17:
            emulatedMessage = {
              message: message,
              txFee: txFee,
              forwardGas: forwardGas,
              gasLimit: message.value
            };
            return _context2.abrupt("return", emulatedMessage);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[7, 14]]);
    }));
    function createEmulatedBurnMessage(_x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19, _x20, _x21, _x22, _x23) {
      return _createEmulatedBurnMessage.apply(this, arguments);
    }
    return createEmulatedBurnMessage;
  }();
  PoolMessageManager.createCollectMessage = function createCollectMessage(poolAddress, tokenId, tickLower, tickUpper, txFee, forwardGas // gas slippage
  ) {
    if (txFee === void 0) {
      txFee = this.gasUsage.BURN_GAS;
    }
    if (forwardGas === void 0) {
      forwardGas = BigInt(0);
    }
    var message = this.createBurnMessage(poolAddress, tokenId, tickLower, tickUpper, BigInt(0), txFee, forwardGas);
    return message;
  };
  PoolMessageManager.createEmulatedCollectMessage = /*#__PURE__*/function () {
    var _createEmulatedCollectMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(poolAddress, tokenId, tickLower, tickUpper, feeAmount0, feeAmount1, client,
    // ton api client
    wallet, wallet_public_key, walletVersion) {
      var txFee, forwardGas, message, isJetton0TON, isJetton1TON, collectType, emulation, _emulation$event$acti3, emulatedGas, tonRevertedFromPool, calculateTxWithTonFee, emulatedMessage;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            txFee = this.gasUsage.BURN_GAS; // 0.3
            forwardGas = BigInt(0);
            message = this.createCollectMessage(poolAddress, tokenId, tickLower, tickUpper);
            isJetton0TON = feeAmount0 && Address$1.parse(feeAmount0.jetton.address).equals(Address$1.parse(pTON_MINTER));
            isJetton1TON = feeAmount1 && Address$1.parse(feeAmount1.jetton.address).equals(Address$1.parse(pTON_MINTER));
            collectType = isJetton0TON && feeAmount0.greaterThan('0') && feeAmount1 != null && feeAmount1.equalTo('0') || isJetton1TON && feeAmount1.greaterThan('0') && feeAmount0 != null && feeAmount0.equalTo('0') ? CollectType.TON : isJetton0TON && feeAmount0.greaterThan('0') && feeAmount1 != null && feeAmount1.greaterThan('0') || isJetton1TON && feeAmount1.greaterThan('0') && feeAmount0 != null && feeAmount0.greaterThan('0') ? CollectType.TON_JETTON : CollectType.JETTON;
            if (!(wallet && client && wallet_public_key && walletVersion)) {
              _context3.next = 32;
              break;
            }
            _context3.prev = 7;
            _context3.next = 10;
            return emulateMessage(client, [message], wallet, wallet_public_key, walletVersion);
          case 10:
            emulation = _context3.sent;
            if (!emulation) {
              _context3.next = 27;
              break;
            }
            emulatedGas = BigInt(Math.abs(emulation.event.extra));
            tonRevertedFromPool = BigInt(((_emulation$event$acti3 = emulation.event.actions.find(function (event) {
              return event.TonTransfer;
            })) == null || (_emulation$event$acti3 = _emulation$event$acti3.TonTransfer) == null ? void 0 : _emulation$event$acti3.amount) || 0); // forwardGas = this.gasUsage.BURN_GAS_SLIPPAGE * BigInt(2); // 0.1
            calculateTxWithTonFee = function calculateTxWithTonFee(amount, mult) {
              return BigInt(amount.quotient.toString()) + (txFee - tonRevertedFromPool - emulatedGas * BigInt(mult));
            };
            _context3.t0 = collectType;
            _context3.next = _context3.t0 === CollectType.TON ? 18 : _context3.t0 === CollectType.TON_JETTON ? 21 : _context3.t0 === CollectType.JETTON ? 24 : 26;
            break;
          case 18:
            // ..only TON
            if (feeAmount0 != null && feeAmount0.greaterThan('0')) txFee = calculateTxWithTonFee(feeAmount0, -1);
            if (feeAmount1 != null && feeAmount1.greaterThan('0')) txFee = calculateTxWithTonFee(feeAmount1, -1);
            return _context3.abrupt("break", 27);
          case 21:
            // ..some TON + ..some Jetton
            if (isJetton0TON && feeAmount0 != null && feeAmount0.greaterThan('0')) txFee = calculateTxWithTonFee(feeAmount0, 1);
            if (isJetton1TON && feeAmount1 != null && feeAmount1.greaterThan('0')) txFee = calculateTxWithTonFee(feeAmount1, 1);
            return _context3.abrupt("break", 27);
          case 24:
            // only Jetton or Jetton + Jetton
            txFee = txFee - emulatedGas;
            // forwardGas = this.gasUsage.BURN_GAS_SLIPPAGE; // 0.05
            return _context3.abrupt("break", 27);
          case 26:
            return _context3.abrupt("break", 27);
          case 27:
            _context3.next = 32;
            break;
          case 29:
            _context3.prev = 29;
            _context3.t1 = _context3["catch"](7);
            console.log('error emulation - ', _context3.t1);
          case 32:
            emulatedMessage = {
              message: message,
              txFee: txFee,
              forwardGas: forwardGas,
              gasLimit: message.value
            };
            return _context3.abrupt("return", emulatedMessage);
          case 34:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[7, 29]]);
    }));
    function createEmulatedCollectMessage(_x24, _x25, _x26, _x27, _x28, _x29, _x30, _x31, _x32, _x33) {
      return _createEmulatedCollectMessage.apply(this, arguments);
    }
    return createEmulatedCollectMessage;
  }();
  PoolMessageManager.createSwapExactInMessage = function createSwapExactInMessage(userJettonWallet,
  // input jetton wallet attached to user
  routerJettonWallet,
  // output jetton wallet attached to router
  recipient, amountIn, minimumAmountOut, priceLimitSqrt, swapType, txFee,
  // 0.4
  forwardGas // 4 maximum messages in tx = 0.2
  ) {
    if (txFee === void 0) {
      txFee = this.gasUsage.SWAP_GAS;
    }
    if (forwardGas === void 0) {
      forwardGas = this.gasUsage.TRANSFER_GAS * BigInt(4);
    }
    var swapRequest;
    swapRequest = beginCell$1().storeUint(ContractOpcodes.POOLV3_SWAP, 32) // Request to swap
    .storeAddress(routerJettonWallet) // JettonWallet attached to Router is used to identify target token
    .storeUint(priceLimitSqrt, 160) // Minimum/maximum price that we are ready to reach
    .storeCoins(minimumAmountOut) // Minimum amount to get back
    .storeAddress(recipient) // Address to receive result of the swap
    .storeUint(0, 1) // Payload Maybe Ref // Address to recieve result of the swap
    .endCell();
    switch (swapType) {
      case SwapType.TON_TO_JETTON:
        swapRequest = beginMessage(proxyWalletOpcodesV2.tonTransfer).storeCoins(amountIn) // ton amount
        .storeAddress(recipient) // refund address
        .storeUint(1, 1).storeRef(swapRequest).endCell();
        return {
          to: Address$1.parse(pTON_ROUTER_WALLET),
          value: amountIn + txFee + forwardGas,
          body: swapRequest
        };
      default:
        var payload = JettonWallet.transferMessage(amountIn, Address$1.parse(ROUTER), recipient, null, txFee + this.gasUsage.SWAP_GAS_SLIPPAGE, swapRequest);
        return {
          to: userJettonWallet,
          value: txFee + forwardGas,
          body: payload,
          sendMode: SendMode$1.PAY_GAS_SEPARATELY
        };
    }
  };
  PoolMessageManager.createEmulatedSwapExactInMessage = /*#__PURE__*/function () {
    var _createEmulatedSwapExactInMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(userJettonWallet, routerJettonWallet, recipient, amountIn, minimumAmountOut, priceLimitSqrt, swapType, client,
    // ton api client
    wallet_public_key, walletVersion) {
      var txFee, forwardGas, message, emulation, _emulation$event$acti4, _tonRevertedFromPool, _emulatedGas, tonAmountOut, emulatedMessage;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            txFee = this.gasUsage.SWAP_GAS; // 0.4
            forwardGas = this.gasUsage.TRANSFER_GAS * BigInt(4); // 0.2
            message = this.createSwapExactInMessage(userJettonWallet, routerJettonWallet, recipient, amountIn, minimumAmountOut, priceLimitSqrt, swapType);
            /* emulate message */
            if (!(client && wallet_public_key && walletVersion)) {
              _context4.next = 27;
              break;
            }
            _context4.prev = 4;
            _context4.next = 7;
            return emulateMessage(client, [message], recipient.toString(), wallet_public_key, walletVersion);
          case 7:
            emulation = _context4.sent;
            if (!emulation) {
              _context4.next = 22;
              break;
            }
            /* tx gas */
            _tonRevertedFromPool = BigInt(((_emulation$event$acti4 = emulation.event.actions.find(function (event) {
              return event.TonTransfer;
            })) == null || (_emulation$event$acti4 = _emulation$event$acti4.TonTransfer) == null ? void 0 : _emulation$event$acti4.amount) || 0);
            _emulatedGas = BigInt(Math.abs(emulation.event.extra)); // forwardGas =
            //   BigInt(
            //     emulation.event.actions.filter(
            //       action =>
            //         action.type === 'JettonTransfer' ||
            //         action.type === 'TonTransfer'
            //     ).length + 1 // +1 for initial jetton transfer
            //   ) * this.gasUsage.TRANSFER_GAS;
            _context4.t0 = swapType;
            _context4.next = _context4.t0 === SwapType.TON_TO_JETTON ? 14 : _context4.t0 === SwapType.JETTON_TO_TON ? 16 : _context4.t0 === SwapType.JETTON_TO_JETTON ? 19 : 21;
            break;
          case 14:
            txFee = _emulatedGas; // forward gas in the base created message
            // message = this.createSwapExactInMessage(
            //   userJettonWallet,
            //   routerJettonWallet,
            //   recipient,
            //   amountIn,
            //   minimumAmountOut,
            //   priceLimitSqrt,
            //   swapType,
            //   txFee,
            //   txFee + forwardGas
            // );
            /* TODO: calc correct txFee */
            // if (tonRevertedFromPool) {
            //   txFee = amountIn - tonRevertedFromPool - emulatedGas;
            //   message = this.createSwapExactInMessage(
            //     userJettonWallet,
            //     routerJettonWallet,
            //     recipient,
            //     amountIn,
            //     minimumAmountOut,
            //     priceLimitSqrt,
            //     swapType,
            //     txFee,
            //     txFee + forwardGas
            //   );
            // }
            return _context4.abrupt("break", 21);
          case 16:
            tonAmountOut = emulation.trace.children ? getTonRefundAmount(emulation.trace.children) : BigInt(0);
            txFee = tonAmountOut ? _emulatedGas - (_tonRevertedFromPool - tonAmountOut) : _emulatedGas;
            // message = this.createSwapExactInMessage(
            //   userJettonWallet,
            //   routerJettonWallet,
            //   recipient,
            //   amountIn,
            //   minimumAmountOut,
            //   priceLimitSqrt,
            //   swapType,
            //   txFee,
            //   forwardGas
            // );
            return _context4.abrupt("break", 21);
          case 19:
            txFee = BigInt(Math.abs(emulation.event.extra));
            // message = this.createSwapExactInMessage(
            //   userJettonWallet,
            //   routerJettonWallet,
            //   recipient,
            //   amountIn,
            //   minimumAmountOut,
            //   priceLimitSqrt,
            //   swapType,
            //   txFee,
            //   forwardGas
            // );
            return _context4.abrupt("break", 21);
          case 21:
            console.log('success emulation - ', emulation);
          case 22:
            _context4.next = 27;
            break;
          case 24:
            _context4.prev = 24;
            _context4.t1 = _context4["catch"](4);
            console.log('error emulation - ', _context4.t1);
          case 27:
            // const emulatedMessage = {
            //   message,
            //   txFee: txFee,
            //   forwardGas,
            //   gasLimit: txFee + forwardGas,
            // };
            emulatedMessage = {
              message: message,
              txFee: txFee,
              forwardGas: forwardGas,
              gasLimit: swapType === SwapType.TON_TO_JETTON ? message.value - amountIn : message.value
            };
            return _context4.abrupt("return", emulatedMessage);
          case 29:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this, [[4, 24]]);
    }));
    function createEmulatedSwapExactInMessage(_x34, _x35, _x36, _x37, _x38, _x39, _x40, _x41, _x42, _x43) {
      return _createEmulatedSwapExactInMessage.apply(this, arguments);
    }
    return createEmulatedSwapExactInMessage;
  }();
  return PoolMessageManager;
}();
PoolMessageManager.gasUsage = {
  TRANSFER_GAS: /*#__PURE__*/toNano$1(0.05),
  MINT_GAS: /*#__PURE__*/toNano$1(0.4),
  SWAP_GAS: /*#__PURE__*/toNano$1(0.4),
  SWAP_GAS_SLIPPAGE: /*#__PURE__*/toNano$1(0.1),
  BURN_GAS: /*#__PURE__*/toNano$1(0.3),
  BURN_GAS_SLIPPAGE: /*#__PURE__*/toNano$1(0.1),
  DEPLOY_POOL_GAS: /*#__PURE__*/toNano$1(0.2)
};

export { ACCOUNTV3_CODE, ADDRESS_ZERO, AccountV3Contract, BLACK_HOLE_ADDRESS, Bound, ContractErrors, ContractOpcodes, DEFAULT_TICK_SPACING, Errors, ErrorsLookup, FEE_DENOMINATOR, Field, Fraction, FullMath, IMPOSSIBLE_FEE, INITIAL_POOL_FEE, Jetton, JettonAmount, JettonMinter, JettonWallet, LiquidityMath, MaxUint256, NEGATIVE_ONE, NoTickDataProvider, ONE, Op, OpcodesLookup, POOLV3_CODE, POOL_FACTORY, POSITIONV3_CODE, Percent, Pool, PoolFactoryContract, PoolMessageManager, PoolV3Contract, Position, PositionLibrary, PositionNFTV3Contract, Price, Q192, Q96, ROUTER, ROUTERV3_CODE, Rounding, Route, RouterV3Contract, SqrtPriceMath, SwapType, TIMELOCK_DELAY_DEFAULT, Tick, TickInfoWrapper, TickLibrary, TickList, TickListDataProvider, TickMath, Trade, TradeType, WalletContract, WalletVersion, ZERO, accountv3ContractConfigToCell, calculatePoolStateInit, computePoolAddress, currencyEquals, defaultJettonKeys, defaultNftKeys, displayContentCell, embedJettonData, emulateMessage, encodeSqrtRatioX96, getEmojiHash, getSwapEstimate, getTickToPrice, isSorted, jWalletOpcodes, jettonContentToCell, jettonMinterConfigToCell, jettonWalletConfigToCell, maxAmountSpend, maxLiquidityForAmounts, mostSignificantBit, nearestUsableTick, nftContentPackedDefault, nftContentToPack, nftItemContentPackedDefault, nftItemContentToPack, pTON_MINTER, pTON_ROUTER_WALLET, packJettonOnchainMetadata, packOffchainMetadata, packPoolData, parseBalance, parseWalletVersion, poolFactoryContractConfigToCell, poolv3ContractConfigToCell, poolv3StateInitConfig, positionNFTv3ContractConfigToCell, priceToClosestTick, proxyWalletOpcodesV2, routerv3ContractCellToConfig, routerv3ContractConfigToCell, subIn256, tickToPrice, tradeComparator, tryParseAmount, tryParsePrice, tryParseTick, unpackJettonOnchainMetadata, validateAndParseAddress, walletConfigToCell };
//# sourceMappingURL=sdk.esm.js.map
