import { Address, Cell, Contract, ContractProvider, Sender } from '@ton/core';
export interface PoolStateAndConfiguration {
    router_address: Address;
    admin_address: Address;
    controller_address: Address;
    jetton0_wallet: Address;
    jetton1_wallet: Address;
    jetton0_minter: Address;
    jetton1_minter: Address;
    pool_active: boolean;
    tick_spacing: number;
    lp_fee_base: number;
    protocol_fee: number;
    lp_fee_current: number;
    tick: number;
    price_sqrt: bigint;
    liquidity: bigint;
    feeGrowthGlobal0X128: bigint;
    feeGrowthGlobal1X128: bigint;
    collectedProtocolFee0: bigint;
    collectedProtocolFee1: bigint;
    nftv3item_counter: bigint;
    reserve0: bigint;
    reserve1: bigint;
    nftv3items_active?: bigint;
    ticks_occupied?: number;
    seqno?: bigint;
}
/** Inital data structures and settings **/
export declare type PoolV3ContractConfig = {
    router_address: Address;
    admin_address?: Address;
    lp_fee_base?: number;
    protocol_fee?: number;
    jetton0_wallet: Address;
    jetton1_wallet: Address;
    tick_spacing?: number;
    pool_active?: boolean;
    tick?: number;
    price_sqrt?: bigint;
    liquidity?: bigint;
    lp_fee_current?: number;
    accountv3_code: Cell;
    position_nftv3_code: Cell;
    nftContent?: Cell;
    nftItemContent?: Cell;
};
export declare class TickInfoWrapper {
    liquidityGross: bigint;
    liquidityNet: bigint;
    outerFeeGrowth0Token: bigint;
    outerFeeGrowth1Token: bigint;
    constructor(liquidityGross?: bigint, liquidityNet?: bigint, outerFeeGrowth0Token?: bigint, outerFeeGrowth1Token?: bigint);
}
export declare function embedJettonData(content: Cell, jetton0Name: string, decimals0: number, jetton1Name: string, decimals1: number): Cell;
export declare let nftContentToPack: {
    [s: string]: string | undefined;
};
export declare const nftContentPackedDefault: Cell;
export declare let nftItemContentToPack: {
    [s: string]: string | undefined;
};
export declare const nftItemContentPackedDefault: Cell;
export declare function poolv3StateInitConfig(jetton0Wallet: Address, jetton1Wallet: Address, accountV3Code: Cell, positionNftV3Code: Cell, routerAddress: Address): PoolV3ContractConfig;
export declare function poolv3ContractConfigToCell(config: PoolV3ContractConfig): Cell;
declare type NumberedTickInfo = {
    tickNum: number;
    liquidityGross: bigint;
    liquidityNet: bigint;
    outerFeeGrowth0Token?: bigint;
    outerFeeGrowth1Token?: bigint;
};
/** Pool  **/
export declare class PoolV3Contract implements Contract {
    readonly address: Address;
    readonly init?: {
        code: Cell;
        data: Cell;
    } | undefined;
    constructor(address: Address, init?: {
        code: Cell;
        data: Cell;
    } | undefined);
    static orderJettonId(jetton0Wallet: Address, jetton1Wallet: Address): boolean;
    static createFromConfig(config: PoolV3ContractConfig, code: Cell, workchain?: number): PoolV3Contract;
    sendDeploy(provider: ContractProvider, via: Sender, value: bigint, tickSpacing: number, sqrtPriceX96: bigint, opts: {
        is_from_admin?: boolean;
        activate_pool?: boolean;
        jetton0Minter?: Address;
        jetton1Minter?: Address;
        admin?: Address;
        controller?: Address;
        nftContentPacked?: Cell;
        nftItemContentPacked?: Cell;
        protocolFee?: number;
        lpFee?: number;
        currentFee?: number;
    }): Promise<void>;
    static reinitMessage(opts: {
        is_from_admin?: boolean;
        activate_pool?: boolean;
        tickSpacing?: number;
        sqrtPriceX96?: bigint;
        jetton0Minter?: Address;
        jetton1Minter?: Address;
        admin?: Address;
        controller?: Address;
        nftContentPacked?: Cell;
        nftItemContentPacked?: Cell;
        protocolFee?: number;
        lpFee?: number;
        currentFee?: number;
    }): Cell;
    static unpackReinitMessage(body: Cell): {
        is_from_admin?: boolean;
        activate_pool?: boolean;
        tickSpacing?: number;
        sqrtPriceX96?: bigint;
        jetton0Minter?: Address;
        jetton1Minter?: Address;
        admin?: Address;
        controller?: Address;
        nftContentPacked?: Cell;
        nftItemContentPacked?: Cell;
        protocolFee?: number;
        lpFee?: number;
        currentFee?: number;
    };
    sendReinit(provider: ContractProvider, via: Sender, value: bigint, opts: {
        is_from_admin?: boolean;
        activate_pool?: boolean;
        tickSpacing?: number;
        sqrtPriceX96?: bigint;
        jetton0Minter?: Address;
        jetton1Minter?: Address;
        admin?: Address;
        controller?: Address;
        nftContentPacked?: Cell;
        nftItemContentPacked?: Cell;
        protocolFee?: number;
        lpFee?: number;
        currentFee?: number;
    }): Promise<void>;
    static messageSetFees(protocolFee: number, lpFee: number, currentFee: number): Cell;
    static unpackSetFeesMessage(body: Cell): {
        protocolFee: number;
        lpFee: number;
        currentFee: number;
    };
    sendSetFees(provider: ContractProvider, sender: Sender, value: bigint, protocolFee: number, lpFee: number, currentFee: number): Promise<void>;
    sendLockPool(provider: ContractProvider, sender: Sender, value: bigint): Promise<void>;
    sendUnlockPool(provider: ContractProvider, sender: Sender, value: bigint): Promise<void>;
    static messageCollectProtocol(): Cell;
    static unpackCollectProtocolMessage(body: Cell): void;
    sendCollectProtocol(provider: ContractProvider, sender: Sender, value: bigint): Promise<void>;
    sendBurn(provider: ContractProvider, via: Sender, value: bigint, nftIndex: bigint, tickLower: number, tickUpper: number, liquidity2Burn: bigint): Promise<void>;
    /** Getters **/
    getIsActive(provider: ContractProvider): Promise<boolean>;
    getIsDebug(provider: ContractProvider): Promise<boolean>;
    getPoolStateAndConfiguration(provider: ContractProvider): Promise<PoolStateAndConfiguration>;
    /**
     *  Returns a tick by tickNumber. If tick not inited - tick filled with zero will be returned.
     *  Also pervious tick and next tick numbers are returned
     *
     *
     *  @param provider   blockchain access provider
     *  @param tickNumber Tick to extract data for
     *
     **/
    getTickInfo(provider: ContractProvider, tickNumber: number): Promise<TickInfoWrapper>;
    getTickInfosAll(provider: ContractProvider): Promise<NumberedTickInfo[]>;
    /**
     *  Returns a hash object of ticks infos with all internal data starting from key >=tickNumber  or key <= tickNumber
     *  and no more then number. Unfortunately there is an internal limit of 255 tickInfos
     *
     *
     *  @param provider   blockchain access provider
     *  @param tickNumber Starting tick. Ticks greater or equal will be returned with back == false, with back == true - less or equal keys will be enumerated
     *  @param amount     Number of tick infos to be returned
     *  @param back       directions of ticks
     *  @param full       should fee related fields be filled
     *
     *
     **/
    getTickInfosFromArr(provider: ContractProvider, tickNumber: number, amount: number, back?: boolean, full?: boolean): Promise<NumberedTickInfo[]>;
    getMintEstimate(provider: ContractProvider, tickLower: number, tickUpper: number, liquidity: bigint): Promise<{
        amount0: bigint;
        amount1: bigint;
        mintErrors: number;
    }>;
    getSwapEstimate(provider: ContractProvider, zeroForOne: boolean, amount: bigint, sqrtPriceLimitX96: bigint, minOutAmount?: bigint, gasLimit?: bigint): Promise<{
        amount0: bigint;
        amount1: bigint;
    }>;
    getCollectedFees(provider: ContractProvider, tickLower: number, tickUpper: number, posLiquidityDelta: bigint, posFeeGrowthInside0X128: bigint, posFeeGrowthInside1X128: bigint): Promise<{
        amount0: bigint;
        amount1: bigint;
    }>;
    getFeeGrowthInside(provider: ContractProvider, tickLower: number, tickUpper: number, tickCurrent: number, feeGrowthGlobal0X128: bigint, feeGrowthGlobal1X128: bigint): Promise<{
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
    }>;
    getUserAccountAddress(provider: ContractProvider, owner: Address): Promise<Address>;
    getNFTAddressByIndex(provider: ContractProvider, index: bigint): Promise<Address>;
    getNFTCollectionContent(provider: ContractProvider): Promise<{
        nftv3item_counter: bigint;
        nftv3_content: Cell;
        router_address: Address;
    }>;
    getNFTContent(provider: ContractProvider, index: bigint, nftItemContent: Cell): Promise<Cell>;
    getChildContracts(provider: ContractProvider): Promise<{
        accountCode: Cell;
        positionNFTCode: Cell;
        nftCollectionContent: Cell;
        nftItemContent: Cell;
    }>;
}
export {};
