"use strict";
/**
 * Contract instance wrapper for easy interaction
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractInstance = void 0;
const ContractInteractor_1 = require("./ContractInteractor");
class ContractInstance {
    constructor(demos, address, abi) {
        this.demos = demos;
        this.address = address;
        this.abi = abi;
        this.methods = {};
        this.interactor = new ContractInteractor_1.ContractInteractor(demos);
        // Set up method proxies if ABI is provided
        if (abi && abi.functions) {
            this.setupMethodProxies();
        }
        // Set up general proxy for dynamic method calls
        return new Proxy(this, {
            get: (target, prop) => {
                // Return existing properties
                if (prop in target) {
                    return target[prop];
                }
                // Create dynamic method caller
                if (typeof prop === 'string' && !prop.startsWith('_')) {
                    return (...args) => this.call(prop, args);
                }
                return undefined;
            }
        });
    }
    /**
     * Call a contract method
     */
    async call(method, args = [], options) {
        return await this.interactor.call(this.address, method, args, options);
    }
    /**
     * Send DEM with a contract call
     */
    async callWithValue(method, args, value, options) {
        return await this.call(method, args, {
            ...options,
            value
        });
    }
    /**
     * Get contract state (if accessible)
     */
    async getState(key) {
        if (key) {
            return await this.call('getState', [key]);
        }
        return await this.call('getState', []);
    }
    /**
     * Get contract metadata
     */
    async getMetadata() {
        const result = await this.demos.rpcCall({
            method: 'getContractMetadata',
            params: [this.address]
        });
        return result.result === 200 ? result.response : null;
    }
    /**
     * Get contract events
     */
    async getEvents(params) {
        const result = await this.demos.rpcCall({
            method: 'getContractEvents',
            params: [{
                    contractAddress: this.address,
                    ...params
                }]
        });
        return result.result === 200 ? result.response.events : [];
    }
    /**
     * Setup method proxies based on ABI
     */
    setupMethodProxies() {
        if (!this.abi || !this.abi.functions)
            return;
        for (const func of this.abi.functions) {
            if (func.visibility === 'public') {
                this.methods[func.name] = async (...args) => {
                    // Validate argument count
                    const requiredParams = func.parameters.filter(p => !p.optional).length;
                    if (args.length < requiredParams) {
                        throw new Error(`Method ${func.name} expects at least ${requiredParams} arguments, got ${args.length}`);
                    }
                    // Determine if this is a view call
                    const isView = func.mutability === 'view' || func.mutability === 'pure';
                    const options = {};
                    if (func.mutability === 'payable' && args.length > func.parameters.length) {
                        // Last argument might be value
                        options.value = args.pop();
                    }
                    const result = await this.call(func.name, args, options);
                    if (result.success) {
                        return result.result;
                    }
                    else {
                        throw new Error(result.error || `Call to ${func.name} failed`);
                    }
                };
            }
        }
    }
    /**
     * Create a typed instance from ABI
     */
    static fromABI(demos, address, abi) {
        return new ContractInstance(demos, address, abi);
    }
    /**
     * Wait for contract to be deployed at address
     */
    static async waitForDeployment(demos, address, timeout = 30000) {
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
            const result = await demos.rpcCall({
                method: 'getContract',
                params: [address]
            });
            if (result.result === 200 && result.response) {
                return true;
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        return false;
    }
}
exports.ContractInstance = ContractInstance;
//# sourceMappingURL=ContractInstance.js.map