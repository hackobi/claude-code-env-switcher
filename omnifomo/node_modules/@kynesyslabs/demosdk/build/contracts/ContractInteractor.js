"use strict";
/**
 * Contract interaction functionality for Demos SDK
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractInteractor = void 0;
const unifiedCrypto_1 = require("../encryption/unifiedCrypto");
const skeletons = __importStar(require("../websdk/utils/skeletons"));
class ContractInteractor {
    constructor(demos) {
        this.demos = demos;
    }
    /**
     * Call a smart contract method
     * @param contractAddress The contract address
     * @param method The method name to call
     * @param args Arguments for the method
     * @param options Call options
     * @returns Call result
     */
    async call(contractAddress, method, args = [], options = {}) {
        try {
            // For view/pure calls, use call RPC (no transaction needed)
            if (this.isViewCall(method, options)) {
                return await this.viewCall(contractAddress, method, args);
            }
            // For state-changing calls, send a transaction
            return await this.transactionCall(contractAddress, method, args, options);
        }
        catch (error) {
            return {
                success: false,
                error: error.message || 'Contract call failed'
            };
        }
    }
    /**
     * Batch multiple contract calls
     */
    async batchCall(calls) {
        const results = [];
        for (const call of calls) {
            const result = await this.call(call.contractAddress, call.method, call.args, call.options);
            results.push(result);
        }
        return results;
    }
    /**
     * Read-only contract call (no transaction)
     */
    async viewCall(contractAddress, method, args) {
        const result = await this.sendRPC({
            method: 'contractCall',
            params: [{
                    contractAddress,
                    method,
                    args,
                    readOnly: true
                }]
        });
        if (result.result !== 200) {
            return {
                success: false,
                error: result.response?.error || 'View call failed'
            };
        }
        return {
            success: true,
            result: result.response.returnValue,
            gasUsed: result.response.gasUsed
        };
    }
    /**
     * State-changing contract call (sends transaction)
     */
    async transactionCall(contractAddress, method, args, options) {
        // Validate wallet connection
        if (!this.demos.walletConnected) {
            throw new Error('Wallet not connected. Please connect a wallet first.');
        }
        // Build the call transaction
        const tx = await this.buildCallTransaction(contractAddress, method, args, options);
        // Send the transaction
        const result = await this.sendRPC({
            method: 'sendTransaction',
            params: [tx]
        });
        if (result.result !== 200) {
            return {
                success: false,
                error: result.response?.error || 'Transaction failed'
            };
        }
        // Wait for confirmation if requested
        if (options.waitForConfirmation !== false) {
            const confirmation = await this.waitForTransaction(result.response.transactionHash, options.confirmations || 1);
            if (!confirmation.success) {
                return {
                    success: false,
                    error: confirmation.error
                };
            }
            return {
                success: true,
                result: confirmation.returnValue,
                gasUsed: confirmation.gasUsed,
                events: confirmation.events,
                transactionHash: result.response.transactionHash,
                blockHeight: confirmation.blockHeight
            };
        }
        return {
            success: true,
            transactionHash: result.response.transactionHash
        };
    }
    /**
     * Build contract call transaction
     */
    async buildCallTransaction(contractAddress, method, args, options) {
        const { publicKey } = await this.demos.crypto.getIdentity('ed25519');
        const publicKeyHex = (0, unifiedCrypto_1.uint8ArrayToHex)(publicKey);
        const nonce = options.nonce ?? await this.demos.getAddressNonce(publicKeyHex);
        const payload = {
            contractAddress,
            method,
            args
        };
        const tx = structuredClone(skeletons.transaction);
        tx.content.type = 'contractCall';
        tx.content.data = ['contractCall', payload];
        tx.content.nonce = nonce;
        tx.content.from = publicKeyHex;
        tx.content.timestamp = Date.now();
        tx.content.amount = Number(options.value || 0);
        // Sign the transaction
        return await this.signTransaction(tx);
    }
    /**
     * Check if a call is view/pure (read-only)
     */
    isViewCall(method, options) {
        // Check if explicitly marked as view
        if (options.value && options.value > 0) {
            return false; // Calls with value are never view
        }
        // Common view method patterns
        const viewPatterns = [
            /^get/i,
            /^is/i,
            /^has/i,
            /^check/i,
            /^view/i,
            /^read/i,
            /balance/i,
            /supply/i,
            /owner/i,
            /allowance/i
        ];
        return viewPatterns.some(pattern => pattern.test(method));
    }
    /**
     * Wait for transaction confirmation
     */
    async waitForTransaction(txHash, confirmations) {
        const maxAttempts = 30; // 30 seconds timeout
        let attempts = 0;
        while (attempts < maxAttempts) {
            const result = await this.sendRPC({
                method: 'getTransactionReceipt',
                params: [txHash]
            });
            if (result.result === 200 && result.response) {
                const receipt = result.response;
                if (receipt.confirmations >= confirmations) {
                    return {
                        success: true,
                        returnValue: receipt.returnValue,
                        gasUsed: receipt.gasUsed,
                        events: receipt.events,
                        blockHeight: receipt.blockHeight
                    };
                }
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }
        return {
            success: false,
            error: 'Transaction confirmation timeout'
        };
    }
    /**
     * Helper to send RPC requests
     */
    async sendRPC(request) {
        // This will be implemented through the main Demos class
        return await this.demos.rpcCall(request);
    }
    /**
     * Helper to sign transactions
     */
    async signTransaction(tx) {
        // This will be implemented through the main Demos class
        return await this.demos.sign(tx);
    }
}
exports.ContractInteractor = ContractInteractor;
//# sourceMappingURL=ContractInteractor.js.map