"use strict";
/**
 * Factory for creating contract instances
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchBuilder = exports.ContractFactory = void 0;
const ContractDeployer_1 = require("./ContractDeployer");
const ContractInteractor_1 = require("./ContractInteractor");
const ContractInstance_1 = require("./ContractInstance");
class ContractFactory {
    constructor(demos) {
        this.demos = demos;
        this.deployer = new ContractDeployer_1.ContractDeployer(demos);
        this.interactor = new ContractInteractor_1.ContractInteractor(demos);
    }
    /**
     * Deploy a new contract
     */
    async deploy(source, constructorArgs = [], options = {}) {
        return await this.deployer.deployAndWrap(source, constructorArgs, options);
    }
    /**
     * Get an instance of an existing contract
     */
    async at(address, abi) {
        return new ContractInstance_1.ContractInstance(this.demos, address, abi);
    }
    /**
     * Create a batch operation builder
     */
    batch() {
        return new BatchBuilder(this.demos, this.deployer, this.interactor);
    }
    /**
     * Estimate gas for a contract call
     */
    async estimateGas(contractAddress, method, args = []) {
        const result = await this.demos.rpcCall({
            method: 'estimateGas',
            params: [{
                    contractAddress,
                    method,
                    args
                }]
        });
        if (result.result === 200) {
            return BigInt(result.response.gasEstimate || 0);
        }
        throw new Error('Failed to estimate gas');
    }
}
exports.ContractFactory = ContractFactory;
/**
 * Batch operation builder
 */
class BatchBuilder {
    constructor(demos, deployer, interactor) {
        this.demos = demos;
        this.deployer = deployer;
        this.interactor = interactor;
        this.operations = [];
    }
    /**
     * Add a deployment to the batch
     */
    deploy(source, constructorArgs = [], options = {}) {
        this.operations.push(async () => await this.deployer.deploy(source, constructorArgs, options));
        return this;
    }
    /**
     * Add a contract call to the batch
     */
    call(contractAddress, method, args = []) {
        this.operations.push(async () => await this.interactor.call(contractAddress, method, args));
        return this;
    }
    /**
     * Execute all operations in the batch
     */
    async execute() {
        const results = [];
        for (const operation of this.operations) {
            try {
                const result = await operation();
                results.push(result);
            }
            catch (error) {
                results.push({
                    success: false,
                    error: error.message
                });
            }
        }
        return results;
    }
}
exports.BatchBuilder = BatchBuilder;
//# sourceMappingURL=ContractFactory.js.map