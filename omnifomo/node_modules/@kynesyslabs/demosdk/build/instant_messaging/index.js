"use strict";
// FIXME Integrate with l2ps.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagingPeer = void 0;
/**
 * MessagingPeer class for peer-to-peer communication through a signaling server
 *
 * This class handles:
 * - Connection to signaling server
 * - Peer registration with public key
 * - Peer discovery
 * - Message exchange with other peers
 * - Public key requests
 * - Automatic reconnection with exponential backoff
 *
 * Message Handling:
 * - Messages are automatically encrypted when sent and decrypted when received
 * - To handle incoming messages with type "message", register a handler using onMessage:
 *   ```typescript
 *   peer.onMessage((message, fromId) => {
 *     // Handle the decrypted message here
 *     console.log(`Message from ${fromId}:`, message);
 *   });
 *   ```
 * - You can register multiple handlers for different purposes (each handler will receive the decrypted message and sender's ID)
 * - Handlers are executed in the order they are registered
 * - If no handlers are registered, messages will be silently ignored
 * - For request-response patterns (like getting a peer's public key), use the Promise-based methods
 *   that handle the response matching automatically
 *
 * Request-Response Pattern:
 * - The class provides a robust request-response pattern through the sendToServerAndWait method
 * - This method sends a message to the server and waits for a specific response type
 * - It supports custom error handling, retry logic, and filtering by additional criteria
 * - Example usage:
 *   ```typescript
 *   // Basic usage
 *   const response = await peer.sendToServerAndWait(
 *     {
 *       type: "custom_action",
 *       payload: { someData: "value" }
 *     },
 *     "custom_action_success"
 *   );
 *
 *   // With retry logic
 *   const response = await peer.sendToServerAndWait(
 *     {
 *       type: "custom_action",
 *       payload: { someData: "value" }
 *     },
 *     "custom_action_success",
 *     {
 *       retryCount: 3,
 *       timeout: 5000
 *     }
 *   );
 *   ```
 *
 * Message Types:
 * - "message": Encrypted peer-to-peer messages
 *   ```typescript
 *   // Example of a received message payload
 *   {
 *     type: "message",
 *     payload: {
 *       message: {
 *         algorithm: "ml-kem-aes",
 *         encryptedData: Uint8Array,
 *         cipherText: Uint8Array
 *       },
 *       fromId: "sender-peer-id"
 *     }
 *   }
 *
 *   // After decryption, handlers receive:
 *   // message = "Hello, this is the decrypted message"
 *   // fromId = "sender-peer-id"
 *   ```
 *
 * Complete Example: Building a barebone messenger app and handling incoming messages
 * ```typescript
 * // In your application file (e.g., myMessenger.ts)
 * import { MessagingPeer } from './path/to/instant_messaging';
 *
 * // Create a peer instance
 * const peer = new MessagingPeer({
 *   serverUrl: 'ws://your-signaling-server:3000',
 *   clientId: 'your-unique-id',
 *   publicKey: yourPublicKey // Your ml-kem public key
 * });
 *
 * // Connect to the server
 * await peer.connect();
 *
 * // Register a handler for incoming messages
 * peer.onMessage((message, fromId) => {
 *   // Print the message to the console
 *   console.log(`Message from ${fromId}:`, message);
 *
 *   // If you're building a UI, you might update the DOM:
 *   const messageElement = document.createElement('div');
 *   messageElement.textContent = `${fromId}: ${message}`;
 *   document.getElementById('messages-container').appendChild(messageElement);
 * });
 *
 * // Discover other peers
 * const peers = await peer.discoverPeers();
 * console.log('Available peers:', peers);
 *
 * // Send a message to a specific peer
 * await peer.sendMessage('target-peer-id', 'Hello from me!');
 * ```
 *
 * Usage:
 * ```typescript
 * const peer = new MessagingPeer({
 *   serverUrl: 'ws://localhost:3000',
 *   clientId: 'unique-id',
 *   publicKey: a ml-kem public key
 * });
 *
 * // Connect and register
 * await peer.connect();
 *
 * // Discover other peers
 * const peers = await peer.discoverPeers();
 *
 * // Send a message
 * await peer.sendMessage('target-peer-id', 'Hello!');
 *
 * // Listen for messages
 * peer.onMessage((message, fromId) => {
 *   console.log(`Message from ${fromId}:`, message);
 * });
 * ```
 */
const unifiedCrypto_1 = require("../encryption/unifiedCrypto");
const uint8Serialize_1 = require("../utils/uint8Serialize");
class MessagingPeer {
    constructor(config) {
        this.ws = null;
        this.messageHandlers = new Set();
        this.errorHandlers = new Set();
        this.peerDisconnectedHandlers = new Set();
        this.connectionStateHandlers = new Set();
        this.connectedPeers = new Set();
        this.messageQueue = [];
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.baseReconnectDelay = 1000; // 1 second
        this.reconnectTimeout = null;
        this.isReconnecting = false;
        this.config = config;
    }
    /**
     * Connects to the signaling server and registers the peer
     * @returns Promise that resolves when connected and registered
     */
    async connect() {
        console.log("[IM @ " + this.config.clientId + "] Connecting to the server", this.config.serverUrl);
        return new Promise((resolve, reject) => {
            try {
                this.connectWebSocket();
                this.reconnectAttempts = 0;
                // Wait for the WebSocket to connect and register
                const checkConnection = setInterval(() => {
                    if (this.isConnected) {
                        clearInterval(checkConnection);
                        // Now wait for registration confirmation
                        this.registerAndWait()
                            .then(() => {
                            console.log("[IM @ " +
                                this.config.clientId +
                                "] Connection and registration complete");
                            resolve();
                        })
                            .catch(error => {
                            console.error("[IM @ " +
                                this.config.clientId +
                                "] Registration failed", error);
                            reject(error);
                        });
                    }
                }, 100);
                // Set a timeout for the connection
                setTimeout(() => {
                    clearInterval(checkConnection);
                    if (!this.isConnected) {
                        reject(new Error("Connection timeout"));
                    }
                }, 10000);
            }
            catch (error) {
                console.error("[IM @ " +
                    this.config.clientId +
                    "] Error connecting to the server", error);
                reject(error);
            }
        });
    }
    /**
     * Establishes WebSocket connection and sets up event handlers
     */
    connectWebSocket() {
        if (this.ws) {
            this.ws.close();
        }
        this.ws = new WebSocket(this.config.serverUrl);
        this.isReconnecting = true;
        this.notifyConnectionState("reconnecting");
        this.ws.onopen = () => {
            console.log("[IM @ " + this.config.clientId + "] Connected to the server");
            this.isConnected = true;
            this.isReconnecting = false;
            this.reconnectAttempts = 0;
            this.processMessageQueue();
            this.notifyConnectionState("connected");
        };
        this.ws.onclose = () => {
            console.log("[IM @ " +
                this.config.clientId +
                "] Disconnected from the server");
            this.isConnected = false;
            this.connectedPeers.clear();
            this.notifyConnectionState("disconnected");
            this.attemptReconnect();
        };
        this.ws.onerror = error => {
            console.error("[IM @ " + this.config.clientId + "] Error on the websocket", error);
            this.handleError({
                type: "CONNECTION_ERROR",
                details: error instanceof Error
                    ? error.message
                    : "WebSocket connection error",
            });
        };
        this.ws.onmessage = event => {
            this.handleMessage(JSON.parse(event.data));
        };
    }
    /**
     * Attempts to reconnect to the server with exponential backoff
     */
    attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts ||
            !this.isReconnecting) {
            return;
        }
        const delay = Math.min(this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts), 30000);
        this.reconnectTimeout = setTimeout(() => {
            this.reconnectAttempts++;
            this.connectWebSocket();
        }, delay);
    }
    /**
     * Awaits a response for a specific message type
     * @param messageType - The type of message to wait for
     * @param filterFn - Optional function to filter messages by additional criteria
     * @param timeout - Optional timeout in milliseconds (default: 10000)
     * @returns Promise that resolves with the message payload or rejects with an error
     */
    async awaitResponse(messageType, filterFn, timeout = 10000) {
        return new Promise((resolve, reject) => {
            // Set a timeout to reject the promise if no response is received
            const timeoutId = setTimeout(() => {
                reject(new Error(`Timeout waiting for response of type: ${messageType}`));
            }, timeout);
            const handler = (message, fromId) => {
                // Convert to Message object if needed
                const msg = message && typeof message === "object" && "type" in message
                    ? message
                    : { type: "message", payload: message };
                if (msg.type === messageType && (!filterFn || filterFn(msg))) {
                    clearTimeout(timeoutId);
                    resolve(msg.payload);
                }
                else if (msg.type === "error") {
                    console.error("[IM @ " +
                        this.config.clientId +
                        "] Received an error message: ", msg);
                    clearTimeout(timeoutId);
                    reject(new Error(msg.payload.details));
                }
            };
            this.addTemporaryMessageHandler(handler);
        });
    }
    /**
     * Registers the peer with the signaling server
     */
    register() {
        this.sendToServer({
            type: "register",
            payload: {
                clientId: this.config.clientId,
                publicKey: Array.from(this.config.publicKey),
            },
        });
        console.log("[IM @ " + this.config.clientId + "] Register payload sent");
    }
    /**
     * Registers the peer with the signaling server and waits for confirmation
     * @returns Promise that resolves when registration is confirmed
     */
    async registerAndWait() {
        // Creating a proof that shows our signing key
        const proofSignature = await unifiedCrypto_1.unifiedCrypto.sign("ml-dsa", this.config.publicKey);
        const serializedProofSignature = {
            algorithm: "ml-dsa",
            serializedSignedData: (0, uint8Serialize_1.serializeUint8Array)(proofSignature.signature),
            serializedPublicKey: (0, uint8Serialize_1.serializeUint8Array)(proofSignature.publicKey),
            serializedMessage: (0, uint8Serialize_1.serializeUint8Array)(proofSignature.message),
        };
        // Sending the registration request and signing key proof
        await this.sendToServerAndWait({
            type: "register",
            payload: {
                clientId: this.config.clientId,
                publicKey: Array.from(this.config.publicKey),
                verification: serializedProofSignature,
            },
        }, "register");
        console.log("[IM @ " + this.config.clientId + "] Registration confirmed");
    }
    /**
     * Discovers all connected peers
     * @returns Promise that resolves with an array of peer IDs
     */
    async discoverPeers() {
        const response = await this.sendToServerAndWait({
            type: "discover",
            payload: {},
        }, "discover");
        this.connectedPeers = new Set(response.peers);
        return response.peers;
    }
    /**
     * Sends a message to a specific peer
     * @param targetId - The ID of the target peer
     * @param message - The message to send
     */
    async sendMessage(targetId, message) {
        // Get the target peer's public key
        // REVIEW Error handling if it fails?
        const targetPublicKey = await this.requestPublicKey(targetId);
        // Encrypt the message using ml-kem-aes
        // NOTE This assumes that we have already exchanged public keys with the target peer
        const bytesMessage = new TextEncoder().encode(message);
        const encryptedMessage = await unifiedCrypto_1.unifiedCrypto.encrypt("ml-kem-aes", bytesMessage, targetPublicKey);
        const serializedCipherText = (0, uint8Serialize_1.serializeUint8Array)(encryptedMessage.cipherText);
        const serializedEncryptedData = (0, uint8Serialize_1.serializeUint8Array)(encryptedMessage.encryptedData);
        const serializedEncryptedObject = {
            algorithm: "ml-kem-aes",
            serializedCipherText,
            serializedEncryptedData,
        };
        // Send the encrypted message to the target peer
        this.sendToServer({
            type: "message",
            payload: {
                targetId: targetId,
                message: serializedEncryptedObject,
            },
        });
    }
    /**
     * Requests a peer's public key
     * @param peerId - The ID of the peer whose public key to request
     * @returns Promise that resolves with the peer's public key
     */
    async requestPublicKey(peerId) {
        const response = await this.sendToServerAndWait({
            type: "request_public_key",
            payload: {
                targetId: peerId,
            },
        }, "public_key_response", {
            filterFn: message => message.payload.peerId === peerId,
        });
        return new Uint8Array(response.publicKey);
    }
    /**
     * Responds to a server question
     * @param questionId - The ID of the question to respond to
     * @param response - The response to send back to the server
     */
    respondToServer(questionId, response) {
        this.sendToServer({
            type: "peer_response",
            payload: {
                questionId,
                response,
            },
        });
    }
    /**
     * Registers a handler for server questions
     * @param handler - Function to call when a server question is received
     */
    onServerQuestion(handler) {
        const messageHandler = (message, fromId) => {
            if (message.type === "server_question") {
                handler(message.payload.question, message.payload.questionId);
            }
        };
        this.messageHandlers.add(messageHandler);
    }
    /**
     * Adds a handler for incoming messages
     * @param handler - Function to call when a message is received
     */
    onMessage(handler) {
        this.messageHandlers.add(handler);
    }
    /**
     * Adds a handler for errors
     * @param handler - Function to call when an error occurs
     */
    onError(handler) {
        this.errorHandlers.add(handler);
    }
    /**
     * Adds a handler for peer disconnection events
     * @param handler - Function to call when a peer disconnects
     */
    onPeerDisconnected(handler) {
        this.peerDisconnectedHandlers.add(handler);
    }
    /**
     * Adds a handler for connection state changes
     * @param handler - Function to call when connection state changes
     */
    onConnectionStateChange(handler) {
        this.connectionStateHandlers.add(handler);
    }
    /**
     * Removes a message handler
     * @param handler - The handler to remove
     */
    removeMessageHandler(handler) {
        this.messageHandlers.delete(handler);
    }
    /**
     * Removes an error handler
     * @param handler - The handler to remove
     */
    removeErrorHandler(handler) {
        this.errorHandlers.delete(handler);
    }
    /**
     * Removes a peer disconnected handler
     * @param handler - The handler to remove
     */
    removePeerDisconnectedHandler(handler) {
        this.peerDisconnectedHandlers.delete(handler);
    }
    /**
     * Removes a connection state change handler
     * @param handler - The handler to remove
     */
    removeConnectionStateHandler(handler) {
        this.connectionStateHandlers.delete(handler);
    }
    /**
     * Closes the connection to the signaling server
     */
    disconnect() {
        this.isReconnecting = false;
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
        if (this.ws) {
            this.ws.close();
            this.ws = null;
            this.isConnected = false;
            this.connectedPeers.clear();
            this.notifyConnectionState("disconnected");
        }
    }
    /**
     * Sends a message to the signaling server
     * @param message - The message to send
     */
    sendToServer(message) {
        if (!this.ws || !this.isConnected) {
            this.messageQueue.push(message);
            return;
        }
        try {
            this.ws.send(JSON.stringify(message));
        }
        catch (error) {
            this.handleError({
                type: "SEND_ERROR",
                details: error instanceof Error
                    ? error.message
                    : "Failed to send message",
            });
        }
    }
    /**
     * Sends a message to the server and waits for a specific response type
     * @param message - The message to send
     * @param expectedResponseType - The type of response to wait for
     * @param options - Additional options for handling the response
     * @returns Promise that resolves with the response payload or rejects with an error
     */
    async sendToServerAndWait(message, expectedResponseType, options = {}) {
        const { timeout = 10000, errorHandler, retryCount = 0, filterFn, } = options;
        try {
            // Send the message
            this.sendToServer(message);
            // Wait for the response
            return await this.awaitResponse(expectedResponseType, filterFn, timeout);
        }
        catch (error) {
            // Custom error handling
            if (errorHandler) {
                errorHandler(error);
            }
            // Retry logic if needed
            if (retryCount > 0) {
                console.log(`[IM] Retrying message (${retryCount} attempts remaining)...`);
                return this.sendToServerAndWait(message, expectedResponseType, {
                    ...options,
                    retryCount: retryCount - 1,
                });
            }
            throw error;
        }
    }
    /**
     * Handles incoming messages from the signaling server
     * @param message - The received message
     */
    handleMessage(message) {
        switch (message.type) {
            case "message":
                console.log("[IM @ " +
                    this.config.clientId +
                    "] Received an encrypted message");
                //console.log(message)
                // Decrypt the message using ml-kem-aes before passing to handlers
                const serializedEncryptedMessage = message.payload // REVIEW Safeguard this?
                    .message; // REVIEW Safeguard this?
                const cipherText = (0, uint8Serialize_1.deserializeUint8Array)(serializedEncryptedMessage.serializedCipherText);
                const encryptedData = (0, uint8Serialize_1.deserializeUint8Array)(serializedEncryptedMessage.serializedEncryptedData);
                const encryptedMessage = {
                    algorithm: serializedEncryptedMessage.algorithm,
                    cipherText,
                    encryptedData,
                };
                // NOTE When we receive a message, we need to decrypt it before passing it to the message handlers
                // This is an async operation, so we need to handle it properly
                console.log("[IM @ " + this.config.clientId + "] Decrypting message:");
                const decryptedMessage = unifiedCrypto_1.unifiedCrypto
                    .decrypt(encryptedMessage)
                    .then(decryptedMessage => {
                    console.log("[IM @ " +
                        this.config.clientId +
                        "] Decrypted message: ", decryptedMessage);
                    // NOTE If something is added here, it will be executed for every message
                    // Below are the user-defined message handlers (through peer.onMessage)
                    this.messageHandlers.forEach(handler => {
                        handler(decryptedMessage, message.payload.fromId);
                    });
                });
                break;
            case "register":
                // Handle registration response
                console.log("[IM @ " +
                    this.config.clientId +
                    "] Received registration response:", message.payload);
                // Pass the message to any temporary handlers waiting for this response
                this.messageHandlers.forEach(handler => {
                    handler(message, "");
                });
                break;
            case "peer_disconnected":
                this.connectedPeers.delete(message.payload.peerId);
                this.peerDisconnectedHandlers.forEach(handler => {
                    handler(message.payload.peerId);
                });
                break;
            case "server_question":
                console.log("[IM @ " +
                    this.config.clientId +
                    "] Received a server question:", message.payload);
                // Pass the message to any temporary handlers waiting for this response
                this.messageHandlers.forEach(handler => {
                    handler(message, "");
                });
                break;
            case "peer_response":
                console.log("[IM @ " +
                    this.config.clientId +
                    "] Received a peer response:", message.payload);
                // Pass the message to any temporary handlers waiting for this response
                this.messageHandlers.forEach(handler => {
                    handler(message, "");
                });
                break;
            /*case "error":
                console.error("[IM @ " + this.config.clientId + "] Received an error message: ", message)
                this.handleError({
                    type: message.payload.errorType,
                    details: message.payload.details,
                })
                break*/
            default:
                console.info("[IM @ " + this.config.clientId + "] Received a message: ");
                console.log(message.type);
                // Pass the message to any temporary handlers waiting for this response
                this.messageHandlers.forEach(handler => {
                    handler(message, "");
                });
                break;
        }
    }
    /**
     * Handles errors
     * @param error - The error to handle
     */
    handleError(error) {
        this.errorHandlers.forEach(handler => {
            handler(error);
        });
    }
    /**
     * Notifies connection state change handlers
     * @param state - The new connection state
     */
    notifyConnectionState(state) {
        this.connectionStateHandlers.forEach(handler => {
            handler(state);
        });
    }
    /**
     * Adds a temporary message handler that will be removed after handling one message
     * @param handler - The temporary handler to add
     */
    addTemporaryMessageHandler(handler) {
        const tempHandler = (message, fromId) => {
            // If the message is a Message object, pass it directly
            if (message && typeof message === "object" && "type" in message) {
                handler(message, fromId);
            }
            else {
                // Otherwise, create a Message object from the data
                handler({
                    type: "message",
                    payload: message,
                }, fromId);
            }
            this.removeMessageHandler(tempHandler);
        };
        this.messageHandlers.add(tempHandler);
    }
    /**
     * Process queued messages
     */
    processMessageQueue() {
        while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            if (message) {
                this.sendToServer(message);
            }
        }
    }
}
exports.MessagingPeer = MessagingPeer;
//# sourceMappingURL=index.js.map