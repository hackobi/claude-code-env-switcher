export interface MessagingPeerConfig {
    serverUrl: string;
    clientId: string;
    publicKey: Uint8Array;
}
export interface Message {
    type: "register" | "discover" | "message" | "peer_disconnected" | "request_public_key" | "public_key_response" | "server_question" | "peer_response" | "debug_question" | "error";
    payload: any;
}
type MessageHandler = (message: any, fromId: string) => void;
type ErrorHandler = (error: {
    type: string;
    details: string;
}) => void;
type PeerDisconnectedHandler = (peerId: string) => void;
type ConnectionStateHandler = (state: "connected" | "disconnected" | "reconnecting") => void;
export declare class MessagingPeer {
    ws: WebSocket | null;
    private config;
    private messageHandlers;
    private errorHandlers;
    private peerDisconnectedHandlers;
    private connectionStateHandlers;
    private connectedPeers;
    private messageQueue;
    isConnected: boolean;
    private reconnectAttempts;
    private maxReconnectAttempts;
    private baseReconnectDelay;
    private reconnectTimeout;
    private isReconnecting;
    constructor(config: MessagingPeerConfig);
    /**
     * Connects to the signaling server and registers the peer
     * @returns Promise that resolves when connected and registered
     */
    connect(): Promise<void>;
    /**
     * Establishes WebSocket connection and sets up event handlers
     */
    private connectWebSocket;
    /**
     * Attempts to reconnect to the server with exponential backoff
     */
    private attemptReconnect;
    /**
     * Awaits a response for a specific message type
     * @param messageType - The type of message to wait for
     * @param filterFn - Optional function to filter messages by additional criteria
     * @param timeout - Optional timeout in milliseconds (default: 10000)
     * @returns Promise that resolves with the message payload or rejects with an error
     */
    awaitResponse<T = any>(messageType: Message["type"], filterFn?: (message: Message) => boolean, timeout?: number): Promise<T>;
    /**
     * Registers the peer with the signaling server
     */
    register(): void;
    /**
     * Registers the peer with the signaling server and waits for confirmation
     * @returns Promise that resolves when registration is confirmed
     */
    registerAndWait(): Promise<void>;
    /**
     * Discovers all connected peers
     * @returns Promise that resolves with an array of peer IDs
     */
    discoverPeers(): Promise<string[]>;
    /**
     * Sends a message to a specific peer
     * @param targetId - The ID of the target peer
     * @param message - The message to send
     */
    sendMessage(targetId: string, message: string): Promise<void>;
    /**
     * Requests a peer's public key
     * @param peerId - The ID of the peer whose public key to request
     * @returns Promise that resolves with the peer's public key
     */
    requestPublicKey(peerId: string): Promise<Uint8Array>;
    /**
     * Responds to a server question
     * @param questionId - The ID of the question to respond to
     * @param response - The response to send back to the server
     */
    respondToServer(questionId: string, response: any): void;
    /**
     * Registers a handler for server questions
     * @param handler - Function to call when a server question is received
     */
    onServerQuestion(handler: (question: any, questionId: string) => void): void;
    /**
     * Adds a handler for incoming messages
     * @param handler - Function to call when a message is received
     */
    onMessage(handler: MessageHandler): void;
    /**
     * Adds a handler for errors
     * @param handler - Function to call when an error occurs
     */
    onError(handler: ErrorHandler): void;
    /**
     * Adds a handler for peer disconnection events
     * @param handler - Function to call when a peer disconnects
     */
    onPeerDisconnected(handler: PeerDisconnectedHandler): void;
    /**
     * Adds a handler for connection state changes
     * @param handler - Function to call when connection state changes
     */
    onConnectionStateChange(handler: ConnectionStateHandler): void;
    /**
     * Removes a message handler
     * @param handler - The handler to remove
     */
    removeMessageHandler(handler: MessageHandler): void;
    /**
     * Removes an error handler
     * @param handler - The handler to remove
     */
    removeErrorHandler(handler: ErrorHandler): void;
    /**
     * Removes a peer disconnected handler
     * @param handler - The handler to remove
     */
    removePeerDisconnectedHandler(handler: PeerDisconnectedHandler): void;
    /**
     * Removes a connection state change handler
     * @param handler - The handler to remove
     */
    removeConnectionStateHandler(handler: ConnectionStateHandler): void;
    /**
     * Closes the connection to the signaling server
     */
    disconnect(): void;
    /**
     * Sends a message to the signaling server
     * @param message - The message to send
     */
    private sendToServer;
    /**
     * Sends a message to the server and waits for a specific response type
     * @param message - The message to send
     * @param expectedResponseType - The type of response to wait for
     * @param options - Additional options for handling the response
     * @returns Promise that resolves with the response payload or rejects with an error
     */
    sendToServerAndWait<T = any>(message: Message, expectedResponseType: Message["type"], options?: {
        timeout?: number;
        errorHandler?: (error: any) => void;
        retryCount?: number;
        filterFn?: (message: Message) => boolean;
    }): Promise<T>;
    /**
     * Handles incoming messages from the signaling server
     * @param message - The received message
     */
    private handleMessage;
    /**
     * Handles errors
     * @param error - The error to handle
     */
    private handleError;
    /**
     * Notifies connection state change handlers
     * @param state - The new connection state
     */
    private notifyConnectionState;
    /**
     * Adds a temporary message handler that will be removed after handling one message
     * @param handler - The temporary handler to add
     */
    private addTemporaryMessageHandler;
    /**
     * Process queued messages
     */
    private processMessageQueue;
}
export {};
