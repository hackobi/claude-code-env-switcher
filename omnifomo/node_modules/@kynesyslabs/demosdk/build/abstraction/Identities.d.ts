import { XMCoreTargetIdentityPayload, Web2CoreTargetIdentityPayload, GithubProof, TwitterProof, InferFromSignaturePayload, DiscordProof, TelegramSignedAttestation, FindDemosIdByWeb2IdentityQuery, FindDemosIdByWeb3IdentityQuery } from "../types/abstraction";
import { UnifiedDomainResolution } from "./types/UDResolution";
import { Demos } from "../websdk/demosclass";
import { PQCAlgorithm } from "../types/cryptography";
import { Account, RPCResponseWithValidityData } from "../types";
export declare class Identities {
    formats: {
        web2: {
            github: string[];
            twitter: string[];
            discord: string[];
        };
    };
    /**
     * Create a web2 proof payload for use with web2 identity inference.
     *
     * @param keypair The keypair of the demos account.
     * @returns The web2 proof payload string.
     */
    createWeb2ProofPayload(demos: Demos): Promise<string>;
    /**
     * Infer an identity from either a crosschain payload or a web2 proof.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param context The context of the identity to infer.
     * @param payload The payload to infer the identity from.
     *
     * @returns The validity data of the identity transaction.
     */
    private inferIdentity;
    /**
     * Remove a crosschain identity associated with an address.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to remove the identity from.
     * @returns The response from the RPC call.
     */
    private removeIdentity;
    /**
     * Infer a crosschain identity from a signature.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to infer the identity from.
     * @returns The validity data of the identity transaction.
     */
    inferXmIdentity(demos: Demos, payload: InferFromSignaturePayload, referralCode?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Infer a web2 identity from a proof payload.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to infer the identity from.
     *
     * @returns The validity data of the identity transaction.
     */
    inferWeb2Identity(demos: Demos, payload: Web2CoreTargetIdentityPayload): Promise<RPCResponseWithValidityData>;
    /**
     * Remove a crosschain identity from the network.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to remove the identity.
     * @returns The response from the RPC call.
     */
    removeXmIdentity(demos: Demos, payload: XMCoreTargetIdentityPayload): Promise<RPCResponseWithValidityData>;
    /**
     * Remove a web2 identity from the network.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to remove the identity.
     * @returns The response from the RPC call.
     */
    removeWeb2Identity(demos: Demos, payload: {
        context: string;
        username: string;
    }): Promise<RPCResponseWithValidityData>;
    /**
     * Add a github identity to the GCR.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to add the identity to.
     * @returns The response from the RPC call.
     */
    addGithubIdentity(demos: Demos, payload: GithubProof, referralCode?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Add a twitter identity to the GCR.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to add the identity to.
     * @returns The response from the RPC call.
     */
    addTwitterIdentity(demos: Demos, payload: TwitterProof, referralCode?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Add a discord identity to the GCR.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The payload to add the identity to.
     * @returns The response from the RPC call.
     */
    addDiscordIdentity(demos: Demos, payload: DiscordProof, referralCode?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Add a telegram identity to the GCR.
     * This method is designed to work with telegram bot attestations.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param payload The telegram identity payload containing user and bot signatures.
     * @param referralCode Optional referral code for incentive points.
     * @returns The response from the RPC call.
     */
    addTelegramIdentity(demos: Demos, payload: TelegramSignedAttestation, referralCode?: string): Promise<RPCResponseWithValidityData>;
    bindPqcIdentity(demos: Demos, algorithms?: "all" | PQCAlgorithm[]): Promise<RPCResponseWithValidityData>;
    removePqcIdentity(demos: Demos, algorithms?: "all" | PQCAlgorithm[]): Promise<RPCResponseWithValidityData>;
    /**
     * Get the identities associated with an address.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param address The address to get identities for.
     * @returns The identities associated with the address.
     */
    getIdentities(demos: Demos, call?: string, address?: string): Promise<import("../types").RPCResponse>;
    /**
     * Get the crosschain identities associated with an address.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param address The address to get identities for.
     * @returns The identities associated with the address.
     */
    getXmIdentities(demos: Demos, address?: string): Promise<import("../types").RPCResponse>;
    /**
     * Get the web2 identities associated with an address.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param address The address to get identities for.
     * @returns The identities associated with the address.
     */
    getWeb2Identities(demos: Demos, address?: string): Promise<import("../types").RPCResponse>;
    /**
     * Get the points associated with an identity
     *
     * @param demos A Demos instance to communicate with the RPC
     * @param address The address to get points for. Defaults to the connected wallet's address.
     * @returns The points data for the identity
     */
    getUserPoints(demos: Demos, address?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Validate a referral code to check if it exists and is valid.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param referralCode The referral code to validate.
     * @returns The validation result containing validity status, referrer public key, and message.
     */
    validateReferralCode(demos: Demos, referralCode: string): Promise<import("../types").RPCResponse>;
    /**
     * Get referral information for an address.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param address The address to get referral info for. Defaults to the connected wallet's address.
     * @returns The referral information associated with the address.
     */
    getReferralInfo(demos: Demos, address?: string): Promise<import("../types").RPCResponse>;
    /**
     * Get demos accounts by linked web2 or web3 identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param identity The identity to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByIdentity(demos: Demos, identity: FindDemosIdByWeb2IdentityQuery | FindDemosIdByWeb3IdentityQuery): Promise<Account[]>;
    /**
     * Get demos accounts by linked web2 identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param context The context of the identity to get the account for.
     * @param username The username to get the account for.
     * @param userId The user id to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByWeb2Identity(demos: Demos, context: "twitter" | "github" | "discord" | "telegram", username: string, userId?: string): Promise<Account[]>;
    /**
     * Get demos accounts by linked web3 identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param chain The chain as a string containing the chain and subchain separated by a period (eg. "eth.mainnet" | "solana.mainnet", etc.)
     * @param address The address to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByWeb3Identity(demos: Demos, chain: `${string}.${string}`, address: string): Promise<Account[]>;
    /**
     * Get demos accounts by linked twitter identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param username The username to get the account for.
     * @returns The account associated with the username.
     */
    getDemosIdsByTwitter(demos: Demos, username: string, userId?: string): Promise<Account[]>;
    /**
     * Get demos accounts by linked github identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param username The username to get the account for.
     * @param userId The user id to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByGithub(demos: Demos, username: string, userId?: string): Promise<Account[]>;
    /**
     * Get demos accounts by linked discord identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param username The username to get the account for.
     * @param userId The user id to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByDiscord(demos: Demos, username: string, userId?: string): Promise<Account[]>;
    /**
     * Get demos accounts by linked telegram identity.
     *
     * @param demos A Demos instance to communicate with the RPC.
     * @param username The username to get the account for.
     * @param userId The user id to get the account for.
     * @returns The account associated with the identity.
     */
    getDemosIdsByTelegram(demos: Demos, username: string, userId?: string): Promise<Account[]>;
    /**
     * Detect signature type from address format
     *
     * @param address The blockchain address to analyze
     * @returns "evm" for Ethereum-compatible addresses, "solana" for Solana addresses
     * @throws Error if address format is not recognized
     *
     * @private
     */
    private detectSignatureType;
    /**
     * Generate a challenge message for Unstoppable Domain ownership verification.
     *
     * The user must sign this challenge with one of their domain's authorized addresses
     * using MetaMask (EVM) or Phantom (Solana) wallet.
     *
     * @param demosPublicKey The user's Demos public key (hex string)
     * @param signingAddress The address that will sign the challenge (from domain's authorized addresses)
     * @returns Challenge message to be signed
     */
    generateUDChallenge(demosPublicKey: string, signingAddress: string): string;
    /**
     * Resolve a domain to its owner's address and other metadata.
     *
     * @param demos A Demos instance to communicate with the RPC
     * @param domain The UD domain (e.g., "brad.crypto")
     * @returns The unified domain resolution result
     */
    resolveUDDomain(demos: Demos, domain: string): Promise<UnifiedDomainResolution>;
    /**
     * Add an Unstoppable Domain identity to the GCR.
     *
     * Flow:
     * 1. User selects an authorized address from their domain records
     * 2. User signs challenge with their wallet (MetaMask for EVM, Phantom for Solana)
     * 3. Submit domain + signature for verification
     *
     * @param demos A Demos instance to communicate with the RPC
     * @param domain The UD domain (e.g., "brad.crypto")
     * @param signingAddress The address used to sign (from domain's authorized addresses)
     * @param signature Signature from the signing address
     * @param signedData The challenge message that was signed
     * @param referralCode Optional referral code
     * @returns The response from the RPC call
     *
     * @example
     * ```typescript
     * const identities = new Identities()
     * // Get signable addresses for the domain
     * const addresses = await identities.getUDSignableAddresses("brad.crypto")
     * const signingAddress = addresses[0].address // User selects address
     *
     * // Generate challenge with selected address
     * const challenge = identities.generateUDChallenge(demos.publicKey, signingAddress)
     *
     * // User signs challenge (EVM example with MetaMask)
     * const signature = await ethereum.request({
     *     method: 'personal_sign',
     *     params: [challenge, signingAddress]
     * })
     *
     * await identities.addUnstoppableDomainIdentity(
     *     demos,
     *     "brad.crypto",
     *     signingAddress,
     *     signature,
     *     challenge
     * )
     * ```
     */
    addUnstoppableDomainIdentity(demos: Demos, signingAddress: string, signature: string, challenge: string, resolutionData: UnifiedDomainResolution, referralCode?: string): Promise<RPCResponseWithValidityData>;
    /**
     * Remove an Unstoppable Domain identity from the GCR.
     *
     * @param demos A Demos instance to communicate with the RPC
     * @param domain The UD domain (e.g., "brad.crypto")
     *
     * @returns The validity data response from the RPC
     */
    removeUnstoppableDomainIdentity(demos: Demos, domain: string): Promise<RPCResponseWithValidityData>;
    /**
     * Get the Unstoppable Domain identities associated with an address.
     *
     * @param demos A Demos instance to communicate with the RPC
     * @param address The address to get identities for. Defaults to the connected wallet's address.
     *
     * @returns The identities associated with the address.
     */
    getUDIdentities(demos: Demos, address?: string): Promise<import("../types").RPCResponse>;
}
