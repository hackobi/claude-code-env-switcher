import { chainIds } from "./providers/CoinAddresses";
type SupportedChainId = typeof chainIds.eth.mainnet | typeof chainIds.bsc.mainnet | typeof chainIds.arbitrum.mainnet | typeof chainIds.optimism.mainnet;
interface EvmTokenPair {
    native: string;
    wrapped: string | false;
}
/**
 * Error class for EVM coin finder
 * @extends Error
 * @param {string} message - The error message
 * @param {string} code - The error code
 * @param {any} details - The error details
 */
export declare class EvmError extends Error {
    readonly code: string;
    readonly details?: any;
    constructor(message: string, code: string, details?: any);
}
/**
 * Class for finding wrapped tokens on EVM chains
 * @throws {EvmError} With code 'UNSUPPORTED_CHAIN_ID' if chain ID is not supported
 * @throws {EvmError} With code 'INVALID_ADDRESS' if token address is invalid
 * @throws {EvmError} With code 'CONTRACT_NOT_FOUND' if token contract doesn't exist
 */
export declare class EvmCoinFinder {
    private static getChainName;
    private static isValidAddress;
    private static getChainNameFromId;
    private static getRandomProvider;
    static validateChainId(chainId: number): asserts chainId is SupportedChainId;
    /**
     * Finds native ETH and WETH addresses for given chain IDs
     * @param {SupportedChainId[]} targetChainIds - Array of supported chain IDs
     * @returns {Promise<Record<SupportedChainId, EvmTokenPair>>}
     * @throws {EvmError} With code 'UNSUPPORTED_CHAIN_ID' if any chain ID is not supported
     */
    static findNativeEth(targetChainIds: SupportedChainId[]): Promise<Record<SupportedChainId, EvmTokenPair>>;
    /**
     * Finds the wrapped assets for the given chain IDs
     * @param {SupportedChainId[]} targetChainIds The chain IDs to find wrapped assets for
     * @returns {Promise<Record<number, EvmTokenPair>>} An object with the wrapped assets for each chain ID or false if not found
     */
    static findWrappedAssets(targetChainIds: SupportedChainId[]): Promise<Record<SupportedChainId, EvmTokenPair>>;
    /**
     * Finds wrapped token addresses across different chains
     * @param {string} tokenAddress - Token address on source chain
     * @param {SupportedChainId} sourceChainId - Chain ID where token exists
     * @param {SupportedChainId[]} targetChainIds - Chain IDs to find wrapped versions
     * @returns {Promise<Record<SupportedChainId, EvmTokenPair>>} Map of chain IDs to token addresses
     * @throws {EvmError} With various error codes for different failure cases
     */
    static findTokenPairs(tokenAddress: string, sourceChainId: SupportedChainId, targetChainIds: SupportedChainId[]): Promise<Record<SupportedChainId, EvmTokenPair>>;
    /**
     * Finds the native address for the given chain ID
     * @param {string} chain The chain to find the native address for
     * @param {number} targetChainId The chain ID to find the native address for
     * @returns {string} The native address for the given chain ID
     */
    static getNativeForSupportedChain(chain: string, targetChainId: number): string;
}
export {};
