"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmCoinFinder = exports.EvmError = void 0;
const providers_1 = __importDefault(require("./providers"));
const CoinAddresses_1 = require("./providers/CoinAddresses");
const ethers = __importStar(require("ethers"));
/**
 * Error class for EVM coin finder
 * @extends Error
 * @param {string} message - The error message
 * @param {string} code - The error code
 * @param {any} details - The error details
 */
class EvmError extends Error {
    constructor(message, code, details) {
        super(message);
        this.code = code;
        this.details = details;
    }
}
exports.EvmError = EvmError;
/**
 * Class for finding wrapped tokens on EVM chains
 * @throws {EvmError} With code 'UNSUPPORTED_CHAIN_ID' if chain ID is not supported
 * @throws {EvmError} With code 'INVALID_ADDRESS' if token address is invalid
 * @throws {EvmError} With code 'CONTRACT_NOT_FOUND' if token contract doesn't exist
 */
class EvmCoinFinder {
    static getChainName(chainId) {
        switch (chainId) {
            case CoinAddresses_1.chainIds.eth.mainnet:
                return CoinAddresses_1.BaseChain.ETHEREUM;
            case CoinAddresses_1.chainIds.bsc.mainnet:
                return CoinAddresses_1.BaseChain.BSC;
            case CoinAddresses_1.chainIds.arbitrum.mainnet:
                return CoinAddresses_1.BaseChain.ARBITRUM;
            case CoinAddresses_1.chainIds.optimism.mainnet:
                return CoinAddresses_1.BaseChain.OPTIMISM;
            default:
                throw new Error(`Unsupported chain ID: ${chainId}`);
        }
    }
    static isValidAddress(address) {
        return ethers.isAddress(address);
    }
    static getChainNameFromId(chainId) {
        switch (chainId) {
            case CoinAddresses_1.chainIds.eth.mainnet:
                return CoinAddresses_1.BaseChain.ETHEREUM;
            case CoinAddresses_1.chainIds.bsc.mainnet:
                return CoinAddresses_1.BaseChain.BSC;
            case CoinAddresses_1.chainIds.arbitrum.mainnet:
                return CoinAddresses_1.BaseChain.ARBITRUM;
            case CoinAddresses_1.chainIds.optimism.mainnet:
                return CoinAddresses_1.BaseChain.OPTIMISM;
            default:
                return undefined;
        }
    }
    static async getRandomProvider(chainId) {
        // Filter out Flashbots and Payload RPCs
        const rpcUrls = providers_1.default.evm[chainId.toString()].filter(url => !url.includes("flashbots.net") && !url.includes("payload.de"));
        if (!rpcUrls || rpcUrls.length === 0) {
            throw new Error(`No providers found for chain ${chainId}`);
        }
        // Shuffle RPC URLs to try them in random order
        const shuffledUrls = [...rpcUrls].sort(() => Math.random() - 0.5);
        // Try each RPC until one works
        for (const rpcUrl of shuffledUrls) {
            try {
                // Create ethers provider
                const provider = new ethers.JsonRpcProvider(rpcUrl, undefined, {
                    staticNetwork: true, // Prevent network detection
                });
                await provider.getNetwork(); // Test the connection
                return provider;
            }
            catch (error) {
                console.warn(`Failed to connect to RPC ${rpcUrl}:`, error);
                continue; // Try next RPC
            }
        }
        throw new Error(`All RPC providers failed for chain ${chainId}`);
    }
    static validateChainId(chainId) {
        if (!Object.values(CoinAddresses_1.chainIds).some(chain => Object.values(chain).includes(chainId))) {
            throw new EvmError(`Unsupported chain ID: ${chainId}`, "UNSUPPORTED_CHAIN_ID");
        }
    }
    /**
     * Finds native ETH and WETH addresses for given chain IDs
     * @param {SupportedChainId[]} targetChainIds - Array of supported chain IDs
     * @returns {Promise<Record<SupportedChainId, EvmTokenPair>>}
     * @throws {EvmError} With code 'UNSUPPORTED_CHAIN_ID' if any chain ID is not supported
     */
    static async findNativeEth(targetChainIds) {
        const result = {};
        for (const chainId of targetChainIds) {
            this.validateChainId(chainId);
            let weth;
            switch (chainId) {
                case CoinAddresses_1.chainIds.eth.mainnet:
                    weth = CoinAddresses_1.tokenAddresses.ethereum.wrapped.ethereum.mainnet;
                    break;
                case CoinAddresses_1.chainIds.bsc.mainnet:
                    weth = CoinAddresses_1.tokenAddresses.ethereum.wrapped.bsc.mainnet;
                    break;
                case CoinAddresses_1.chainIds.arbitrum.mainnet:
                    weth = CoinAddresses_1.tokenAddresses.ethereum.wrapped.arbitrum.mainnet;
                    break;
                case CoinAddresses_1.chainIds.optimism.mainnet:
                    weth = CoinAddresses_1.tokenAddresses.ethereum.wrapped.optimism.mainnet;
                    break;
            }
            if (weth) {
                result[chainId] = {
                    native: CoinAddresses_1.tokenAddresses.ethereum.mainnet, // native ETH
                    wrapped: weth, // wrapped ETH
                };
            }
        }
        return result;
    }
    /**
     * Finds the wrapped assets for the given chain IDs
     * @param {SupportedChainId[]} targetChainIds The chain IDs to find wrapped assets for
     * @returns {Promise<Record<number, EvmTokenPair>>} An object with the wrapped assets for each chain ID or false if not found
     */
    static async findWrappedAssets(targetChainIds) {
        const result = {};
        for (const chainId of targetChainIds) {
            this.validateChainId(chainId);
            result[chainId] = {
                native: CoinAddresses_1.tokenAddresses.ethereum.mainnet,
                wrapped: CoinAddresses_1.tokenAddresses.ethereum.wrapped[this.getChainName(chainId)]
                    ?.mainnet || false,
            };
        }
        return result;
    }
    /**
     * Finds wrapped token addresses across different chains
     * @param {string} tokenAddress - Token address on source chain
     * @param {SupportedChainId} sourceChainId - Chain ID where token exists
     * @param {SupportedChainId[]} targetChainIds - Chain IDs to find wrapped versions
     * @returns {Promise<Record<SupportedChainId, EvmTokenPair>>} Map of chain IDs to token addresses
     * @throws {EvmError} With various error codes for different failure cases
     */
    static async findTokenPairs(tokenAddress, sourceChainId, targetChainIds) {
        if (!this.isValidAddress(tokenAddress)) {
            throw new EvmError("Invalid token address", "INVALID_ADDRESS", {
                address: tokenAddress,
            });
        }
        const result = {};
        // Verify token exists on source chain
        const provider = await this.getRandomProvider(sourceChainId);
        const code = await provider.getCode(tokenAddress);
        if (code === "0x") {
            throw new Error("Token contract not found on source chain");
        }
        // Get chain names for lookup
        const sourceChain = this.getChainNameFromId(sourceChainId);
        if (!sourceChain) {
            throw new Error(`Unsupported chain ID: ${sourceChainId}`);
        }
        for (const targetChainId of targetChainIds) {
            // Same chain = same address
            if (targetChainId === sourceChainId) {
                result[targetChainId] = {
                    native: tokenAddress,
                    wrapped: false,
                };
                continue;
            }
            const targetChain = this.getChainNameFromId(targetChainId);
            if (!targetChain) {
                result[targetChainId] = {
                    native: tokenAddress,
                    wrapped: false,
                };
                continue;
            }
            // Check USDC mapping
            if (tokenAddress === CoinAddresses_1.tokenAddresses.usdc[sourceChain]?.mainnet) {
                result[targetChainId] = {
                    native: tokenAddress,
                    wrapped: CoinAddresses_1.tokenAddresses.usdc[targetChain]?.mainnet || false,
                };
                continue;
            }
            // Check USDT mapping
            if (tokenAddress === CoinAddresses_1.tokenAddresses.usdt[sourceChain]?.mainnet) {
                result[targetChainId] = {
                    native: tokenAddress,
                    wrapped: CoinAddresses_1.tokenAddresses.usdt[targetChain]?.mainnet || false,
                };
                continue;
            }
            result[targetChainId] = {
                native: tokenAddress,
                wrapped: false,
            };
        }
        return result;
    }
    /**
     * Finds the native address for the given chain ID
     * @param {string} chain The chain to find the native address for
     * @param {number} targetChainId The chain ID to find the native address for
     * @returns {string} The native address for the given chain ID
     */
    static getNativeForSupportedChain(chain, targetChainId) {
        // Validate chain matches targetChainId
        switch (chain) {
            case CoinAddresses_1.BaseChain.ETHEREUM:
                if (targetChainId !== CoinAddresses_1.chainIds.eth.mainnet) {
                    throw new Error("Chain ID doesn't match ethereum");
                }
                return CoinAddresses_1.tokenAddresses.ethereum.mainnet;
            case CoinAddresses_1.BaseChain.BSC:
                if (targetChainId !== CoinAddresses_1.chainIds.bsc.mainnet) {
                    throw new Error("Chain ID doesn't match bsc");
                }
                break;
            case CoinAddresses_1.BaseChain.ARBITRUM:
                if (targetChainId !== CoinAddresses_1.chainIds.arbitrum.mainnet) {
                    throw new Error("Chain ID doesn't match arbitrum");
                }
                break;
            case CoinAddresses_1.BaseChain.OPTIMISM:
                if (targetChainId !== CoinAddresses_1.chainIds.optimism.mainnet) {
                    throw new Error("Chain ID doesn't match optimism");
                }
                break;
            default:
                throw new Error(`Unsupported chain: ${chain}`);
        }
        // Return native address (0x0)
        return CoinAddresses_1.tokenAddresses.ethereum.mainnet;
    }
}
exports.EvmCoinFinder = EvmCoinFinder;
//# sourceMappingURL=EvmCoinFinder.js.map