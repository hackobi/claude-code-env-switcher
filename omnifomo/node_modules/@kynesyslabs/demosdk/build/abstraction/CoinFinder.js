"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinFinder = void 0;
const CoinAddresses_1 = require("./providers/CoinAddresses");
/**
 * Class for finding wrapped tokens on various chains
 */
class CoinFinder {
    static validateChain(chain) {
        if (!Object.values(CoinAddresses_1.BaseChain).includes(chain)) {
            throw new Error(`Invalid chain: ${chain}`);
        }
    }
    /**
     * Finds the wrapped token address for a given source chain on a target chain
     * @param {BaseChain} sourceChain The chain whose token we want to find (e.g., BITCOIN, SOLANA)
     * @param {BaseChain} targetChain The chain where we want to find the wrapped token
     * @returns {Promise<string | false>} The wrapped token address or false if not found
     */
    static async findWrappedToken(sourceChain, targetChain) {
        this.validateChain(sourceChain);
        this.validateChain(targetChain);
        return (CoinAddresses_1.tokenAddresses[sourceChain].wrapped?.[targetChain]?.mainnet || false);
    }
    /**
     * Gets the native token address for any supported chain
     * @param {SupportedChain} chain The supported chain to find the native address for (e.g., "ethereum_mainnet")
     * @param {number} targetChainId The chain ID to find the native address for (e.g., 1 for Ethereum mainnet)
     * @returns {string} The native token address for the given chain ID
     * @throws {Error} If chain ID doesn't match the chain or if chain is unsupported
     */
    static getNativeForSupportedChain(chain, targetChainId = 1) {
        const [chainType, networkType] = chain.split("_");
        // Handle EVM chains
        switch (chainType) {
            case CoinAddresses_1.BaseChain.ETHEREUM:
            case CoinAddresses_1.BaseChain.BSC:
            case CoinAddresses_1.BaseChain.ARBITRUM:
            case CoinAddresses_1.BaseChain.OPTIMISM:
                // Validate chain ID matches the chain
                const chainIdMap = {
                    [CoinAddresses_1.BaseChain.ETHEREUM]: CoinAddresses_1.chainIds.eth.mainnet,
                    [CoinAddresses_1.BaseChain.BSC]: CoinAddresses_1.chainIds.bsc.mainnet,
                    [CoinAddresses_1.BaseChain.ARBITRUM]: CoinAddresses_1.chainIds.arbitrum.mainnet,
                    [CoinAddresses_1.BaseChain.OPTIMISM]: CoinAddresses_1.chainIds.optimism.mainnet,
                };
                if (targetChainId !== chainIdMap[chainType]) {
                    throw new Error(`Chain ID doesn't match ${chainType}`);
                }
                return CoinAddresses_1.tokenAddresses.ethereum[networkType];
            // Handle non-EVM chains
            case CoinAddresses_1.BaseChain.SOLANA:
            case CoinAddresses_1.BaseChain.MULTIVERSX:
            case CoinAddresses_1.BaseChain.XRP:
            case CoinAddresses_1.BaseChain.BITCOIN:
            case CoinAddresses_1.BaseChain.TON:
                if (targetChainId !== 1) {
                    throw new Error("Non-EVM chains only support targetChainId 1");
                }
                return CoinAddresses_1.tokenAddresses[chainType][networkType];
            default:
                throw new Error(`Unsupported chain: ${chain}`);
        }
    }
}
exports.CoinFinder = CoinFinder;
//# sourceMappingURL=CoinFinder.js.map