"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MULTIVERSX = void 0;
const core_1 = require("../core");
const sdk_core_1 = require("@multiversx/sdk-core");
const sdk_wallet_1 = require("@multiversx/sdk-wallet");
const interfaces_1 = require("../core/types/interfaces");
class MULTIVERSX extends core_1.MULTIVERSX {
    constructor(rpc_url) {
        super(rpc_url);
    }
    async getInfo() {
        throw new Error('Method not implemented.');
    }
    async createWallet(password, addressIndex) {
        (0, core_1.required)(password, 'Password is required to encrypt the key file');
        const mnemonics = sdk_wallet_1.Mnemonic.generate();
        const words = mnemonics.getWords();
        const words_with_index = words.map((word, index) => index + '. ' + word);
        const secretKey = mnemonics.deriveKey(addressIndex, password);
        const wallet = sdk_wallet_1.UserWallet.fromSecretKey({ secretKey, password });
        const jsonWallet = wallet.toJSON();
        // NOTE: .bech32 is the address property
        const walletAddress = jsonWallet.bech32;
        // TODO Return downloadable mnemonics & json files
        return {
            mnemonics: words,
            address: walletAddress,
            mnemonics_txt: words_with_index.join(''),
            wallet_keyfile: JSON.stringify(jsonWallet, null, 2),
        };
    }
    async sendTransaction(raw_tx) {
        (0, core_1.required)(this.provider, 'Provider not connected');
        if (raw_tx instanceof sdk_core_1.Transaction) {
            const tx_hash = await this.provider.sendTransaction(raw_tx);
            return {
                result: interfaces_1.XmTransactionResult.success,
                hash: tx_hash,
            };
        }
        // Handle hex-encoded JSON string
        let plainTx;
        if (typeof raw_tx === 'string') {
            try {
                let jsonString = raw_tx;
                if (raw_tx.startsWith('0x')) {
                    jsonString = Buffer.from(raw_tx.slice(2), 'hex').toString('utf-8');
                }
                plainTx = JSON.parse(jsonString);
            }
            catch (error) {
                throw new Error('Failed to parse transaction string. Invalid JSON format.');
            }
        }
        else {
            plainTx = raw_tx;
        }
        // The plain object format from toPlainObject()/toSendable() is already API-compatible.
        const response = await this.provider.doPostGeneric('transactions', plainTx);
        const tx_hash = response.txHash;
        if (!tx_hash || typeof tx_hash !== 'string') {
            throw new Error(`Failed to send transaction. API response: ${JSON.stringify(response)}`);
        }
        return {
            result: interfaces_1.XmTransactionResult.success,
            hash: tx_hash,
        };
    }
}
exports.MULTIVERSX = MULTIVERSX;
//# sourceMappingURL=multiversx.js.map