"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MULTIVERSX = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const sdk_network_providers_1 = require("@multiversx/sdk-network-providers");
const sdk_wallet_1 = require("@multiversx/sdk-wallet");
const bech32_1 = __importDefault(require("bech32"));
const core_1 = require("./");
class MULTIVERSX extends core_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.chainId = "";
        this.name = "egld";
        if (rpc_url) {
            this.setRPC(rpc_url);
        }
    }
    setRPC(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = new sdk_network_providers_1.ApiNetworkProvider(this.rpc_url);
    }
    async connect() {
        (0, core_1.required)(this.provider, "Provider not connected");
        try {
            const networkConfig = await this.provider.getNetworkConfig();
            this.chainId = networkConfig.ChainID;
            this.connected = Boolean(this.chainId);
            return this.connected;
        }
        catch (error) {
            this.connected = false;
        }
        return false;
    }
    async connectKeyFileWallet(keyFile, password) {
        try {
            // INFO: Parse the keyFile JSON string
            keyFile = JSON.parse(keyFile);
        }
        catch (error) {
            throw new Error("Failed to load the wallet. Invalid KeyFile!");
        }
        return sdk_wallet_1.UserSigner.fromWallet(keyFile, password);
    }
    async connectWallet(privateKey, options) {
        // INFO: This method is overriden in the web sdk
        // to connect with the extension wallet
        // Check if privateKey is a raw hex string (64 hex characters)
        const isRawHexKey = /^[0-9a-fA-F]{64}$/.test(privateKey);
        if (isRawHexKey) {
            const secretKey = sdk_wallet_1.UserSecretKey.fromString(privateKey);
            this.wallet = new sdk_wallet_1.UserSigner(secretKey);
        }
        else {
            this.wallet = await this.connectKeyFileWallet(privateKey, options?.password ?? '');
        }
        return this.wallet;
    }
    getAddress() {
        // INFO: method is overriden in the web sdk
        (0, core_1.required)(this.wallet, "Wallet not connected");
        return this.wallet.getAddress().bech32();
    }
    // SECTION: ReadsIntegrated 
    async getBalance(address) {
        (0, core_1.required)(address, "address is required to get the balance");
        const Iaddress = new sdk_core_1.Address(address);
        const account = await this.provider.getAccount(Iaddress);
        return account.balance.toString();
    }
    async getTokenBalance(token_id) {
        (0, core_1.required)(this.provider);
        (0, core_1.required)(this.wallet);
        const walletAddress = this.getAddress();
        const address = new sdk_core_1.Address(walletAddress);
        const token = await this.provider.getFungibleTokenOfAccount(address, token_id);
        return token.balance.toNumber();
    }
    async getNFTs() {
        (0, core_1.required)(this.provider);
        (0, core_1.required)(this.wallet);
        const address = this.getAddress();
        const account = new sdk_core_1.Address(address);
        return this.provider.getNonFungibleTokensOfAccount(account);
    }
    async signMessage(message, options) {
        (0, core_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        let wallet = this.wallet;
        const signedMessage = wallet.sign(Buffer.from(message));
        const signedMessageString = (await signedMessage).toString('hex');
        return signedMessageString;
    }
    async verifyMessage(message, signature, publicKey) {
        const decodedAddress = bech32_1.default.decode(publicKey);
        const publicKeyBuffer = Buffer.from(bech32_1.default.fromWords(decodedAddress.words));
        const address = new sdk_core_1.Address(publicKeyBuffer);
        const userVerifier = sdk_core_1.UserVerifier.fromAddress(address);
        const isVerified = userVerifier.verify(Buffer.from(message), Buffer.from(signature, 'hex'));
        return isVerified;
    }
    // SECTION: Writes
    /**
     * Signs a single transaction. Calls `signTransactions` with a single transaction and returns the first element of the result.
     * @returns The signed transaction as a plain object
     */
    async signTransaction(transaction, options) {
        const txs = await this.signTransactions([transaction], options);
        return txs[0];
    }
    async addTxNonces(transactions) {
        (0, core_1.required)(this.provider, "Provider not connected");
        // INFO: Retrieve account on network to get nonce
        const senderBech32 = this.getAddress();
        const senderAddress = new sdk_core_1.Address(senderBech32);
        const account = new sdk_core_1.Account(senderAddress);
        const senderOnNetwork = await this.provider.getAccount(senderAddress);
        account.update(senderOnNetwork);
        // INFO: Local nonce management
        // LINK: https://docs.multiversx.com/integrators/creating-transactions/#nonce-management
        let currentNonce = account.nonce.valueOf();
        transactions.forEach(tx => {
            tx.setNonce(currentNonce);
            // INFO: Increment the nonce for the next tx
            currentNonce++;
        });
        return transactions;
    }
    /**
     * Signs multiple transactions
     * @returns The signed transactions as an array of plain objects
     */
    async signTransactions(transactions, options) {
        (0, core_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        // INFO: Override wallet connection
        if (options?.privateKey) {
            await this.connectWallet(options.privateKey, {
                password: options.password,
            });
        }
        transactions = await this.addTxNonces(transactions);
        for (const tx of transactions) {
            const serializedTx = tx.serializeForSigning();
            const txSign = await this.wallet.sign(serializedTx);
            tx.applySignature(txSign);
        }
        return transactions.map(tx => {
            // INFO: Return plain objects
            return tx.toSendable();
        });
    }
    async preparePay(address, amount) {
        const txs = await this.preparePays([{ address, amount }]);
        return txs[0];
    }
    async preparePays(payments) {
        (0, core_1.required)(this.wallet);
        const sender = this.getAddress();
        const senderAddress = new sdk_core_1.Address(sender);
        const transactions = payments.map(payment => {
            const transfer = sdk_core_1.TokenTransfer.egldFromAmount(payment.amount);
            const receiverAddress = new sdk_core_1.Address(payment.address);
            const factory = new sdk_core_1.TransferTransactionsFactory(new sdk_core_1.GasEstimator());
            return factory.createEGLDTransfer({
                value: transfer,
                sender: senderAddress,
                receiver: receiverAddress,
                chainID: this.chainId,
            });
        });
        return this.signTransactions(transactions);
    }
    // SECTION Unimplemented methods
    getEmptyTransaction() {
        throw new Error("Method not implemented.");
    }
}
exports.MULTIVERSX = MULTIVERSX;
//# sourceMappingURL=multiversx.js.map