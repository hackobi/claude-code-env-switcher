"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SOLANA = void 0;
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
// nacl is needed for signing and verifying messages
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const tweetnacl_util_1 = require("tweetnacl-util");
const bs58_1 = __importDefault(require("bs58"));
const bip39 = __importStar(require("bip39"));
const micro_ed25519_hdkey_1 = require("micro-ed25519-hdkey");
const buffer_layout_1 = require("@solana/buffer-layout");
const defaultChain_1 = require("./types/defaultChain");
const utils_1 = require("./utils");
class SOLANA extends defaultChain_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.name = "solana";
    }
    setRpc(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = new web3_js_1.Connection(this.rpc_url, {
            confirmTransactionInitialTimeout: 15000,
        });
    }
    async connect() {
        try {
            const version = await this.provider.getVersion();
            this.connected = Number.isInteger(version["feature-set"]);
        }
        catch (error) {
            this.connected = false;
        }
        return this.connected;
    }
    // async disconnect() {
    //     this.resetInstance()
    //     return true
    // }
    async createWallet() {
        const keypair = web3_js_1.Keypair.generate();
        return {
            address: keypair.publicKey.toBase58(),
            secretKey: bs58_1.default.encode(keypair.secretKey),
            keypair: keypair,
        };
    }
    // ANCHOR Public methods
    async connectWallet(privateKey, accountIndex = 0) {
        privateKey = privateKey.trim();
        // INFO: Check if the input is a mnemonic phrase (contains spaces)
        const isMnemonic = privateKey.includes(" ");
        // INFO: Derive as BIP44 format
        if (isMnemonic) {
            // INFO: Convert mnemonic to seed using BIP39
            const seed = bip39.mnemonicToSeedSync(privateKey, "");
            // INFO: Create HD key from master seed
            const hd = micro_ed25519_hdkey_1.HDKey.fromMasterSeed(seed.toString("hex"));
            // INFO: Derive keypair using Solana BIP44 path: m/44'/501'/{accountIndex}'/0'
            const path = `m/44'/501'/${accountIndex}'/0'`;
            this.wallet = web3_js_1.Keypair.fromSeed(hd.derive(path).privateKey);
            return this.wallet;
        }
        // INFO: Treat as base58 encoded private key
        const pkBuffer = bs58_1.default.decode(privateKey);
        this.wallet = web3_js_1.Keypair.fromSecretKey(pkBuffer);
        return this.wallet;
    }
    async getBalance(address) {
        const publicKey = new web3_js_1.PublicKey(address);
        const balance = await this.provider.getBalance(publicKey);
        return balance.toString();
    }
    // Signing messages using tweetnacl and a keypair
    async signMessage(message, options) {
        (0, utils_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        // Encoding the message
        const messageBytes = (0, tweetnacl_util_1.decodeUTF8)(message);
        let signers = [this.wallet];
        if (options?.privateKey) {
            const privateKeyBuffer = bs58_1.default.decode(options.privateKey);
            const keypair = web3_js_1.Keypair.fromSecretKey(privateKeyBuffer);
            signers = [keypair];
        }
        // Signing the message
        const signedBytes = tweetnacl_1.default.sign.detached(messageBytes, signers[0].secretKey);
        return (0, tweetnacl_util_1.encodeBase64)(signedBytes);
    }
    // Verifying messages using tweetnacl and a keypair
    async verifyMessage(message, signature, publicKey) {
        // converting base58 to bytes
        const messageBytes = (0, tweetnacl_util_1.decodeUTF8)(message);
        const publicKeyBytes = bs58_1.default.decode(publicKey);
        const signatureBytes = (0, tweetnacl_util_1.decodeBase64)(signature);
        // verifying the message
        return tweetnacl_1.default.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes);
    }
    async signTransaction(tx, options) {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        // LINK https://docs.shyft.to/tutorials/how-to-sign-transactions-on-solana
        // NOTE Due to the above, the transaction is signed and sent at the same time.
        // tx.addSignature()
        const txs = await this.signTransactions([tx], options);
        return txs[0];
    }
    async signTransactions(transactions, options) {
        (0, utils_1.required)(this.wallet || (options && options.privateKey), "Wallet not connected");
        let signers = [this.wallet];
        if (options && options.privateKey) {
            const privateKeyBuffer = bs58_1.default.decode(options.privateKey);
            const keypair = web3_js_1.Keypair.fromSecretKey(privateKeyBuffer);
            signers = [keypair];
        }
        return transactions.map(tx => {
            tx.sign(signers);
            return tx.serialize();
        });
    }
    getAddress() {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        return this.wallet.publicKey.toBase58();
    }
    getEmptyTransaction() {
        const vmsg = new web3_js_1.TransactionMessage({
            payerKey: this.wallet.publicKey,
            recentBlockhash: "",
            instructions: [],
        }).compileToV0Message();
        return new web3_js_1.VersionedTransaction(vmsg);
    }
    async preparePay(receiver, amount, options) {
        const tx = await this.preparePays([{ address: receiver, amount }], options);
        return tx[0];
    }
    async preparePays(payments, options) {
        const blockInfo = await this.provider.getLatestBlockhash();
        const transactions = payments.map(payment => {
            // create a transfer instruction
            const transferIx = web3_js_1.SystemProgram.transfer({
                fromPubkey: this.wallet.publicKey,
                toPubkey: new web3_js_1.PublicKey(payment.address),
                lamports: parseFloat(payment.amount) * web3_js_1.LAMPORTS_PER_SOL,
            });
            // compile the instruction into a message
            const vmsg = new web3_js_1.TransactionMessage({
                instructions: [transferIx],
                payerKey: this.wallet.publicKey,
                recentBlockhash: blockInfo.blockhash,
            }).compileToV0Message();
            // create a versioned transaction
            return new web3_js_1.VersionedTransaction(vmsg);
        });
        // sign the transactions
        return this.signTransactions(transactions, options);
    }
    // SECTION: Programs
    async getProgramIdl(programId) {
        const provider = {
            connection: this.provider,
        };
        // @ts-ignore
        return await anchor_1.Program.fetchIdl(programId, provider);
    }
    async fetchAccount(address, options) {
        let programId = options.programId;
        let idl = options.idl;
        if (!programId) {
            // INFO: Fetch the program ID from the account
            const accInfo = await this.provider.getAccountInfo(new web3_js_1.PublicKey(address));
            programId = accInfo.owner;
        }
        if (!idl) {
            // INFO: Fetch the IDL from the network
            idl = await this.getProgramIdl(options.programId);
        }
        const program = new anchor_1.Program(idl, programId, {
            // @ts-ignore
            connection: this.provider,
        });
        return await program.account[options.name].fetch(address);
    }
    async runAnchorProgram(programId, params) {
        // REVIEW: Do we need to connect our wallet with the anchor provider?
        const pid = new web3_js_1.PublicKey(programId);
        // @ts-ignore
        const anchorProvider = new anchor_1.AnchorProvider(this.provider, null, {});
        let idl = params.idl;
        if (!idl) {
            // INFO: If not using manual IDL, fetch it from the network
            idl = await this.getProgramIdl(programId);
        }
        if (!idl) {
            // INFO: If no IDL is found, throw an error
            throw new Error("No IDL found for this program");
        }
        // INFO: Get the IDL and create program interface
        const program = new anchor_1.Program(idl, pid, anchorProvider);
        // INFO: construct the transaction
        const ix = program.methods[params.instruction];
        // calling the method with undefined throws an error, so prevent it
        const _ix = params.args ? ix(params.args) : ix();
        const tx = await _ix.accounts(params.accounts).transaction();
        // INFO: Add fee payer and validity data
        tx.feePayer = params.feePayer;
        const block = await this.provider.getLatestBlockhash();
        tx.recentBlockhash = block.blockhash;
        tx.lastValidBlockHeight = block.lastValidBlockHeight;
        // INFO: Sign and return the tx
        tx.sign(...params.signers);
        return tx.serialize();
    }
    async runRawProgram(programId, params) {
        // INFO: Set fee payer
        const tx = new web3_js_1.Transaction({
            feePayer: params.feePayer,
        });
        // INFO: Locate the instruction
        const ix = {
            index: params.instructionIndex,
            // @ts-expect-error
            layout: (0, buffer_layout_1.struct)([(0, buffer_layout_1.u32)("instruction"), (0, buffer_layout_1.ns64)(params.instructionName)]),
        };
        // INFO: Encode the instruction and its parameters
        // Create an empty buffer
        let data = Buffer.alloc(ix.layout.span);
        let layoutFields = Object.assign({
            instruction: ix.index,
        }, params.params);
        // Write the data to the buffer
        ix.layout.encode(layoutFields, data);
        // INFO: Add the instruction to the transaction
        tx.add(new web3_js_1.TransactionInstruction({
            keys: params.keys,
            programId: new web3_js_1.PublicKey(programId),
            data: data,
        }));
        // INFO: Add validity information
        const block = await this.provider.getLatestBlockhash();
        tx.recentBlockhash = block.blockhash;
        tx.lastValidBlockHeight = block.lastValidBlockHeight;
        // INFO: Sign and return the transaction
        tx.sign(...params.signers);
        return tx.serialize();
    }
    // SECTION: Singleton methods
    static getInstance() {
        if (!SOLANA.instance) {
            return null;
        }
        return SOLANA.instance;
    }
    static createInstance(rpc_url) {
        if (!SOLANA.instance) {
            SOLANA.instance = new SOLANA(rpc_url);
        }
        return SOLANA.instance;
    }
}
exports.SOLANA = SOLANA;
//# sourceMappingURL=solana.js.map