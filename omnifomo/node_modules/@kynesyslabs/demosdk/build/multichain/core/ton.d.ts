import { Cell, TonClient, WalletContractV5R1 } from "@ton/ton";
import { KeyPair } from "@ton/crypto";
import { IPayOptions } from ".";
import { DefaultChain } from "./types/defaultChain";
export declare class TON extends DefaultChain {
    provider: TonClient;
    signer: KeyPair;
    wallet: WalletContractV5R1;
    constructor(rpc_url: string);
    setRpc(rpc_url: string): void;
    connect(): Promise<boolean>;
    connectWallet(mnemonics: string): Promise<WalletContractV5R1>;
    getAddress(): string;
    getPublicKey(): string | undefined;
    getBalance(address: string): Promise<string>;
    signMessage(message: string, options?: {
        privateKey?: string;
    }): Promise<string>;
    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;
    signTransaction(tx: Cell): Promise<Cell>;
    signTransactions(txs: Cell[]): Promise<Cell[]>;
    preparePay(receiver: string, amount: string, options?: {
        /**
         * A private key mnemonic to use for signing the transaction(s) instead of the connected wallet
         */
        privateKey: string;
    }): Promise<Buffer<ArrayBufferLike>>;
    preparePays(payments: IPayOptions[], options?: {
        /**
         * A private key mnemonic to use for signing the transaction(s) instead of the connected wallet
         */
        privateKey: string;
    }): Promise<Buffer<ArrayBufferLike>[]>;
    /**
     * Prepare a cell to be sent to the network.
     *
     * @param cell The cell to convert to a sendable file
     * @returns The cell as a sendable file
     */
    cellsToSendableFile(cells: Cell[]): Promise<Buffer<ArrayBufferLike>[]>;
    getEmptyTransaction(): Promise<import("@ton/ton").Builder>;
    /**
     * Estimate the transaction fee for a transfer
     * @param receiver The recipient address
     * @param amount The amount in TON (not nanotons)
     * @returns Fee estimate in nanotons as bigint
     */
    estimateFee(receiver: string, amount: string): Promise<bigint>;
}
