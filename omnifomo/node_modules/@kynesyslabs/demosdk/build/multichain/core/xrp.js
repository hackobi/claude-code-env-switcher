"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XRPL = void 0;
exports.xrplGetLastSequence = xrplGetLastSequence;
const xrpl_1 = require("xrpl");
const core_1 = require("./");
const ripple_keypairs_1 = require("ripple-keypairs");
/**
 * Get the last sequence number of an address
 * @param address The address
 * @returns The last sequence number
 */
async function xrplGetLastSequence(provider, address) {
    // INFO: Get user's current sequence
    // Code extracted from the xrpl library
    // By following this.provider.autofill
    const request = {
        command: 'account_info',
        account: address,
        ledger_index: 'current',
    };
    const account_info = await provider.request(request);
    const currentSequence = account_info.result.account_data.Sequence;
    return currentSequence;
}
class XRPL extends core_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.name = 'xrpl';
        if (rpc_url) {
            this.setRpc(rpc_url);
        }
    }
    // SECTION: Providers
    // INFO Set of methods for connecting to an RPC while
    // retaining a granular control over the instance status
    async setRpc(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = new xrpl_1.Client(rpc_url, {
            connectionTimeout: 10000,
        });
    }
    async connect(with_reconnect = true) {
        // INFO Connects to the provider with error handling
        let trial_index = 0;
        let maxTrials = 3;
        const providerConnect = async () => {
            try {
                await this.provider.connect();
                return true;
            }
            catch (error) {
                trial_index++;
                if (trial_index == maxTrials) {
                    // INFO: Return false if we failed to connect
                    return false;
                }
                // INFO: Retry for the Nth time
                await providerConnect();
            }
            return false;
        };
        // Listen for connection events
        this.provider.on('connected', () => {
            console.log('Successfully connected to XRPL.');
            this.connected = true;
        });
        // Handle disconnection events
        // INFO: with_reconnect = false is used to exit tests without open handles
        if (with_reconnect) {
            this.provider.on('disconnected', async (code) => {
                // Handle the disconnection event (e.g., attempt to reconnect)
                console.log(`Disconnected from XRPL with code: ${code}, reconnecting: ${with_reconnect}`);
                this.connected = false;
                this.connected = await providerConnect();
            });
        }
        // Handle errors
        this.provider.on('error', (errorCode, errorMessage, data) => {
            console.log(`XRPL Client Error: ${errorCode}, ${errorMessage}`);
            // Handle the error based on errorCode and errorMessage
        });
        // Finally, connect to the provider
        this.connected = await providerConnect();
        return this.connected;
    }
    // SECTION: Wallets
    // INFO Connecting a wallet through a private key (string)
    async connectWallet(privateKey) {
        this.wallet = xrpl_1.Wallet.fromSeed(privateKey);
        return this.wallet;
    }
    getAddress() {
        return this.wallet.address;
    }
    // SECTION: Reads
    // REVIEW: getBalance return type. Should it be a string or an object?
    async getBalance(address, multi = true) {
        let response = null;
        if (multi) {
            response = await this.provider.getBalances(address);
        }
        else {
            response = await this.provider.getXrpBalance(address);
        }
        return response;
    }
    async signMessage(message, options) {
        (0, core_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        const hexMessage = (0, xrpl_1.convertStringToHex)(message);
        const privateKey = this.wallet.privateKey;
        let formattedPrivateKey = privateKey;
        if (privateKey.startsWith('0x')) {
            formattedPrivateKey = privateKey.slice(2);
        }
        const signedMessage = (0, ripple_keypairs_1.sign)(hexMessage, formattedPrivateKey);
        return signedMessage;
    }
    async verifyMessage(message, signature, publicKey) {
        const hexMessage = (0, xrpl_1.convertStringToHex)(message);
        const isValid = (0, ripple_keypairs_1.verify)(hexMessage, signature, publicKey);
        return isValid;
    }
    // SECTION: Writes
    // INFO Signing a transaction
    // with a private key or by using our stored wallet
    async signTransaction(transaction, options) {
        // INFO: Call signTransactions with a single transaction
        const txs = await this.signTransactions([transaction], options);
        return txs[0];
    }
    async signTransactions(transactions, options) {
        // INFO: If a private key is provided, override the wallet
        // REVIEW: Should we assign the new wallet to this.wallet?
        if (options?.privateKey) {
            this.wallet = xrpl_1.Wallet.fromSeed(options.privateKey);
        }
        // INFO: Check if wallet is connected
        (0, core_1.required)(this.wallet, 'Wallet not connected');
        let currentSequence = await xrplGetLastSequence(this.provider, this.getAddress());
        return transactions.map((tx) => {
            tx.Sequence = currentSequence;
            // INFO: Increment the sequence for the next transaction
            currentSequence++;
            // NOTE: this.wallet.sign is not async
            return this.wallet.sign(tx);
        });
    }
    async preparePay(address, amount) {
        (0, core_1.required)(this.wallet, 'Wallet not connected');
        // INFO: Call preparePays with a single payment
        const txs = await this.preparePays([{ address, amount }]);
        return txs[0];
    }
    async preparePays(payments) {
        const base_tx = await this.getEmptyTransaction();
        const txs = payments.map((payment) => {
            // Copy the base tx
            const tx = {
                ...base_tx,
                // Set amount and destination
                Destination: payment.address,
                Amount: (0, xrpl_1.xrpToDrops)(payment.amount),
                // INFO: Sequence number will be set by this.signTransactions
            };
            return tx;
        });
        // INFO: Return a list of signed transactions
        return this.signTransactions(txs);
    }
    // SECTION: Utils
    // INFO Generic empty tx skeleton for this chain
    async getEmptyTransaction() {
        // INFO: Autofill the transaction
        const tx = await this.provider.autofill({
            TransactionType: 'Payment',
            Account: this.getAddress(),
            Amount: (0, xrpl_1.xrpToDrops)(0),
            Destination: '',
            Sequence: 0,
        });
        return tx;
    }
    async disconnect() {
        await this.provider.disconnect();
        this.resetInstance();
        return !this.connected;
    }
}
exports.XRPL = XRPL;
//# sourceMappingURL=xrp.js.map