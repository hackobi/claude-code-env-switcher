"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TON = void 0;
const ton_1 = require("@ton/ton");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const crypto_1 = require("@ton/crypto");
const _1 = require(".");
const defaultChain_1 = require("./types/defaultChain");
class TON extends defaultChain_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.name = "ton";
    }
    setRpc(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = new ton_1.TonClient({
            endpoint: this.rpc_url,
        });
    }
    async connect() {
        try {
            const info = await this.provider.getMasterchainInfo();
            this.connected = !!info;
        }
        catch (error) {
            this.connected = false;
        }
        return this.connected;
    }
    async connectWallet(mnemonics) {
        const mnemonicArray = mnemonics.trim().split(/\s+/);
        // Validate mnemonic - must be exactly 24 words and valid TON mnemonic
        if (mnemonicArray.length !== 24) {
            throw new Error(`Invalid mnemonic: expected 24 words, got ${mnemonicArray.length}`);
        }
        const isValid = await (0, crypto_1.mnemonicValidate)(mnemonicArray);
        if (!isValid) {
            throw new Error("Invalid TON mnemonic: validation failed");
        }
        try {
            this.signer = await (0, crypto_1.mnemonicToPrivateKey)(mnemonicArray);
            this.wallet = ton_1.WalletContractV5R1.create({
                publicKey: this.signer.publicKey,
                workchain: 0,
            });
            return this.wallet;
        }
        catch (error) {
            console.error("[TON SDK] connectWallet error:", error);
            throw error;
        }
    }
    // SECTION: Information
    getAddress() {
        return this.wallet.address.toString({ urlSafe: true, bounceable: false });
    }
    getPublicKey() {
        if (!this.signer?.publicKey) {
            return undefined;
        }
        return this.signer.publicKey.toString('hex');
    }
    async getBalance(address) {
        const addr = ton_1.Address.parse(address);
        const bal = await this.provider.getBalance(addr);
        return new bignumber_js_1.default(bal).toString();
    }
    async signMessage(message, options) {
        (0, _1.required)(this.signer || options?.privateKey, "Wallet not connected");
        const messageBuffer = Buffer.from(message, 'utf-8');
        const secretKey = this.signer.secretKey;
        const signatureBuffer = (0, crypto_1.sign)(messageBuffer, secretKey);
        const signedMessage = signatureBuffer.toString('base64');
        return signedMessage;
    }
    async verifyMessage(message, signature, publicKey) {
        const messageBuffer = Buffer.from(message, 'utf-8');
        const signatureBuffer = Buffer.from(signature, 'base64');
        const publicKeyBuffer = Buffer.from(publicKey, 'hex');
        const isVerified = (0, crypto_1.signVerify)(messageBuffer, signatureBuffer, publicKeyBuffer);
        return isVerified;
    }
    // SECTION: Transactions
    async signTransaction(tx) {
        const txs = await this.signTransactions([tx]);
        return txs[0];
    }
    async signTransactions(txs) {
        // TODO: Test this method
        // NOTE: preparePay signs the tx so this method is not used
        return txs.map(tx => {
            const signature = (0, crypto_1.sign)(txs[0].hash(), this.signer.secretKey);
            return (0, ton_1.beginCell)()
                .storeBuffer(signature)
                .storeBuilder(tx.asBuilder())
                .endCell();
        });
    }
    async preparePay(receiver, amount, options) {
        const txs = await this.preparePays([{ address: receiver, amount }], options);
        return txs[0];
    }
    async preparePays(payments, options) {
        (0, _1.required)(this.signer || options?.privateKey, "Wallet not connected");
        let signer = this.signer;
        if (options?.privateKey) {
            signer = await (0, crypto_1.mnemonicToPrivateKey)(options.privateKey.split(" "));
        }
        const contract = this.provider.open(this.wallet);
        let seqNo = await contract.getSeqno();
        const txs = payments.map(payment => {
            const cell = contract.createTransfer({
                seqno: seqNo,
                secretKey: signer.secretKey,
                sendMode: ton_1.SendMode.PAY_GAS_SEPARATELY,
                messages: [
                    (0, ton_1.internal)({
                        value: (0, ton_1.toNano)(payment.amount),
                        to: payment.address,
                        bounce: true,
                    }),
                ],
            });
            seqNo++;
            return cell;
        });
        return await this.cellsToSendableFile(txs);
    }
    /**
     * Prepare a cell to be sent to the network.
     *
     * @param cell The cell to convert to a sendable file
     * @returns The cell as a sendable file
     */
    async cellsToSendableFile(cells) {
        // NOTE: All this is done to retrieve the the final tx hash
        const contract = this.provider.open(this.wallet);
        let neededInit = null;
        const address = ton_1.Address.parse(this.getAddress());
        const isContractDeployed = await this.provider.isContractDeployed(address);
        if (contract.init && !isContractDeployed) {
            neededInit = contract.init;
        }
        return cells.map(cell => {
            // INFO: Create an external message
            const ext = (0, ton_1.external)({
                to: this.getAddress(),
                init: neededInit,
                body: cell,
            });
            // INFO: Create a new cell with the external message
            let boc = (0, ton_1.beginCell)().store((0, ton_1.storeMessage)(ext)).endCell();
            // INFO: Convert the cell to a buffer for network transmission
            return boc.toBoc();
        });
    }
    async getEmptyTransaction() {
        return (0, ton_1.beginCell)();
    }
    /**
     * Estimate the transaction fee for a transfer
     * @param receiver The recipient address
     * @param amount The amount in TON (not nanotons)
     * @returns Fee estimate in nanotons as bigint
     */
    async estimateFee(receiver, amount) {
        (0, _1.required)(this.signer, "Wallet not connected");
        const contract = this.provider.open(this.wallet);
        const seqNo = await contract.getSeqno();
        const transfer = contract.createTransfer({
            seqno: seqNo,
            secretKey: this.signer.secretKey,
            sendMode: ton_1.SendMode.PAY_GAS_SEPARATELY,
            messages: [
                (0, ton_1.internal)({
                    value: (0, ton_1.toNano)(amount),
                    to: receiver,
                    bounce: true,
                }),
            ],
        });
        const estimate = await this.provider.estimateExternalMessageFee(this.wallet.address, { body: transfer, initCode: null, initData: null, ignoreSignature: true });
        // Sum all fee components
        const totalFee = BigInt(estimate.source_fees.in_fwd_fee) +
            BigInt(estimate.source_fees.storage_fee) +
            BigInt(estimate.source_fees.gas_fee) +
            BigInt(estimate.source_fees.fwd_fee);
        // Add 10% buffer for safety margin
        return (totalFee * 110n) / 100n;
    }
}
exports.TON = TON;
//# sourceMappingURL=ton.js.map