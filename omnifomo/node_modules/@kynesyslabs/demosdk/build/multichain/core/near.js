"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NEAR = void 0;
const near_api_js_1 = require("near-api-js");
const big_integer_1 = __importDefault(require("big-integer"));
const websdk_1 = require("../../websdk");
const defaultChain_1 = require("./types/defaultChain");
const transaction_1 = require("near-api-js/lib/transaction");
const utils_1 = require("@near-js/utils");
const bip39 = __importStar(require("@scure/bip39"));
const bytes_1 = require("@project-serum/anchor/dist/cjs/utils/bytes");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const tweetnacl_util_1 = require("tweetnacl-util");
const ed25519_hd_key_1 = require("ed25519-hd-key");
// NEAR BIP44 derivation path (coin type 397)
const NEAR_DERIVATION_PATH = "m/44'/397'/0'";
class NEAR extends defaultChain_1.DefaultChain {
    constructor(rpc_url, networkId = "testnet") {
        super(rpc_url);
        this.actions = near_api_js_1.transactions;
        this.name = "near";
        this.networkId = networkId;
        this.setRpc(rpc_url, networkId);
    }
    static async create(rpc_url) {
        const instance = new this(rpc_url);
        if (rpc_url) {
            await instance.connect();
        }
        return instance;
    }
    setRpc(rpc_url, networkId = "testnet") {
        this.rpc_url = rpc_url;
        this.networkId = networkId;
        this.provider = new near_api_js_1.Near({
            networkId: this.networkId,
            nodeUrl: this.rpc_url,
        });
    }
    async connect() {
        try {
            const status = await this.provider.connection.provider.status();
            this.connected = !!status;
        }
        catch (error) {
            console.error(error);
            this.connected = false;
        }
        return this.connected;
    }
    getAddress() {
        return this.wallet.getPublicKey().toString();
    }
    async getBalance(address, options) {
        const account = await this.provider.account(address);
        const balance = await account.getAccountBalance();
        return balance.total;
    }
    async connectWallet(privateKey, options) {
        (0, websdk_1._required)(options && options.accountId, "AccountId is required");
        const seed = bip39.mnemonicToSeedSync(privateKey);
        const seedHex = Buffer.from(seed).toString('hex');
        const { key: derivedKey } = (0, ed25519_hd_key_1.derivePath)(NEAR_DERIVATION_PATH, seedHex);
        const base58PrivateKey = bytes_1.bs58.encode(derivedKey);
        this.wallet = near_api_js_1.KeyPair.fromString(`ed25519:${base58PrivateKey}`);
        this.accountId = options.accountId;
        this.networkId = options?.networkId;
        this.signer = await near_api_js_1.InMemorySigner.fromKeyPair(this.networkId, this.accountId, this.wallet);
        return this.wallet;
    }
    async preparePays(payments, options) {
        (0, websdk_1._required)(this.wallet, "Wallet not connected");
        (0, websdk_1._required)(this.accountId, "AccountId is required");
        const txs = payments.map(payment => {
            const parsed = (0, utils_1.parseNearAmount)(payment.amount);
            const amount = parseFloat(parsed);
            const tx = new transaction_1.Transaction({
                receiverId: payment.address,
                actions: [near_api_js_1.transactions.transfer((0, big_integer_1.default)(amount))],
                signerId: this.accountId,
                publicKey: this.wallet.getPublicKey(),
            });
            return tx;
        });
        return await this.signTransactions(txs);
    }
    async signTransactions(txs, options) {
        (0, websdk_1._required)(this.signer, "Wallet not connected");
        (0, websdk_1._required)(this.accountId, "AccountId is required");
        const publicKey = this.wallet.getPublicKey().toString();
        const account = await this.provider.account(this.accountId);
        const info = await account.getAccessKeys();
        let currentNonce = info.find(key => key.public_key === publicKey)
            ?.access_key.nonce;
        if (!currentNonce) {
            throw new Error("Failed to get the account nonce for accountId: " +
                this.accountId);
        }
        const block = await this.provider.connection.provider.block({
            finality: "final",
        });
        const lastBlockHash = block.header.hash;
        return Promise.all(txs.map(async (tx) => {
            currentNonce = (0, big_integer_1.default)(currentNonce).add(1);
            tx.nonce = currentNonce;
            tx.blockHash = (0, utils_1.baseDecode)(lastBlockHash);
            const res = await near_api_js_1.transactions.signTransaction(tx, this.signer, this.accountId, this.networkId);
            // INFO: The `signTransaction` method returns an array with the hash and the signed tx
            // We return the signed tx
            return res[1].encode();
        }));
    }
    async preparePay(receiver, amount, options) {
        const txs = await this.preparePays([{ address: receiver, amount }], options);
        return txs[0];
    }
    async signTransaction(tx, options) {
        const txs = await this.signTransactions([tx], options);
        return txs[0];
    }
    getEmptyTransaction() {
        (0, websdk_1._required)(this.accountId, "AccountId is required");
        (0, websdk_1._required)(this.wallet, "Wallet not connected");
        return new transaction_1.Transaction({
            receiverId: "",
            actions: [],
            nonce: null,
            signerId: this.accountId,
            blockHash: "",
            publicKey: this.wallet.getPublicKey(),
        });
    }
    /**
     * Create a new account
     * @param accountId The new accountId
     * @param amount The amount of â“ƒ to deposit to the new account
     * @param options Specify the curve to use when generating the key pair for the new account
     * @returns The signed transaction for creating the new account on Near, and its key pair
     */
    async createAccount(accountId, amount, options) {
        const newAccountKey = near_api_js_1.KeyPair.fromRandom(options?.curve || "ed25519");
        const tx = this.getEmptyTransaction();
        tx.receiverId = accountId;
        tx.actions = [
            near_api_js_1.transactions.createAccount(),
            near_api_js_1.transactions.transfer((0, big_integer_1.default)((0, utils_1.parseNearAmount)(amount))),
            near_api_js_1.transactions.addKey(newAccountKey.getPublicKey(), near_api_js_1.transactions.fullAccessKey()),
        ];
        const signedTx = await this.signTransaction(tx);
        return {
            signedTx,
            keyPair: newAccountKey,
        };
    }
    async deleteAccount(beneficiallyId) {
        const tx = this.getEmptyTransaction();
        tx.receiverId = beneficiallyId;
        tx.actions = [near_api_js_1.transactions.deleteAccount(beneficiallyId)];
        return await this.signTransaction(tx);
    }
    // INFO Signing a message
    async signMessage(message, options) {
        (0, websdk_1._required)(this.wallet || options?.privateKey, "Wallet not connected");
        let wallet = this.wallet;
        const messageBytes = (0, tweetnacl_util_1.decodeUTF8)(message);
        const signature = wallet.sign(messageBytes);
        const signatureString = near_api_js_1.utils.serialize.base_encode(signature.signature);
        return signatureString;
    }
    // INFO Verifying a message
    async verifyMessage(message, signature, publicKey) {
        const signatureDecoded = near_api_js_1.utils.serialize.base_decode(signature);
        const publicKeyObject = near_api_js_1.utils.key_pair.PublicKey.from(publicKey);
        const publicKeyRaw = Object.values(publicKeyObject.ed25519Key.data);
        const publicKeyDecoded = new Uint8Array(publicKeyRaw);
        const messageBytes = (0, tweetnacl_util_1.decodeUTF8)(message);
        const isValid = tweetnacl_1.default.sign.detached.verify(messageBytes, signatureDecoded, publicKeyDecoded);
        return isValid;
    }
}
exports.NEAR = NEAR;
//# sourceMappingURL=near.js.map