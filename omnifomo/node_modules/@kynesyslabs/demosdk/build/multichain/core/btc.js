"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BTC = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bip32_1 = require("bip32");
const bip39 = __importStar(require("bip39"));
const secp256k1_1 = __importDefault(require("@bitcoinerlab/secp256k1"));
const bitcoinMessage = __importStar(require("bitcoinjs-message"));
const utils_1 = require("./utils");
const axios_1 = __importDefault(require("axios"));
const ecpair_1 = require("ecpair");
const defaultChain_1 = require("./types/defaultChain");
const ECPair = (0, ecpair_1.ECPairFactory)(secp256k1_1.default);
const bip32 = (0, bip32_1.BIP32Factory)(secp256k1_1.default);
const BITCOIN_CONSTANTS = {
    DUST_LIMIT_P2WPKH: 294,
    BASE_TX_SIZE: 10,
    INPUT_SIZE: 68,
    OUTPUT_SIZE: 31,
    SAT_PER_VBYTE: 1,
    MAX_ATTEMPTS: 100,
    MAX_INDEX: 100,
    DEFAULT_NETWORK: bitcoin.networks.testnet,
    MAX_EMPTY: 5,
};
// @ts-expect-error
class BTC extends defaultChain_1.DefaultChain {
    constructor(rpc_url, network = BITCOIN_CONSTANTS.DEFAULT_NETWORK) {
        super(rpc_url);
        this.changeIndex = 0;
        this.lastUsedUtxos = [];
        this.usedChangeAddresses = new Set(); // For storing used change addresses
        this.name = "btc";
        this.provider = rpc_url;
        this.network = network;
    }
    /**
     * Infer the Bitcoin network from the RPC URL
     * Returns mainnet by default if URL is null/undefined/empty
     */
    static inferNetworkFromUrl(rpc_url) {
        if (!rpc_url) {
            return bitcoin.networks.bitcoin; // Default to mainnet for verification
        }
        const lowerUrl = rpc_url.toLowerCase();
        if (lowerUrl.includes("testnet") || lowerUrl.includes("test")) {
            return bitcoin.networks.testnet;
        }
        return bitcoin.networks.bitcoin; // mainnet
    }
    static async create(rpc_url, network) {
        const resolvedNetwork = network ?? BTC.inferNetworkFromUrl(rpc_url);
        const instance = new this(rpc_url ?? "", resolvedNetwork);
        if (rpc_url) {
            await instance.connect();
        }
        return instance;
    }
    async connect() {
        if (!this.rpc_url) {
            return false;
        }
        try {
            const url = this.getApiUrl("/blocks/tip/height");
            const response = await axios_1.default.get(url);
            this.connected = !!response.data;
            return this.connected;
        }
        catch (error) {
            console.error("BTC connection error:", error);
            this.connected = false;
            return false;
        }
    }
    /**
     * Generate a private key for the BTC chain
     * @param seed - The seed to generate the private key from (optional)
     * @returns The private key as a WIF string
     */
    generatePrivateKey(seed) {
        if (seed) {
            // Generate deterministic key from seed using BIP32
            // Use the SAME path for both mainnet and testnet (m/84'/0'/0'/0/0)
            // This matches most BTC wallets
            const root = bip32.fromSeed(seed, this.network);
            const path = "m/84'/0'/0'/0/0";
            const child = root.derivePath(path);
            return child.toWIF();
        }
        else {
            // Generate random key if no seed provided
            const keyPair = ECPair.makeRandom({ network: this.network });
            return keyPair.toWIF();
        }
    }
    async generateChangeAddress() {
        const seed = this.wallet.privateKey;
        const root = bip32.fromSeed(seed, this.network);
        let address;
        let attempts = 0;
        // Check if the address has been used before
        while (attempts < BITCOIN_CONSTANTS.MAX_ATTEMPTS) {
            const child = root.derivePath(`m/84'/1'/0'/1/${this.changeIndex}`);
            const payment = bitcoin.payments.p2wpkh({
                pubkey: Buffer.from(child.publicKey),
                network: this.network,
            });
            address = payment.address;
            // Check if there is a UTXO at this address (i.e., if it was used)
            const utxos = await this.fetchUTXOs(address);
            if (utxos.length === 0 && !this.usedChangeAddresses.has(address)) {
                this.usedChangeAddresses.add(address); // Add to the list of used addresses
                this.changeIndex++;
                return address;
            }
            this.changeIndex++;
            attempts++;
        }
        throw new Error("Failed to generate a unique change address after maximum attempts");
    }
    /**
     * Connect wallet using either a WIF private key or a BIP39 mnemonic phrase
     * @param privateKeyOrMnemonic - WIF private key or 12/24 word mnemonic phrase
     */
    async connectWallet(privateKeyOrMnemonic) {
        try {
            // Check if input is a mnemonic (contains spaces and valid word count)
            const words = privateKeyOrMnemonic.trim().split(/\s+/);
            const isMnemonic = (words.length === 12 || words.length === 24) && bip39.validateMnemonic(privateKeyOrMnemonic.trim());
            if (isMnemonic) {
                // Derive key from mnemonic using BIP84 path (native SegWit)
                const seed = bip39.mnemonicToSeedSync(privateKeyOrMnemonic.trim());
                const root = bip32.fromSeed(seed, this.network);
                const path = "m/84'/0'/0'/0/0";
                const child = root.derivePath(path);
                if (!child.privateKey) {
                    throw new Error("Failed to derive private key from mnemonic.");
                }
                this.wallet = ECPair.fromPrivateKey(child.privateKey, { network: this.network });
            }
            else {
                // Assume WIF format
                this.wallet = ECPair.fromWIF(privateKeyOrMnemonic, this.network);
            }
            const { address } = bitcoin.payments.p2wpkh({
                pubkey: Buffer.from(this.wallet.publicKey),
                network: this.network,
            });
            this.address = address;
            return this.wallet;
        }
        catch (error) {
            throw new Error(`Failed to connect wallet: ${error}`);
        }
    }
    getAddress() {
        (0, utils_1.required)(this.address, "Wallet not connected");
        return this.address;
    }
    getApiUrl(path) {
        const baseUrl = this.provider.replace(/\/api$/, "");
        return `${baseUrl}/api${path}`;
    }
    async fetchUTXOs(address) {
        try {
            const url = this.getApiUrl(`/address/${address}/utxo`);
            const response = await axios_1.default.get(url);
            const utxos = response.data || [];
            return utxos;
        }
        catch (error) {
            throw new Error(`Error receiving UTXOs: ${error}`);
        }
    }
    async fetchAllUTXOs() {
        const mainAddressUTXOs = await this.fetchUTXOs(this.getAddress());
        const seed = this.wallet.privateKey;
        const root = bip32.fromSeed(seed, this.network);
        let changeUTXOs = [];
        let i = 0;
        let emptyCount = 0;
        while (i < BITCOIN_CONSTANTS.MAX_INDEX &&
            emptyCount < BITCOIN_CONSTANTS.MAX_EMPTY) {
            const child = root.derivePath(`m/84'/1'/0'/1/${i}`);
            const { address } = bitcoin.payments.p2wpkh({
                pubkey: Buffer.from(child.publicKey),
                network: this.network,
            });
            const utxos = await this.fetchUTXOs(address);
            if (utxos.length === 0) {
                emptyCount++;
            }
            else {
                emptyCount = 0;
            }
            changeUTXOs = changeUTXOs.concat(utxos.map(utxo => ({
                ...utxo,
                derivedKey: child,
            })));
            i++;
        }
        return [...mainAddressUTXOs, ...changeUTXOs];
    }
    async getTxHex(txid) {
        try {
            const url = this.getApiUrl(`/tx/${txid}/hex`);
            const response = await axios_1.default.get(url);
            const txHex = response.data;
            return txHex;
        }
        catch (error) {
            throw new Error(`Failed to get transaction hex: ${error}`);
        }
    }
    toSigner(ecpair) {
        return {
            publicKey: Buffer.from(ecpair.publicKey),
            sign: (hash, lowR) => {
                const signature = ecpair.sign(hash, lowR);
                return Buffer.from(signature);
            },
        };
    }
    async preparePay(address, amount, overrideFeeRate, addNoise = false) {
        const txs = await this.preparePays([{ address, amount }], overrideFeeRate, addNoise);
        return txs[0];
    }
    async preparePays(payments, overrideFeeRate, addNoise = false) {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        let availableUtxos = await this.fetchAllUTXOs();
        const psbts = [];
        for (const payment of payments) {
            const { psbt, usedUtxos } = await this.createUnsignedPSBT(payment.address, payment.amount, availableUtxos, overrideFeeRate, addNoise);
            psbts.push(psbt);
            this.lastUsedUtxos = usedUtxos.map((u, i) => ({
                ...u,
                derivedKey: availableUtxos.find(utxo => utxo.txid === u.txid && utxo.vout === u.vout)?.derivedKey,
            }));
            availableUtxos = availableUtxos.filter(utxo => !usedUtxos.some(used => used.txid === utxo.txid && used.vout === utxo.vout));
        }
        return this.signTransactions(psbts);
    }
    async createUnsignedPSBT(address, amount, availableUtxos, overrideFeeRate, addNoise = false) {
        const amountNum = Number(amount);
        if (isNaN(amountNum) || amountNum <= 0)
            throw new Error("Incorrect amount");
        if (availableUtxos.length === 0)
            throw new Error("No UTXOs available");
        const psbt = new bitcoin.Psbt({ network: this.network });
        let totalInput = 0;
        let inputCount = 0;
        const usedUtxos = [];
        const inputAddresses = new Set(); // Store input addresses for verification
        const sortedUtxos = [...availableUtxos].sort((a, b) => b.value - a.value);
        const outputCount = addNoise ? 3 : 2;
        let estimatedFee = await this.calculateFee(1, outputCount, overrideFeeRate);
        for (const utxo of sortedUtxos) {
            const pubkey = utxo.derivedKey
                ? utxo.derivedKey.publicKey
                : this.wallet.publicKey;
            const p2wpkh = bitcoin.payments.p2wpkh({
                pubkey: Buffer.from(pubkey),
                network: this.network,
            });
            const utxoAddress = p2wpkh.address;
            inputAddresses.add(utxoAddress); // Save input address
            psbt.addInput({
                hash: utxo.txid,
                index: utxo.vout,
                witnessUtxo: {
                    script: p2wpkh.output,
                    value: utxo.value,
                },
                sequence: 0xfffffffe, // Enable RBF
            });
            totalInput += utxo.value;
            inputCount++;
            usedUtxos.push({ txid: utxo.txid, vout: utxo.vout });
            estimatedFee = await this.calculateFee(inputCount, outputCount, overrideFeeRate);
            if (totalInput >= amountNum + estimatedFee)
                break;
        }
        const finalFee = await this.calculateFee(inputCount, outputCount, overrideFeeRate);
        if (totalInput < amountNum + finalFee) {
            throw new Error(`Insufficient funds: There is ${totalInput}, need ${amountNum + finalFee}`);
        }
        psbt.addOutput({
            address,
            value: amountNum,
        });
        const change = totalInput - amountNum - finalFee;
        let remainingChange = change;
        if (addNoise &&
            remainingChange >= BITCOIN_CONSTANTS.DUST_LIMIT_P2WPKH * 2) {
            const noiseAmount = Math.floor(remainingChange / 3);
            if (noiseAmount >= BITCOIN_CONSTANTS.DUST_LIMIT_P2WPKH) {
                const noiseAddress = await this.generateChangeAddress();
                if (inputAddresses.has(noiseAddress)) {
                    throw new Error("Generated noise address matches an input address");
                }
                psbt.addOutput({
                    address: noiseAddress,
                    value: noiseAmount,
                });
                remainingChange -= noiseAmount;
            }
        }
        if (remainingChange >= BITCOIN_CONSTANTS.DUST_LIMIT_P2WPKH) {
            const changeAddress = await this.generateChangeAddress();
            if (inputAddresses.has(changeAddress)) {
                throw new Error("Generated change address matches an input address");
            }
            psbt.addOutput({
                address: changeAddress,
                value: remainingChange,
            });
        }
        else if (remainingChange > 0) {
            console.log(`The remaining ${remainingChange} satoshi went to the commission`);
        }
        return { psbt, usedUtxos };
    }
    async getFeeRate(overrideRate) {
        if (overrideRate !== undefined) {
            return overrideRate;
        }
        try {
            const url = this.getApiUrl("/fee-estimates");
            const response = await axios_1.default.get(url);
            const feeRate = Math.ceil(response.data["2"]) || BITCOIN_CONSTANTS.SAT_PER_VBYTE;
            return feeRate > 0 ? feeRate : BITCOIN_CONSTANTS.SAT_PER_VBYTE;
        }
        catch (error) {
            console.error("Error receiving commission, using standard:", error);
            return BITCOIN_CONSTANTS.SAT_PER_VBYTE;
        }
    }
    async calculateFee(inputsCount, outputsCount, overrideFeeRate) {
        const txSize = BITCOIN_CONSTANTS.BASE_TX_SIZE +
            inputsCount * BITCOIN_CONSTANTS.INPUT_SIZE +
            outputsCount * BITCOIN_CONSTANTS.OUTPUT_SIZE;
        const feeRate = await this.getFeeRate(overrideFeeRate);
        const fee = Math.ceil(txSize * feeRate);
        return fee;
    }
    async signTransaction(psbt) {
        const [signed] = await this.signTransactions([psbt]);
        return signed;
    }
    async signTransactions(psbts) {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        return psbts.map(psbt => {
            psbt.data.inputs.forEach((input, index) => {
                const utxo = this.lastUsedUtxos[index];
                const keyPair = utxo.derivedKey || this.wallet;
                psbt.signInput(index, this.toSigner(keyPair));
            });
            psbt.finalizeAllInputs();
            const tx = psbt.extractTransaction();
            const txHex = tx.toHex();
            return txHex;
        });
    }
    async getBalance() {
        const utxos = await this.fetchAllUTXOs();
        const totalBalance = utxos.reduce((sum, utxo) => sum + utxo.value, 0);
        return totalBalance.toString();
    }
    async getEmptyTransaction() {
        return {
            version: 2,
            locktime: 0,
            ins: [],
            outs: [],
        };
    }
    /**
     * Get the legacy P2PKH address for signature verification
     * Bitcoin message signatures can only be verified against legacy addresses
     */
    getLegacyAddress() {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        const { address } = bitcoin.payments.p2pkh({
            pubkey: Buffer.from(this.wallet.publicKey),
            network: this.network,
        });
        return address;
    }
    /**
     * Get the public key as hex string (needed for signature verification)
     */
    getPublicKey() {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        return Buffer.from(this.wallet.publicKey).toString("hex");
    }
    async signMessage(message, options) {
        let keyPair;
        if (options?.privateKey) {
            keyPair = ECPair.fromWIF(options.privateKey, this.network);
        }
        else {
            (0, utils_1.required)(this.wallet, "Wallet not connected");
            keyPair = this.wallet;
        }
        const privateKey = Buffer.from(keyPair.privateKey);
        // Use legacy signature format (no segwitType) for maximum compatibility
        const signature = bitcoinMessage.sign(message, privateKey, keyPair.compressed, this.network.messagePrefix);
        return signature.toString("base64");
    }
    /**
     * Infer the Bitcoin network from an address format
     * Mainnet: starts with 1, 3, or bc1
     * Testnet: starts with m, n, 2, or tb1
     */
    static inferNetworkFromAddress(address) {
        if (!address)
            return bitcoin.networks.bitcoin;
        // Mainnet patterns
        if (address.startsWith("1") || address.startsWith("3") || address.toLowerCase().startsWith("bc1")) {
            return bitcoin.networks.bitcoin;
        }
        // Testnet patterns
        if (address.startsWith("m") || address.startsWith("n") || address.startsWith("2") || address.toLowerCase().startsWith("tb1")) {
            return bitcoin.networks.testnet;
        }
        // Default to mainnet
        return bitcoin.networks.bitcoin;
    }
    async verifyMessage(message, signature, address) {
        try {
            // Infer network from address to use correct message prefix
            const network = BTC.inferNetworkFromAddress(address);
            return bitcoinMessage.verify(message, address, Buffer.from(signature, "base64"), network.messagePrefix, true);
        }
        catch (error) {
            return false;
        }
    }
}
exports.BTC = BTC;
BTC.networks = bitcoin.networks;
//# sourceMappingURL=btc.js.map