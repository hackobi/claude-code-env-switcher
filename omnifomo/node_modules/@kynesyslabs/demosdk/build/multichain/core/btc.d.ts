import * as bitcoin from "bitcoinjs-lib";
import { ECPairInterface } from "ecpair";
import { DefaultChain } from "./types/defaultChain";
import { IPayParams } from "./types/interfaces";
export declare class BTC extends DefaultChain {
    static networks: typeof bitcoin.networks;
    provider: string;
    network: bitcoin.Network;
    wallet: ECPairInterface;
    address?: string;
    private changeIndex;
    private lastUsedUtxos;
    private usedChangeAddresses;
    constructor(rpc_url: string, network?: bitcoin.Network);
    /**
     * Infer the Bitcoin network from the RPC URL
     * Returns mainnet by default if URL is null/undefined/empty
     */
    static inferNetworkFromUrl(rpc_url: string | null | undefined): bitcoin.Network;
    static create<T extends BTC>(this: new (rpc_url: string, network: bitcoin.Network) => T, rpc_url: string | null, network?: bitcoin.Network): Promise<T>;
    connect(): Promise<boolean>;
    /**
     * Generate a private key for the BTC chain
     * @param seed - The seed to generate the private key from (optional)
     * @returns The private key as a WIF string
     */
    generatePrivateKey(seed?: Buffer): string;
    private generateChangeAddress;
    /**
     * Connect wallet using either a WIF private key or a BIP39 mnemonic phrase
     * @param privateKeyOrMnemonic - WIF private key or 12/24 word mnemonic phrase
     */
    connectWallet(privateKeyOrMnemonic: string): Promise<ECPairInterface>;
    getAddress(): string;
    private getApiUrl;
    fetchUTXOs(address: string): Promise<any[]>;
    fetchAllUTXOs(): Promise<any[]>;
    getTxHex(txid: string): Promise<string>;
    private toSigner;
    preparePay(address: string, amount: string, overrideFeeRate?: number, addNoise?: boolean): Promise<string>;
    preparePays(payments: IPayParams[], overrideFeeRate?: number, addNoise?: boolean): Promise<string[]>;
    private createUnsignedPSBT;
    getFeeRate(overrideRate?: number): Promise<number>;
    private calculateFee;
    signTransaction(psbt: bitcoin.Psbt): Promise<string>;
    signTransactions(psbts: bitcoin.Psbt[]): Promise<string[]>;
    getBalance(): Promise<string>;
    getEmptyTransaction(): Promise<any>;
    /**
     * Get the legacy P2PKH address for signature verification
     * Bitcoin message signatures can only be verified against legacy addresses
     */
    getLegacyAddress(): string;
    /**
     * Get the public key as hex string (needed for signature verification)
     */
    getPublicKey(): string;
    signMessage(message: string, options?: {
        privateKey?: string;
    }): Promise<string>;
    /**
     * Infer the Bitcoin network from an address format
     * Mainnet: starts with 1, 3, or bc1
     * Testnet: starts with m, n, 2, or tb1
     */
    static inferNetworkFromAddress(address: string): bitcoin.Network;
    verifyMessage(message: string, signature: string, address: string): Promise<boolean>;
}
