"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVM = void 0;
const ethers_1 = require("ethers");
const bip39 = __importStar(require("bip39"));
const defaultChain_1 = require("./types/defaultChain");
const utils_1 = require("./utils");
const ERC20_ABI = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [{ name: "", type: "string" }],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            { name: "src", type: "address" },
            { name: "dst", type: "address" },
            { name: "wad", type: "uint256" },
        ],
        name: "transferFrom",
        outputs: [{ name: "", type: "bool" }],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [{ name: "wad", type: "uint256" }],
        name: "withdraw",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [{ name: "", type: "uint8" }],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [{ name: "", type: "address" }],
        name: "balanceOf",
        outputs: [{ name: "", type: "uint256" }],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [{ name: "", type: "string" }],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            { name: "dst", type: "address" },
            { name: "wad", type: "uint256" },
        ],
        name: "transfer",
        outputs: [{ name: "", type: "bool" }],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [],
        name: "deposit",
        outputs: [],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            { name: "", type: "address" },
            { name: "", type: "address" },
        ],
        name: "allowance",
        outputs: [{ name: "", type: "uint256" }],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    { payable: true, stateMutability: "payable", type: "fallback" },
];
class EVM extends defaultChain_1.DefaultChain {
    constructor(rpc_url, chainId, isEIP1559) {
        super(rpc_url);
        this.contracts = new Map();
        this.name = "evm";
        this.chainId = chainId;
        this.isEIP1559 = isEIP1559;
    }
    setRpc(rpc_url) {
        // NOTE: We override here because we need to create a new provider
        this.rpc_url = rpc_url;
        this.provider = new ethers_1.JsonRpcProvider(this.rpc_url);
    }
    /**
     * Connects to the EVM network
     *
     * @param chainId (Optional) The chainId of this network
     * @param isEIP1559 (Optional) Whether this network uses EIP-1559
     * @returns A boolean indicating whether the connection was successful
     *
     * When parameters are not provided, they are automatically inferred from the network.
     */
    async connect(chainId, isEIP1559) {
        if (chainId) {
            this.chainId = chainId;
        }
        if (isEIP1559) {
            this.isEIP1559 = isEIP1559;
        }
        try {
            const network = await this.provider.getNetwork();
            this.chainId = (0, ethers_1.toNumber)(network.chainId);
            this.connected = this.chainId > 0;
        }
        catch (error) {
            console.error(error);
            this.connected = false;
        }
        return this.connected;
    }
    // INFO Connecting a wallet through a private key (string) or mnemonic phrase
    // REVIEW should private key be a string or a Buffer?
    async connectWallet(privateKey, accountIndex = 0) {
        if (!this.rpc_url) {
            console.warn("WARNING: No RPC URL set. Connecting wallet without provider");
        }
        privateKey = privateKey.trim();
        // INFO: Check if the input is a mnemonic phrase (contains spaces)
        const isMnemonic = privateKey.includes(" ");
        if (isMnemonic) {
            // INFO: Validate mnemonic
            if (!bip39.validateMnemonic(privateKey)) {
                throw new Error("Invalid mnemonic phrase");
            }
            // INFO: Create HD wallet from mnemonic using BIP44 path for Ethereum: m/44'/60'/0'/0/{accountIndex}
            const hdNode = ethers_1.HDNodeWallet.fromPhrase(privateKey, "", `m/44'/60'/0'/0/${accountIndex}`);
            this.wallet = new ethers_1.Wallet(hdNode.privateKey, this.rpc_url ? this.provider : null);
        }
        else {
            // INFO: Treat as private key hex
            this.wallet = new ethers_1.Wallet(privateKey, this.rpc_url ? this.provider : null);
        }
        return this.wallet;
    }
    // INFO Signing a message
    async signMessage(message, options) {
        (0, utils_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        let wallet = this.wallet;
        if (options?.privateKey) {
            wallet = new ethers_1.Wallet(options.privateKey, this.provider);
        }
        return wallet.signMessage(message);
    }
    // INFO Verifying a message
    async verifyMessage(message, signature, publicKey) {
        let recoveredAddress = (0, ethers_1.verifyMessage)(message, signature);
        return recoveredAddress === publicKey;
    }
    // INFO Signing a transaction
    // with a private key or by using our stored wallet
    // REVIEW should private key be a string or a Buffer?
    async signTransaction(transaction, options) {
        const txs = await this.signTransactions([transaction], options);
        return txs[0];
    }
    async signTransactions(transactions, options) {
        (0, utils_1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        if (options?.privateKey) {
            this.wallet = new ethers_1.Wallet(options.privateKey, this.provider);
        }
        // INFO: Get the current nonce
        const this_address = this.getAddress();
        let currentNonce = await this.provider.getTransactionCount(this_address);
        // INFO: Return a list of signed transactions
        return Promise.all(transactions.map(async (tx) => {
            tx.nonce = currentNonce;
            // INFO: Increment the nonce for the next transaction
            currentNonce++;
            return this.wallet.signTransaction(tx);
        }));
    }
    // SECTION Specific methods
    // REVIEW Should prepare methods be like:
    // prepare = { pay(), send(), ...}
    async preparePay(address, amount, options) {
        const tx = await this.preparePays([{ address, amount }], options);
        return tx[0];
    }
    async preparePays(payments, options) {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        const baseTx = await this.prepareBaseTxWithType();
        const txs = payments.map(payment => {
            const tx = {
                ...baseTx,
                ...(options?.gasLimit && { gasLimit: options.gasLimit }),
                to: payment.address,
                value: (0, ethers_1.parseEther)(payment.amount),
            };
            // INFO: wallet.checkTransaction was removed in ethers v6
            // const checkedTx = this.wallet.checkTransaction(tx);
            // console.log('checked', checkedTx);
            return tx;
        });
        return this.signTransactions(txs);
    }
    // SECTION EVM Specific methods
    // INFO Generic transaction skeleton for both EIP-1559 and legacy chains
    async prepareBaseTxWithType() {
        const feeData = await this.provider.getFeeData();
        // INFO: Check if the chain uses EIP-1559
        // If the user has set the isEIP1559 flag, use it
        const isEIP1559 = this.isEIP1559 || feeData.maxFeePerGas !== null;
        const baseTx = {
            gasLimit: 21000,
            chainId: this.chainId,
        };
        if (isEIP1559) {
            return {
                ...baseTx,
                type: 2,
                maxFeePerGas: feeData.maxFeePerGas,
                maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
            };
        }
        // INFO: Legacy chains use a gasPrice
        return {
            ...baseTx,
            gasPrice: feeData.gasPrice,
        };
    }
    // INFO Generic empty tx skeleton for this chain
    async getEmptyTransaction() {
        // NOTE This is a redirection to the prepareBaseTxWithType method as in a evm chain is like that
        return await this.prepareBaseTxWithType();
    }
    // megabudino was here â€“ return the address of the wallet
    getAddress() {
        return this.wallet.address;
    }
    /**
     * Check if an address is valid
     *
     * @param address The address to check
     * @returns A boolean indicating whether the address is valid
     */
    isAddress(address) {
        return (0, ethers_1.isAddress)(address);
    }
    async getBalance(address) {
        let balance_raw = await this.provider.getBalance(address);
        return (0, ethers_1.formatEther)(balance_raw);
    }
    /**
     * Get the balance of a token
     *
     * @param contract_address The address of the token contract
     * @param address The address of the wallet
     * @returns The balance of the token
     */
    async getTokenBalance(contract_address, address) {
        let contract = await this.getContractInstance(contract_address, JSON.stringify(ERC20_ABI));
        const fields = ["name", "symbol", "decimals"];
        const promises = fields.map(field => this.readFromContract(contract, field, []));
        promises.push(contract.balanceOf(address));
        const [name, symbol, decimals, balance] = await Promise.all(promises);
        return {
            name,
            symbol,
            decimals,
            balance,
        };
    }
    // SECTION EVM Exclusive methods
    async createRawTransaction(tx_data) {
        throw new Error("Not implemented");
    }
    async waitForReceipt(tx_hash) {
        return await this.provider.getTransactionReceipt(tx_hash);
    }
    // SECTION Not implemented methods
    async getContractInstance(address, abi) {
        console.log(this);
        if (!this.provider) {
            throw new Error("Provider not connected");
        }
        let contract = new ethers_1.Contract(address, abi, this.provider);
        return contract;
    }
    // REVIEW Reader for contracts
    // ANCHOR MVP
    async readFromContract(contract_instance, function_name, args) {
        return await contract_instance[function_name](...args);
    }
    // REVIEW Writer for contracts
    // REVIEW: Updated to properly prepare and sign transactions for node execution
    async writeToContract(contract_instance, function_name, args, options) {
        (0, utils_1.required)(this.wallet, "Wallet not connected");
        // Connect wallet to contract for signing capability
        const contractWithSigner = contract_instance.connect(this.wallet);
        // Prepare transaction options
        const txOptions = {};
        if (options?.gasLimit) {
            txOptions.gasLimit = options.gasLimit;
        }
        if (options?.value) {
            txOptions.value = (0, ethers_1.parseEther)(options.value);
        }
        // Get nonce
        const nonce = await this.provider.getTransactionCount(this.wallet.address);
        // Get populated transaction without executing
        const populatedTx = await contractWithSigner[function_name].populateTransaction(...args, txOptions);
        // Ensure transaction has required fields
        if (!populatedTx.chainId) {
            populatedTx.chainId = this.chainId;
        }
        // Get base transaction data (gas pricing, etc.)
        const baseTx = await this.prepareBaseTxWithType();
        // Merge base transaction data with populated transaction
        const finalTx = {
            nonce,
            ...baseTx,
            ...populatedTx,
            // Override gasLimit if provided in options
            ...(options?.gasLimit && { gasLimit: options.gasLimit }),
        };
        // Sign the transaction for node execution
        return await this.wallet.signTransaction(finalTx);
    }
    // SECTION Event listener
    /**
     * Listen for a specific event from a contract
     *
     * @param contract The address of the contract to listen to
     * @param abi The ABI of the contract to listen to
     * @param event The event to listen to
     * @param timeout The timeout in milliseconds before the listener is removed
     *
     * @returns A promise that resolves to the event data or rejects if the timeout is reached
     */
    async listenForEvent(contract, abi, event, timeout = 5000) {
        if (!this.provider) {
            throw new Error("Provider not connected");
        }
        const contractInstance = new ethers_1.Contract(contract, abi, this.provider);
        return new Promise((resolve, reject) => {
            let settled = false;
            const listener = (...args) => {
                if (settled) {
                    return;
                }
                settled = true;
                clearTimeout(timer);
                const payload = args.length === 1 ? args[0] : args;
                contractInstance.off(event, listener);
                resolve(payload);
            };
            const timer = setTimeout(() => {
                if (settled) {
                    return;
                }
                settled = true;
                contractInstance.off(event, listener);
                reject(new Error("Event listener timed out"));
            }, timeout);
            contractInstance.on(event, listener);
        });
    }
    /**
     * Listen for all events from a contract
     *
     * @param contract The address of the contract to listen to
     * @param abi The ABI of the contract to listen to
     * @param callback The callback to call when an event is emitted
     *
     * @returns A function to remove the listener
     */
    listenForAllEvents(contract, abi, callback) {
        if (!this.provider) {
            throw new Error("Provider not connected");
        }
        const contractInstance = new ethers_1.Contract(contract, abi, this.provider);
        const listener = (...args) => {
            callback(...args);
        };
        contractInstance.on("*", listener);
        return () => {
            contractInstance.off("*", listener);
        };
    }
}
exports.EVM = EVM;
//# sourceMappingURL=evm.js.map