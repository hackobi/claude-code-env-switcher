import { IPayOptions } from ".";
import { TronWeb } from "tronweb";
import { DefaultChain, IDefaultChainLocal } from "./types/defaultChain";
import { XmTransactionResponse } from "./types/interfaces";
type TronWebInstance = InstanceType<typeof TronWeb>;
export declare class TRON extends DefaultChain implements IDefaultChainLocal {
    provider: TronWebInstance;
    wallet: TronWebInstance;
    static readonly SUN_PER_TRX = 1000000;
    constructor(rpc_url: string);
    setRpc(rpc_url: string): void;
    connect(): Promise<boolean>;
    connectWallet(privateKey: string): Promise<TronWebInstance>;
    getAddress(): string;
    getBalance(address: string): Promise<string>;
    getInfo(): Promise<any>;
    /**
     * Creates a new TRON wallet
     * @param _password Password parameter (reserved for future encryption support)
     * @returns Object containing the wallet address and private key
     * @note Currently returns unencrypted private key. Password parameter is accepted
     *       for interface compatibility but not yet used for encryption.
     */
    createWallet(_password: string): Promise<{
        address: string;
        privateKey: string;
    }>;
    signMessage(message: string, options?: {
        privateKey?: string;
    }): Promise<string>;
    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;
    signTransaction(tx: any): Promise<any>;
    signTransactions(transactions: any[], options?: {
        privateKey?: string;
    }): Promise<any[]>;
    /**
     * Prepare a TRX transfer transaction
     * @param receiver Recipient address (base58 format)
     * @param amount Amount in SUN (1 TRX = 1,000,000 SUN)
     * @param options Options including optional privateKey
     * @returns Signed transaction ready to broadcast
     */
    preparePay(receiver: string, amount: string, options?: {
        privateKey?: string;
    }): Promise<any>;
    /**
     * Prepare multiple TRX transfer transactions
     * @param payments Array of payments with address and amount (in SUN)
     * @param options Options including optional privateKey
     * @returns Array of signed transactions
     */
    preparePays(payments: IPayOptions[], options?: {
        privateKey?: string;
    }): Promise<any[]>;
    /**
     * Broadcast a signed transaction to the network
     * @param signedTx The signed transaction
     * @returns Transaction response with result and hash
     */
    sendTransaction(signedTx: any): Promise<XmTransactionResponse>;
    getEmptyTransaction(): any;
    /**
     * Convert TRX to SUN
     * @param trx Amount in TRX
     * @returns Amount in SUN as bigint
     */
    static trxToSun(trx: string | number): bigint;
    /**
     * Convert SUN to TRX with full precision preservation
     * @param sun Amount in SUN as bigint
     * @returns Amount in TRX as a decimal string (e.g., "123.456789")
     * @note This method returns a string to preserve precision for large values.
     *       For display purposes, you may want to parse this with a BigNumber library.
     */
    static sunToTrx(sun: bigint): string;
}
export {};
