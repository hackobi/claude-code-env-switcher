"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.IBC = void 0;
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const encoding_1 = require("@cosmjs/encoding");
const tx_1 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const defaultChain_1 = require("./types/defaultChain");
const utils_1 = require("./utils");
const crypto_1 = require("crypto");
const crypto_2 = require("@cosmjs/crypto");
const bip39 = __importStar(require("@scure/bip39"));
const bip32 = __importStar(require("@scure/bip32"));
class IBC extends defaultChain_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.address = '';
        this.chainId = '';
        // IBC options
        this.gasPrice = '';
        this.multiplier = 2.0;
        this.name = 'ibc';
    }
    async setRpc(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = await stargate_1.StargateClient.connect(rpc_url);
    }
    // INFO: rpc_url used to avoid overwriting this.provider for test mocking
    async connect(rpc_url) {
        if (!this.provider || (rpc_url && rpc_url !== this.rpc_url)) {
            const url = rpc_url || this.rpc_url;
            this.rpc_url = url;
            this.provider = await stargate_1.StargateClient.connect(url);
        }
        try {
            const chain_id = await this.provider.getChainId();
            this.chainId = chain_id;
            this.connected = Boolean(chain_id);
        }
        catch (error) {
            this.connected = false;
        }
        return this.connected;
    }
    async connectWallet(privateKey, options, rpc_url) {
        (0, utils_1.required)(options.prefix, 'Address prefix not provided');
        (0, utils_1.required)(options.gasPrice, 'Gas price not provided');
        // INFO: Store the gasPrice for preparePays and other methods
        this.gasPrice = options.gasPrice;
        // INFO: Check if privateKey is a mnemonic or a private key
        const isPrivateKey = privateKey.split(' ').length === 1;
        // INFO: Create a signer using the appropriate wallet
        if (isPrivateKey) {
            // TODO: Test this block!
            const buffer = Buffer.from(privateKey, 'hex');
            this.signer = await proto_signing_1.DirectSecp256k1Wallet.fromKey(buffer, options.prefix);
        }
        else {
            this.signer = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(privateKey, {
                prefix: options.prefix,
            });
        }
        // INFO: Store the address as .getAddress can't be async
        const wallet_accounts = await this.signer.getAccounts();
        const this_account = wallet_accounts.find((account) => account.address.startsWith(options.prefix));
        if (this_account) {
            this.address = this_account.address;
        }
        else {
            throw new Error(`No account found for prefix: ${options.prefix}`);
        }
        if (rpc_url) {
            this.setRpc(rpc_url);
        }
        this.rpc_url = rpc_url || this.rpc_url;
        this.wallet = await stargate_1.SigningStargateClient.connectWithSigner(this.rpc_url, this.signer);
        this.chainId = await this.wallet.getChainId();
        return this.wallet;
    }
    getAddress() {
        return this.address;
    }
    /**
     * Get the balance of the address
     * @param address The address
     * @param options Specify the denomination of the token
     * @returns The balance of the address in the specified denomination
     */
    async getBalance(address, options) {
        (0, utils_1.required)(this.provider, 'Provider not connected');
        const coins = await this.provider.getBalance(address, options.denom);
        return coins.amount;
    }
    getEmptyTransaction() {
        return {
            signerAddress: this.getAddress(),
            messages: [
                {
                    typeUrl: '/cosmos.bank.v1beta1.MsgSend',
                    value: {
                        fromAddress: this.getAddress(),
                        toAddress: '',
                        amount: [{ denom: '', amount: '' }],
                    },
                },
            ],
            // INFO: Fees are to be estimated when filling the tx
            fee: null,
            memo: '',
        };
    }
    async preparePay(receiver, amount, options) {
        // INFO: Call preparePays with a single payment
        const tx = await this.preparePays([{ address: receiver, amount }], options);
        return tx[0];
    }
    /**
     * Prepare multiple payments
     * @param payments An array of payments
     * @param options Specifies the denomination of the token
     * @returns An array of signed transactions
     */
    async preparePays(payments, options) {
        // INFO: Create an array of transactions
        const txs = payments.map((payment) => {
            const tx = this.getEmptyTransaction();
            // INFO: Fill the tx
            tx.messages[0].value.toAddress = payment.address;
            tx.messages[0].value.amount = [
                {
                    denom: options.denom,
                    amount: payment.amount,
                },
            ];
            return tx;
        });
        // INFO: Estimate the fee for the first tx
        const fees = await this.estimateTxFee(txs[0]);
        // INFO: Since all txs here are similar, set same fee for all
        txs.forEach((tx) => {
            tx.fee = fees;
        });
        // INFO: Sign and return the txs
        return await this.signTransactions(txs);
    }
    async signMessage(message, options) {
        (0, utils_1.required)(options && options?.privateKey, "Wallet not connected");
        // Check if privateKey is a mnemonic or raw private key
        const isMnemonic = options.privateKey.includes(' ');
        let privateKey;
        let publicKey;
        if (isMnemonic) {
            const seed = bip39.mnemonicToSeedSync(options.privateKey);
            const hdkey = bip32.HDKey.fromMasterSeed(seed);
            const derivedKey = hdkey.derive("m/44'/118'/0'/0/0");
            privateKey = derivedKey.privateKey;
            publicKey = derivedKey.publicKey;
        }
        else {
            const privateKeyBytes = Buffer.from(options.privateKey, 'hex');
            const keypair = await crypto_2.Secp256k1.makeKeypair(privateKeyBytes);
            privateKey = privateKeyBytes;
            publicKey = crypto_2.Secp256k1.compressPubkey(keypair.pubkey);
        }
        const messageHash = (0, crypto_1.createHash)('sha256').update(message).digest();
        const signObj = await crypto_2.Secp256k1.createSignature(messageHash, privateKey);
        const fixedLengthData = signObj.toFixedLength();
        const base64Signature = (0, encoding_1.toBase64)(fixedLengthData);
        const base64PublicKey = (0, encoding_1.toBase64)(publicKey);
        // Return signature|publicKey so both can be extracted
        return `${base64Signature}|${base64PublicKey}`;
    }
    async verifyMessage(message, signature, publicKey) {
        const signatureBytes = (0, encoding_1.fromBase64)(signature);
        const rAndSBytes = signatureBytes.slice(0, 64);
        const publicKeyBytes = (0, encoding_1.fromBase64)(publicKey);
        const signatureObj = crypto_2.Secp256k1Signature.fromFixedLength(rAndSBytes);
        const messageHash = (0, crypto_1.createHash)('sha256').update(message).digest();
        const isVerified = await crypto_2.Secp256k1.verifySignature(signatureObj, messageHash, publicKeyBytes);
        return isVerified;
    }
    async signTransaction(tx, options) {
        // INFO: Call signTransactions with a single tx
        const signed_txs = await this.signTransactions([tx], options);
        return signed_txs[0];
    }
    /**
     * Estimate the fee for a transaction
     * @param tx The transaction
     * @returns The estimate fee for the transaction
     */
    async estimateTxFee(tx) {
        const signerAddress = this.getAddress();
        const gasEstimate = await this.wallet.simulate(signerAddress, tx.messages, tx.memo);
        const gasLimit = Math.round(gasEstimate * this.multiplier);
        return (0, stargate_1.calculateFee)(gasLimit, this.gasPrice);
    }
    async signTransactions(transactions, options) {
        (0, utils_1.required)(this.wallet, 'Wallet not connected');
        if (options?.privateKey) {
            const { privateKey, ...connectOptions } = options;
            await this.connectWallet(privateKey, connectOptions);
        }
        // NOTE: Sequence management happens here
        // INFO: Get account on network
        const address = this.getAddress();
        console.log("address: ", address);
        const account = await this.wallet.getAccount(address);
        console.log("account: ", account);
        if (!account) {
            throw new Error(`Account ${address} not found`);
        }
        // INFO: Store the current sequence
        let current_sequence = account.sequence;
        const signed_txs = transactions.map(async (tx) => {
            const signerInfo = {
                sequence: current_sequence,
                accountNumber: account.accountNumber,
                chainId: this.chainId,
            };
            if (tx.fee === null) {
                // INFO: Throw an error if fee is not set
                console.error('Fee not set for tx: ', tx);
                throw new Error('Fee not set for tx');
            }
            // INFO: Increment the sequence for next round
            current_sequence++;
            // INFO: Sign the tx
            const signed_tx = await this.wallet.sign(tx.signerAddress, tx.messages, tx.fee, tx.memo, signerInfo);
            // INFO: Convert raw tx to bytes array (Ready for broadcast)
            const tx_bytes = tx_1.TxRaw.encode(signed_tx).finish();
            return tx_bytes;
        });
        // INFO: Return the signed transactions
        return await Promise.all(signed_txs);
    }
    async disconnect() {
        this.resetInstance();
        this.address = '';
        this.gasPrice = '';
        return !this.connected;
    }
    // SECTION: Unimplemented methods
    async ibcSend() {
        // TODO: Implement IBC send
        // REFERENCE: https://github.com/cosmos/cosmjs/blob/33271bc51c/packages/stargate/src/signingstargateclient.ts#L246
        throw new Error('Method not implemented');
    }
}
exports.IBC = IBC;
//# sourceMappingURL=ibc.js.map