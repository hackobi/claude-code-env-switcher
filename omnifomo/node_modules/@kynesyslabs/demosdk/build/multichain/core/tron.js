"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRON = void 0;
const _1 = require(".");
const tronweb_1 = require("tronweb");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const defaultChain_1 = require("./types/defaultChain");
const interfaces_1 = require("./types/interfaces");
class TRON extends defaultChain_1.DefaultChain {
    constructor(rpc_url) {
        super(rpc_url);
        this.name = "tron";
    }
    setRpc(rpc_url) {
        this.rpc_url = rpc_url;
        this.provider = new tronweb_1.TronWeb({
            fullHost: this.rpc_url,
        });
    }
    async connect() {
        try {
            (0, _1.required)(this.provider, "Provider not initialized. Call setRpc first.");
            // Test connection by getting latest block
            const block = await this.provider.trx.getCurrentBlock();
            this.connected = !!block?.block_header;
            return this.connected;
        }
        catch (error) {
            console.error("[TRON] Connection failed:", error);
            this.connected = false;
            return false;
        }
    }
    async connectWallet(privateKey) {
        (0, _1.required)(this.provider, "Provider not initialized. Call setRpc first.");
        // Trim whitespace from private key before processing
        const trimmedKey = privateKey.trim();
        const cleanPrivateKey = trimmedKey.startsWith("0x")
            ? trimmedKey.slice(2)
            : trimmedKey;
        this.wallet = new tronweb_1.TronWeb({
            fullHost: this.rpc_url,
            privateKey: cleanPrivateKey,
        });
        return this.wallet;
    }
    getAddress() {
        (0, _1.required)(this.wallet, "Wallet not connected");
        const address = this.wallet.defaultAddress.base58;
        if (!address) {
            throw new Error("Wallet address not available");
        }
        const addressStr = String(address);
        // Validate the address format
        if (!tronweb_1.TronWeb.isAddress(addressStr)) {
            throw new Error(`Invalid TRON address: ${addressStr}`);
        }
        return addressStr;
    }
    async getBalance(address) {
        (0, _1.required)(this.provider, "Provider not initialized");
        try {
            // Returns balance in SUN (1 TRX = 1,000,000 SUN)
            const balanceSun = await this.provider.trx.getBalance(address);
            return new bignumber_js_1.default(balanceSun).toString();
        }
        catch (error) {
            console.error("[TRON] Failed to get balance:", error);
            throw error;
        }
    }
    async getInfo() {
        (0, _1.required)(this.provider, "Provider not initialized");
        return await this.provider.trx.getCurrentBlock();
    }
    /**
     * Creates a new TRON wallet
     * @param _password Password parameter (reserved for future encryption support)
     * @returns Object containing the wallet address and private key
     * @note Currently returns unencrypted private key. Password parameter is accepted
     *       for interface compatibility but not yet used for encryption.
     */
    async createWallet(_password) {
        const account = await tronweb_1.TronWeb.createAccount();
        // TODO: Implement password-based encryption of privateKey
        // For now, return unencrypted to match other chain implementations
        return {
            address: account.address.base58,
            privateKey: account.privateKey,
        };
    }
    async signMessage(message, options) {
        (0, _1.required)(this.wallet || options?.privateKey, "Wallet not connected");
        const wallet = options?.privateKey
            ? new tronweb_1.TronWeb({ fullHost: this.rpc_url, privateKey: options.privateKey })
            : this.wallet;
        const hexMessage = tronweb_1.TronWeb.toHex(message);
        const signedMessage = await wallet.trx.signMessageV2(hexMessage);
        return signedMessage;
    }
    async verifyMessage(message, signature, publicKey) {
        try {
            const hexMessage = tronweb_1.TronWeb.toHex(message);
            const tronWeb = this.provider || new tronweb_1.TronWeb({
                fullHost: this.rpc_url
            });
            const recoveredAddress = await tronWeb.trx.verifyMessageV2(hexMessage, signature);
            return recoveredAddress.toLowerCase() === publicKey.toLowerCase();
        }
        catch (error) {
            console.error("[TRON] Message verification failed:", error);
            return false;
        }
    }
    async signTransaction(tx) {
        (0, _1.required)(this.wallet, "Wallet not connected");
        return await this.wallet.trx.sign(tx);
    }
    async signTransactions(transactions, options) {
        const wallet = options?.privateKey
            ? new tronweb_1.TronWeb({ fullHost: this.rpc_url, privateKey: options.privateKey })
            : this.wallet;
        (0, _1.required)(wallet, "Wallet not connected");
        const signedTxs = [];
        for (const tx of transactions) {
            const signedTx = await wallet.trx.sign(tx);
            signedTxs.push(signedTx);
        }
        return signedTxs;
    }
    /**
     * Prepare a TRX transfer transaction
     * @param receiver Recipient address (base58 format)
     * @param amount Amount in SUN (1 TRX = 1,000,000 SUN)
     * @param options Options including optional privateKey
     * @returns Signed transaction ready to broadcast
     */
    async preparePay(receiver, amount, options) {
        const txs = await this.preparePays([{ address: receiver, amount }], options);
        return txs[0];
    }
    /**
     * Prepare multiple TRX transfer transactions
     * @param payments Array of payments with address and amount (in SUN)
     * @param options Options including optional privateKey
     * @returns Array of signed transactions
     */
    async preparePays(payments, options) {
        const wallet = options?.privateKey
            ? new tronweb_1.TronWeb({ fullHost: this.rpc_url, privateKey: options.privateKey })
            : this.wallet;
        (0, _1.required)(wallet, "Wallet not connected");
        const signedTxs = [];
        for (const payment of payments) {
            const amountBN = new bignumber_js_1.default(payment.amount);
            if (!amountBN.isFinite() || amountBN.isNegative()) {
                throw new Error(`Invalid payment amount: ${payment.amount}`);
            }
            // Convert to integer (SUN should be whole numbers)
            const amountIntBN = amountBN.integerValue(bignumber_js_1.default.ROUND_FLOOR);
            // Validate amount doesn't exceed JavaScript's safe integer limit
            // TronWeb API requires a JavaScript Number, so we must ensure precision is preserved
            if (amountIntBN.isGreaterThan(Number.MAX_SAFE_INTEGER)) {
                const maxTrx = Math.floor(Number.MAX_SAFE_INTEGER / TRON.SUN_PER_TRX);
                throw new Error(`Payment amount ${payment.amount} SUN exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER}). ` +
                    `Maximum supported amount is ~${maxTrx.toLocaleString()} TRX.`);
            }
            const amountInSun = amountIntBN.toNumber();
            const fromAddress = wallet.defaultAddress.base58;
            if (!fromAddress) {
                throw new Error("Wallet address not available");
            }
            const unsignedTx = await wallet.transactionBuilder.sendTrx(payment.address, amountInSun, String(fromAddress));
            const signedTx = await wallet.trx.sign(unsignedTx);
            signedTxs.push(signedTx);
        }
        return signedTxs;
    }
    /**
     * Broadcast a signed transaction to the network
     * @param signedTx The signed transaction
     * @returns Transaction response with result and hash
     */
    async sendTransaction(signedTx) {
        (0, _1.required)(this.provider, "Provider not initialized");
        try {
            const result = await this.provider.trx.sendRawTransaction(signedTx);
            if (result.result === true) {
                return {
                    result: interfaces_1.XmTransactionResult.success,
                    hash: result.txid || result.transaction?.txID,
                };
            }
            return {
                result: interfaces_1.XmTransactionResult.error,
                error: result.message || String(result.code) || "Transaction failed",
            };
        }
        catch (error) {
            console.error("[TRON] Send transaction failed:", error);
            return {
                result: interfaces_1.XmTransactionResult.error,
                error: error.message || error.toString(),
            };
        }
    }
    getEmptyTransaction() {
        return {};
    }
    /**
     * Convert TRX to SUN
     * @param trx Amount in TRX
     * @returns Amount in SUN as bigint
     */
    static trxToSun(trx) {
        if (typeof trx === "string") {
            trx = trx.trim() || "0";
        }
        const trxAmount = new bignumber_js_1.default(trx);
        if (!trxAmount.isFinite()) {
            throw new Error(`Invalid TRX amount: ${trx}`);
        }
        const sun = trxAmount.times(TRON.SUN_PER_TRX).integerValue(bignumber_js_1.default.ROUND_FLOOR);
        return BigInt(sun.toString());
    }
    /**
     * Convert SUN to TRX with full precision preservation
     * @param sun Amount in SUN as bigint
     * @returns Amount in TRX as a decimal string (e.g., "123.456789")
     * @note This method returns a string to preserve precision for large values.
     *       For display purposes, you may want to parse this with a BigNumber library.
     */
    static sunToTrx(sun) {
        const sunPerTrx = BigInt(TRON.SUN_PER_TRX);
        const isNegative = sun < 0n;
        const absSun = isNegative ? -sun : sun;
        const integerPart = absSun / sunPerTrx;
        const remainder = absSun % sunPerTrx;
        // Pad remainder to 6 decimal places (TRON has 6 decimals)
        const fractionalStr = remainder.toString().padStart(6, "0");
        // Remove trailing zeros for cleaner output
        const trimmedFractional = fractionalStr.replace(/0+$/, "") || "0";
        const base = trimmedFractional === "0"
            ? integerPart.toString()
            : `${integerPart}.${trimmedFractional}`;
        return isNegative ? `-${base}` : base;
    }
}
exports.TRON = TRON;
// TRX has 6 decimal places (1 TRX = 1,000,000 SUN)
TRON.SUN_PER_TRX = 1000000;
//# sourceMappingURL=tron.js.map