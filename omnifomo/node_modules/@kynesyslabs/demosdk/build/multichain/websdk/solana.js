"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SOLANA = void 0;
exports.detectPhantomProvider = detectPhantomProvider;
const web3_js_1 = require("@solana/web3.js");
const core_1 = require("../core");
const bs58_1 = __importDefault(require("bs58"));
function detectPhantomProvider() {
    if ("phantom" in window) {
        const provider = window.phantom["solana"];
        if (provider?.isPhantom) {
            return provider;
        }
    }
    return null;
}
class SOLANA extends core_1.SOLANA {
    constructor(rpc_url) {
        super(rpc_url);
    }
    /**
     * Connect a wallet. If running on the browser, try to connect to the Phantom wallet if no private key is provided.
     *
     * @param privateKey The private key to connect to the wallet
     * @returns The wallet object
     */
    // @ts-expect-error
    async connectWallet(privateKey) {
        // INFO: If no private key is provided, try to connect to the Phantom wallet
        if (!privateKey) {
            if (typeof window !== "undefined") {
                this.wallet = detectPhantomProvider();
                // try {
                const address = await this.wallet.connect();
                console.log("Connected to Phantom wallet: ", address.publicKey.toString());
                // } catch {
                //     throw new Error("Failed to connect to Phantom wallet")
                // }
                this.connected = this.wallet.isConnected;
                return this.wallet;
            }
            else {
                throw new Error("No private key provided");
            }
        }
        const pkBuffer = bs58_1.default.decode(privateKey);
        this.wallet = web3_js_1.Keypair.fromSecretKey(pkBuffer);
        return this.wallet;
    }
    async signTransactions(transactions, options) {
        (0, core_1.required)(this.wallet || (options && options.privateKey), "Wallet not connected");
        let usePhantom = false;
        // @ts-expect-error
        // PhantomProvider does not have a secretKey property
        if (!this.wallet.secretKey) {
            usePhantom = true;
        }
        let signers = usePhantom ? [] : [this.wallet];
        if (options && options.privateKey) {
            // INFO: If a private key is provided, override the wallet
            const privateKeyBuffer = bs58_1.default.decode(options.privateKey);
            const keypair = web3_js_1.Keypair.fromSecretKey(privateKeyBuffer);
            signers = [keypair];
        }
        if (signers.length) {
            return transactions.map(tx => {
                tx.sign(signers);
                return tx.serialize();
            });
        }
        // INFO: At this point, the wallet is a PhantomProvider
        const txs = await this.wallet.signAllTransactions(
        // @ts-expect-error
        // VersionedTransaction[] are consumed as Transaction[] by the PhantomProvider
        transactions);
        return txs.map(tx => tx.serialize());
    }
    async disconnect() {
        // INFO: Disconnect the wallet if it is a PhantomProvider
        // @ts-expect-error
        if (this.wallet && this.wallet.privateKey) {
            await this.wallet.disconnect();
        }
        await super.disconnect();
        return !this.connected;
    }
}
exports.SOLANA = SOLANA;
//# sourceMappingURL=solana.js.map