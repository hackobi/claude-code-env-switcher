import { BridgeOperationCompiled, SupportedChain, SupportedEVMChain, SupportedStablecoin, SupportedNonEVMChain } from "./nativeBridgeTypes";
import { Transaction } from "../types/blockchain/Transaction";
import { RPCRequest } from "../types";
import { Demos } from "../websdk";
export declare const methods: {
    /**
     * Validates the chain
     * @param chain
     * @param chainType
     * @param isOrigin (useful for error messages)
     */
    validateChain(chain: string, chainType: string, isOrigin: boolean): void;
    /**
     * Generates a new operation, ready to be sent to the node as a RPCRequest
     * TODO Implement the params
     * REVIEW Should we use the identity somehow or we keep using the private key?
     */
    generateOperation(privateKey: string, publicKey: string, originChainType: SupportedChain, originChain: SupportedEVMChain | SupportedNonEVMChain, destinationChainType: SupportedChain, destinationChain: SupportedEVMChain | SupportedNonEVMChain, originAddress: string, destinationAddress: string, amount: string, token: SupportedStablecoin): RPCRequest;
    /**
     * Generates a bridge transaction ready for client confirmation and broadcasting.
     *
     * @param compiled - The compiled bridge operation from RPC
     * @param demos - Demos instance for signing (provides wallet and nonce)
     * @returns Signed transaction ready for demos.confirm() and demos.broadcast()
     */
    generateOperationTx(compiled: BridgeOperationCompiled, demos: Demos): Promise<Transaction>;
    /**
     * Generates gasless bridge operation signature for meta-transaction
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns Signature for gasless bridge operation authorization
     */
    generateGaslessBridgeSignature(userPrivateKey: string, userPublicKey: string, nonce: number, originChain: string, destChain: string, token: string, recipient: string, amount: string, bridgeFeeBps?: number): string;
    /**
     * Generates gasless deposit signature for USDC deposits
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param usdcAddress USDC contract address
     * @param amount Amount to deposit
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @returns Signature for gasless deposit authorization
     */
    generateGaslessDepositSignature(userPrivateKey: string, userPublicKey: string, nonce: number, usdcAddress: string, amount: string, chainKey: string): string;
    /**
     * Initiates a gasless bridge operation through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns RPC request for gasless bridge initiation
     */
    generateGaslessBridgeOperation(userPublicKey: string, signature: string, nonce: number, originChain: string, destChain: string, token: string, recipient: string, amount: string, bridgeFeeBps?: number): RPCRequest;
    /**
     * Executes a gasless USDC deposit through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @param usdcAddress USDC contract address
     * @param amount Amount to deposit
     * @returns RPC request for gasless deposit execution
     */
    generateGaslessDepositOperation(userPublicKey: string, signature: string, nonce: number, chainKey: string, usdcAddress: string, amount: string): RPCRequest;
    /**
     * Complete gasless bridge flow helper - combines signature generation and operation creation
     * @param userPrivateKey User's private key for signing
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns Object with signature and RPC request for gasless bridge
     */
    generateCompleteGaslessBridge(userPrivateKey: string, userPublicKey: string, nonce: number, originChain: string, destChain: string, token: string, recipient: string, amount: string, bridgeFeeBps?: number): {
        signature: string;
        bridgeOperation: RPCRequest;
        depositOperation: RPCRequest;
    };
    /**
     * Generates atomic deposit and bridge signature for the new combined method
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge (must be equal)
     * @param destChain Destination chain name
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @param chainId Chain ID for signature verification
     * @param contractAddress Contract address for signature verification
     * @returns Signature for atomic deposit and bridge authorization
     */
    generateAtomicDepositAndBridgeSignature(userPrivateKey: string, userPublicKey: string, nonce: number, tokenName: string, depositAmount: string, destChain: string, recipient: string, bridgeFeeBps: number, chainId: number, contractAddress: string): string;
    /**
     * Executes atomic gasless deposit and bridge through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge
     * @param destChain Destination chain name
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points
     * @returns RPC request for atomic deposit and bridge execution
     */
    generateAtomicDepositAndBridgeOperation(userPublicKey: string, signature: string, nonce: number, chainKey: string, tokenName: string, depositAmount: string, destChain: string, recipient: string, bridgeFeeBps?: number): RPCRequest;
    /**
     * RECOMMENDED: Complete atomic deposit and bridge flow helper
     * @param userPrivateKey User's private key for signing
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge (equal values)
     * @param destChain Destination chain name (origin chain is automatic)
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @param chainId Chain ID (for signature verification)
     * @param contractAddress Contract address (for signature verification)
     * @param chainKey Chain key format (e.g., "eth.sepolia")
     * @returns Object with signature and RPC request for atomic operation
     */
    generateAtomicDepositAndBridge(userPrivateKey: string, userPublicKey: string, nonce: number, tokenName: string, depositAmount: string, destChain: string, recipient: string, bridgeFeeBps?: number, chainId?: number, contractAddress?: string, chainKey?: string): {
        signature: string;
        operation: RPCRequest;
    };
};
