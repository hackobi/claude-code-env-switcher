"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.methods = void 0;
const encryption_1 = require("../encryption");
const nativeBridgeTypes_1 = require("./nativeBridgeTypes");
exports.methods = {
    /**
     * Validates the chain
     * @param chain
     * @param chainType
     * @param isOrigin (useful for error messages)
     */
    validateChain(chain, chainType, isOrigin) {
        const chainTypeStr = isOrigin ? "origin" : "destination";
        if (chainType === "EVM") {
            if (!nativeBridgeTypes_1.supportedEVMChains.includes(chain)) {
                throw new Error(`Invalid ${chainTypeStr} chain: ${chain} is not a supported EVM`);
            }
        }
        else {
            if (!nativeBridgeTypes_1.supportedNonEVMChains.includes(chain)) {
                throw new Error(`Invalid ${chainTypeStr} chain: ${chain} is not a supported chain`);
            }
        }
    },
    /**
     * Generates a new operation, ready to be sent to the node as a RPCRequest
     * TODO Implement the params
     * REVIEW Should we use the identity somehow or we keep using the private key?
     */
    generateOperation(privateKey, publicKey, originChainType, originChain, destinationChainType, destinationChain, originAddress, destinationAddress, amount, token) {
        // Ensuring the chains are valid: throw an error if not
        this.validateChain(originChain, originChainType, true);
        this.validateChain(destinationChain, destinationChainType, false);
        // Defining the operation
        const operation = {
            demoAddress: publicKey,
            originChainType: originChainType,
            originChain: originChain,
            destinationChainType: destinationChainType,
            destinationChain: destinationChain,
            originAddress: originAddress,
            destinationAddress: destinationAddress,
            amount: amount,
            token: token,
            txHash: "",
            status: "empty",
        };
        // REVIEW Sign the operation
        let opHash = encryption_1.Hashing.sha256(JSON.stringify(operation));
        let signature = encryption_1.Cryptography.sign(opHash, privateKey);
        let hexSignature = new TextDecoder().decode(signature);
        let nodeCallPayload = {
            method: "nativeBridge",
            params: [operation, hexSignature],
        };
        return nodeCallPayload;
    },
    /**
     * Generates a bridge transaction ready for client confirmation and broadcasting.
     *
     * @param compiled - The compiled bridge operation from RPC
     * @param demos - Demos instance for signing (provides wallet and nonce)
     * @returns Signed transaction ready for demos.confirm() and demos.broadcast()
     */
    async generateOperationTx(compiled, demos) {
        // Extract addresses from the compiled operation
        const operation = compiled.content.operation;
        const from = operation.originAddress; // Source chain address
        const to = operation.originAddress; // Same as from (reflexive transaction)
        const from_ed25519_address = operation.demoAddress; // Demos address that started operation
        // Get proper nonce from demos instance
        const nonce = await demos.getAddressNonce(from_ed25519_address);
        // Prepare the transaction structure with bridge ID
        const txPayload = {
            operation: compiled,
            bridgeId: compiled.content.bridgeId
        };
        const tx = {
            content: {
                type: "nativeBridge",
                data: ["nativeBridge", txPayload],
                from: from,
                to: to,
                from_ed25519_address: from_ed25519_address,
                amount: 0, // Always 0 for bridge operations
                gcr_edits: [], // Will be generated by demos.sign()
                nonce: nonce + 1,
                timestamp: Date.now(),
                transaction_fee: {
                    network_fee: 0,
                    rpc_fee: 0,
                    additional_fee: 0,
                },
            },
            signature: {
                type: "ed25519",
                data: "",
            },
            hash: "",
            status: "empty",
            blockNumber: 0,
            ed25519_signature: ""
        };
        // Use demos.sign() which handles GCR generation, hashing, and signing
        const signedTx = await demos.sign(tx);
        // NOTE: Client must call demos.confirm(signedTx) then demos.broadcast(validationData)
        // to complete the transaction flow, following the same pattern as pay() transactions
        return signedTx;
    },
    /**
     * Generates gasless bridge operation signature for meta-transaction
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns Signature for gasless bridge operation authorization
     */
    generateGaslessBridgeSignature(userPrivateKey, userPublicKey, nonce, originChain, destChain, token, recipient, amount, bridgeFeeBps = 0) {
        // Create the same message format as used in smart contract and node validation
        const messageData = {
            action: "LIQUIDITY_TANK_BRIDGE",
            user: userPublicKey,
            nonce: nonce,
            originChain: originChain,
            destChain: destChain,
            token: token,
            recipient: recipient,
            amount: amount,
            bridgeFeeBps: bridgeFeeBps
        };
        const messageHash = encryption_1.Hashing.sha256(JSON.stringify(messageData));
        const signature = encryption_1.Cryptography.sign(messageHash, userPrivateKey);
        return (0, encryption_1.uint8ArrayToHex)(signature);
    },
    /**
     * Generates gasless deposit signature for USDC deposits
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param usdcAddress USDC contract address
     * @param amount Amount to deposit
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @returns Signature for gasless deposit authorization
     */
    generateGaslessDepositSignature(userPrivateKey, userPublicKey, nonce, usdcAddress, amount, chainKey) {
        // Create the same message format as used in smart contract and node validation
        const messageData = {
            action: "LIQUIDITY_TANK_DEPOSIT",
            user: userPublicKey,
            nonce: nonce,
            usdcAddress: usdcAddress,
            amount: amount,
            chainKey: chainKey
        };
        const messageHash = encryption_1.Hashing.sha256(JSON.stringify(messageData));
        const signature = encryption_1.Cryptography.sign(messageHash, userPrivateKey);
        return (0, encryption_1.uint8ArrayToHex)(signature);
    },
    /**
     * Initiates a gasless bridge operation through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns RPC request for gasless bridge initiation
     */
    generateGaslessBridgeOperation(userPublicKey, signature, nonce, originChain, destChain, token, recipient, amount, bridgeFeeBps = 0) {
        const nodeCallPayload = {
            method: "initiateGaslessBridge",
            params: [{
                    user: userPublicKey,
                    signature: signature,
                    nonce: nonce,
                    originChain: originChain,
                    destChain: destChain,
                    token: token,
                    recipient: recipient,
                    amount: amount,
                    bridgeFeeBps: bridgeFeeBps
                }]
        };
        return nodeCallPayload;
    },
    /**
     * Executes a gasless USDC deposit through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @param usdcAddress USDC contract address
     * @param amount Amount to deposit
     * @returns RPC request for gasless deposit execution
     */
    generateGaslessDepositOperation(userPublicKey, signature, nonce, chainKey, usdcAddress, amount) {
        const nodeCallPayload = {
            method: "executeGaslessDeposit",
            params: [{
                    user: userPublicKey,
                    signature: signature,
                    nonce: nonce,
                    chainKey: chainKey,
                    usdcAddress: usdcAddress,
                    amount: amount
                }]
        };
        return nodeCallPayload;
    },
    /**
     * Complete gasless bridge flow helper - combines signature generation and operation creation
     * @param userPrivateKey User's private key for signing
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param originChain Origin chain name
     * @param destChain Destination chain name
     * @param token Token contract address
     * @param recipient Recipient address
     * @param amount Amount to bridge
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @returns Object with signature and RPC request for gasless bridge
     */
    generateCompleteGaslessBridge(userPrivateKey, userPublicKey, nonce, originChain, destChain, token, recipient, amount, bridgeFeeBps = 0) {
        // Generate signatures
        const bridgeSignature = this.generateGaslessBridgeSignature(userPrivateKey, userPublicKey, nonce, originChain, destChain, token, recipient, amount, bridgeFeeBps);
        const depositSignature = this.generateGaslessDepositSignature(userPrivateKey, userPublicKey, nonce + 1, token, amount, `${originChain.toLowerCase()}.${process.env.NODE_ENV === 'production' ? 'mainnet' : 'sepolia'}`);
        // Generate operations
        const bridgeOperation = this.generateGaslessBridgeOperation(userPublicKey, bridgeSignature, nonce, originChain, destChain, token, recipient, amount, bridgeFeeBps);
        const depositOperation = this.generateGaslessDepositOperation(userPublicKey, depositSignature, nonce + 1, `${originChain.toLowerCase()}.${process.env.NODE_ENV === 'production' ? 'mainnet' : 'sepolia'}`, token, amount);
        return {
            signature: bridgeSignature,
            bridgeOperation,
            depositOperation
        };
    },
    /**
     * Generates atomic deposit and bridge signature for the new combined method
     * @param userPrivateKey User's private key for signing gasless authorization
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge (must be equal)
     * @param destChain Destination chain name
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @param chainId Chain ID for signature verification
     * @param contractAddress Contract address for signature verification
     * @returns Signature for atomic deposit and bridge authorization
     */
    generateAtomicDepositAndBridgeSignature(userPrivateKey, userPublicKey, nonce, tokenName, depositAmount, destChain, recipient, bridgeFeeBps = 0, chainId, contractAddress) {
        // Create the same message format as used in smart contract verification
        const messageData = {
            action: "LIQUIDITY_TANK_DEPOSIT_AND_BRIDGE",
            user: userPublicKey,
            nonce: nonce,
            tokenName: tokenName,
            depositAmount: depositAmount,
            originChain: chainId.toString(), // Automatically detected from block.chainid
            destChain: destChain,
            recipient: recipient,
            bridgeFeeBps: bridgeFeeBps,
            chainId: chainId,
            contractAddress: contractAddress
        };
        const messageHash = encryption_1.Hashing.sha256(JSON.stringify(messageData));
        const signature = encryption_1.Cryptography.sign(messageHash, userPrivateKey);
        return (0, encryption_1.uint8ArrayToHex)(signature);
    },
    /**
     * Executes atomic gasless deposit and bridge through Demos RPC
     * @param userPublicKey User's public key (address)
     * @param signature User's signature for gasless authorization
     * @param nonce User nonce for replay protection
     * @param chainKey Chain key (e.g., "eth.sepolia")
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge
     * @param destChain Destination chain name
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points
     * @returns RPC request for atomic deposit and bridge execution
     */
    generateAtomicDepositAndBridgeOperation(userPublicKey, signature, nonce, chainKey, tokenName, depositAmount, destChain, recipient, bridgeFeeBps = 0) {
        const nodeCallPayload = {
            method: "executeAtomicDepositAndBridge",
            params: [{
                    user: userPublicKey,
                    signature: signature,
                    nonce: nonce,
                    chainKey: chainKey,
                    tokenName: tokenName,
                    depositAmount: depositAmount,
                    destChain: destChain,
                    recipient: recipient,
                    bridgeFeeBps: bridgeFeeBps
                }]
        };
        return nodeCallPayload;
    },
    /**
     * RECOMMENDED: Complete atomic deposit and bridge flow helper
     * @param userPrivateKey User's private key for signing
     * @param userPublicKey User's public key (address)
     * @param nonce User nonce for replay protection
     * @param tokenName Human-readable token name (e.g., "usdc", "eth")
     * @param depositAmount Amount to deposit and bridge (equal values)
     * @param destChain Destination chain name (origin chain is automatic)
     * @param recipient Recipient address
     * @param bridgeFeeBps Bridge fee in basis points (optional)
     * @param chainId Chain ID (for signature verification)
     * @param contractAddress Contract address (for signature verification)
     * @param chainKey Chain key format (e.g., "eth.sepolia")
     * @returns Object with signature and RPC request for atomic operation
     */
    generateAtomicDepositAndBridge(userPrivateKey, userPublicKey, nonce, tokenName, depositAmount, destChain, recipient, bridgeFeeBps = 0, chainId = 11155111, // Default to Sepolia
    contractAddress = "0x...", // Should be provided by caller
    chainKey = "eth.sepolia") {
        // REVIEW: Generate signature for the atomic operation
        const signature = this.generateAtomicDepositAndBridgeSignature(userPrivateKey, userPublicKey, nonce, tokenName, depositAmount, destChain, recipient, bridgeFeeBps, chainId, contractAddress);
        // REVIEW: Generate the atomic operation RPC request
        const operation = this.generateAtomicDepositAndBridgeOperation(userPublicKey, signature, nonce, chainKey, tokenName, depositAmount, destChain, recipient, bridgeFeeBps);
        return {
            signature,
            operation
        };
    }
};
//# sourceMappingURL=nativeBridge.js.map