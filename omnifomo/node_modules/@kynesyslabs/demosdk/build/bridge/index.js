"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RubicBridge = exports.supportedNonEVMChains = exports.supportedEVMChains = exports.NativeBridgeUSDCAbi = exports.NativeBridgeUSDCContracts = exports.NativeBridgeSupportedEVMChains = exports.NativeBridgeSupportedStablecoins = exports.NativeBridgeSupportedChains = exports.NativeBridgeMethods = exports.RubicSdkError = exports.CrossChainTrade = exports.CROSS_CHAIN_TRADE_TYPE = exports.BLOCKCHAIN_NAME = exports.SupportedTokens = exports.SupportedChains = exports.ChainProviders = void 0;
exports.validateChain = validateChain;
var constants_1 = require("../types/bridge/constants");
Object.defineProperty(exports, "ChainProviders", { enumerable: true, get: function () { return constants_1.ChainProviders; } });
Object.defineProperty(exports, "SupportedChains", { enumerable: true, get: function () { return constants_1.SupportedChains; } });
Object.defineProperty(exports, "SupportedTokens", { enumerable: true, get: function () { return constants_1.SupportedTokens; } });
const rubicBridge_1 = __importDefault(require("./rubicBridge"));
exports.RubicBridge = rubicBridge_1.default;
var rubic_sdk_1 = require("rubic-sdk");
Object.defineProperty(exports, "BLOCKCHAIN_NAME", { enumerable: true, get: function () { return rubic_sdk_1.BLOCKCHAIN_NAME; } });
Object.defineProperty(exports, "CROSS_CHAIN_TRADE_TYPE", { enumerable: true, get: function () { return rubic_sdk_1.CROSS_CHAIN_TRADE_TYPE; } });
Object.defineProperty(exports, "CrossChainTrade", { enumerable: true, get: function () { return rubic_sdk_1.CrossChainTrade; } });
Object.defineProperty(exports, "RubicSdkError", { enumerable: true, get: function () { return rubic_sdk_1.RubicSdkError; } });
const nativeBridge_1 = require("./nativeBridge");
Object.defineProperty(exports, "NativeBridgeMethods", { enumerable: true, get: function () { return nativeBridge_1.methods; } });
const nativeBridgeTypes_1 = require("./nativeBridgeTypes");
// Export types from nativeBridgeTypes
var nativeBridgeTypes_2 = require("./nativeBridgeTypes");
Object.defineProperty(exports, "NativeBridgeSupportedChains", { enumerable: true, get: function () { return nativeBridgeTypes_2.supportedChains; } });
Object.defineProperty(exports, "NativeBridgeSupportedStablecoins", { enumerable: true, get: function () { return nativeBridgeTypes_2.supportedStablecoins; } });
Object.defineProperty(exports, "NativeBridgeSupportedEVMChains", { enumerable: true, get: function () { return nativeBridgeTypes_2.supportedEVMChains; } });
Object.defineProperty(exports, "NativeBridgeUSDCContracts", { enumerable: true, get: function () { return nativeBridgeTypes_2.usdcContracts; } });
Object.defineProperty(exports, "NativeBridgeUSDCAbi", { enumerable: true, get: function () { return nativeBridgeTypes_2.usdcAbi; } });
Object.defineProperty(exports, "supportedEVMChains", { enumerable: true, get: function () { return nativeBridgeTypes_2.supportedEVMChains; } });
Object.defineProperty(exports, "supportedNonEVMChains", { enumerable: true, get: function () { return nativeBridgeTypes_2.supportedNonEVMChains; } });
// Export standalone validateChain function
function validateChain(chain, isOrigin) {
    // Determine chain type based on supported chains
    let chainType;
    if (nativeBridgeTypes_1.supportedEVMChains.includes(chain)) {
        chainType = "EVM";
    }
    else if (nativeBridgeTypes_1.supportedNonEVMChains.includes(chain)) {
        chainType = "SOLANA";
    }
    else {
        const chainTypeStr = isOrigin ? "origin" : "destination";
        throw new Error(`Invalid ${chainTypeStr} chain: ${chain} is not supported`);
    }
    // Use the bridge's validation method directly
    nativeBridge_1.methods.validateChain(chain, chainType, isOrigin);
}
//# sourceMappingURL=index.js.map