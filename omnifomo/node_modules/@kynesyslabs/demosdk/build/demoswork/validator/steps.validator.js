"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noUnusedSteps = noUnusedSteps;
const types_1 = require("../../types");
function getMappedScriptSteps(script) {
    // return a map of step ids mapped to their descriptions
    return new Map(Object.keys(script.steps).map(step => [
        step,
        script.steps[step].description,
    ]));
}
function getConditionalScriptSteps(script) {
    let steps = new Set();
    // INFO: Loop through all conditions and add the step to the set
    script.conditions.forEach(condition => {
        const parseValue = (value) => {
            if (value &&
                value.type === types_1.DataTypes.internal &&
                value.workUID.startsWith("step_")) {
                steps.add(value.workUID);
            }
        };
        parseValue(condition.value_a);
        parseValue(condition.value_b);
        if (condition.work && condition.work.startsWith("step_")) {
            steps.add(condition.work);
        }
    });
    return steps;
}
function catchNotIncluded(steps, scriptSteps, message = "") {
    let diff = new Set(Array.from(steps).filter(x => !scriptSteps.has(x)));
    if (diff.size > 0) {
        throw new Error(`Steps ${[...diff]} not included in final script - ${message}`);
    }
}
function extractStepsFromOperation(operation, scriptSteps) {
    let steps = new Set();
    switch (operation.operationType) {
        case "conditional":
            let conditionalSteps = getConditionalScriptSteps(operation);
            steps = new Set([...steps, ...conditionalSteps]);
            break;
        case "base":
            let baseSteps = new Set(operation.order.filter(step => step.startsWith("step_")));
            steps = new Set([...steps, ...baseSteps]);
            break;
    }
    catchNotIncluded(steps, scriptSteps, `${operation.operationType} - ${operation.id}`);
    return steps;
}
function collectAllSteps(script, scriptSteps) {
    let steps = new Set();
    Object.keys(script.operations).forEach(opUID => {
        let operation = script.operations[opUID];
        steps = new Set([...steps, ...extractStepsFromOperation(operation, scriptSteps)]);
    });
    return steps;
}
/**
 * Assert that all steps in the script are consumed by operations
 *
 * @param script The work script to validate
 * @returns true if all steps are used, false otherwise
 */
function noUnusedSteps(script) {
    // NOTES: Collect all steps in the script
    // and compare them to the script steps
    let scriptSteps = getMappedScriptSteps(script);
    let steps = collectAllSteps(script, scriptSteps);
    for (const id of scriptSteps.keys()) {
        if (!steps.has(id)) {
            throw new Error(`Step ${scriptSteps.get(id) || id} not used in script`);
        }
    }
}
//# sourceMappingURL=steps.validator.js.map