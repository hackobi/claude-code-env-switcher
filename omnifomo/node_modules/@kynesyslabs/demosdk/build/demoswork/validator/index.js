"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSanityChecks = runSanityChecks;
const steps_validator_1 = require("./steps.validator");
function dependsOnIsAnArrayOfWorkUIDs(script) {
    const validPrefixes = ["step_", "op_"];
    const errors = [];
    const allWorkUIDs = new Set([
        ...Object.keys(script.operations),
        ...Object.keys(script.steps),
    ]);
    function checkDependencies(item, itemType) {
        const invalidDep = item.depends_on.find(dep => !validPrefixes.some(prefix => dep.startsWith(prefix)));
        if (invalidDep) {
            errors.push(`${itemType} ${
            // @ts-ignore
            item.description || item.id} depends on an invalid work UID: ${invalidDep}`);
        }
        item.depends_on.forEach(dep => {
            if (!allWorkUIDs.has(dep)) {
                errors.push(`${itemType} ${item.id} depends on a non-existent work UID: ${dep}`);
            }
        });
    }
    Object.entries(script.operations).forEach(([key, operation]) => checkDependencies({ ...operation, id: key }, "Operation"));
    Object.entries(script.steps).forEach(([key, step]) => checkDependencies({ ...step, id: key }, "Step"));
    if (errors.length > 0) {
        throw new Error("Invalid dependencies found:\n" + errors.join("\n"));
    }
}
/**
 * Validates a work script. Checks for common errors.
 *
 * @param work The work script to validate
 */
function runSanityChecks(script) {
    (0, steps_validator_1.noUnusedSteps)(script);
    dependsOnIsAnArrayOfWorkUIDs(script);
    // TODO: Add check to ensure operation reference order does not conflict with
    // defined operations order in the final script
    // TODO: Check for circular references!
}
//# sourceMappingURL=index.js.map