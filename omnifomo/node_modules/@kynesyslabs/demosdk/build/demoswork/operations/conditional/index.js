"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionalOperation = void 0;
const demoswork_1 = require("../..");
const types_1 = require("../../../types");
const __1 = require("..");
class ConditionalOperation extends __1.DemosWorkOperation {
    constructor(...conditions) {
        super();
        this.type = "conditional";
        this.tempCondition = null;
        this.operationScript = {
            id: this.id,
            operationType: "conditional",
            critical: true,
            depends_on: [],
            conditions: new Map(),
            order: [],
        };
        for (const condition of conditions) {
            this.appendCondition(condition);
        }
    }
    indexCondition(condition) {
        // INFO: copy condition action to the operation
        if (condition.action) {
            this.addWork(condition.action);
        }
        this.operationScript.conditions.set(condition.id, {
            operator: condition.operator,
            value_a: this.parseConditionValue(condition.value_a),
            value_b: this.parseConditionValue(condition.value_b),
            ...(condition.action ? { work: condition.action.id } : {}),
        });
        return {
            type: types_1.DataTypes.internal,
            workUID: condition.id,
            key: "output.result",
        };
    }
    parseConditionValue(value) {
        // converts condition values into the script format
        if (value instanceof demoswork_1.Condition) {
            this.indexCondition(value);
            return {
                type: types_1.DataTypes.internal,
                workUID: value.id,
                key: null,
            };
        }
        return value;
    }
    appendCondition(condition) {
        for (const work of condition.work.values()) {
            this.addWork(work);
        }
        delete condition.work;
        const entry = {
            operator: condition.operator,
            value_a: this.parseConditionValue(condition.value_a),
            value_b: this.parseConditionValue(condition.value_b),
        };
        // if there is an action, the condition comes from the constructor
        // ie. is a fully formed condition.
        this.addWork(condition.action);
        this.operationScript.conditions.set(condition.id, {
            ...entry,
            ...(condition.action ? { work: condition.action.id } : {})
        });
        return this.operationScript.order.push(condition.id);
    }
    // SECTION: CONDITIONAL OPERATION METHODS
    if(value_a, operator, value_b) {
        let conditionEntry = new demoswork_1.Condition({
            action: null,
            value_a: value_a,
            value_b: value_b,
            operator: operator,
        });
        this.tempCondition = conditionEntry;
        return {
            then: this.then.bind(this),
        };
    }
    then(step) {
        // update the last item in the temp conditions
        // and push it to the operation script
        this.tempCondition.action = step;
        this.appendCondition(this.tempCondition);
        this.tempCondition = null;
        return {
            elif: this.if.bind(this),
            else: this.else.bind(this),
        };
    }
    else(step) {
        const condition = new demoswork_1.Condition({
            operator: null,
            value_a: null,
            value_b: null,
            action: step,
        });
        // INFO: Override value formatting
        condition.value_a = null;
        condition.value_b = null;
        return this.appendCondition(condition);
    }
}
exports.ConditionalOperation = ConditionalOperation;
//# sourceMappingURL=index.js.map