"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RSA = void 0;
const node_forge_1 = __importDefault(require("node-forge"));
const DemosWebAuth_1 = require("./DemosWebAuth");
const required_1 = require("./utils/required");
// INFO This class is to be used as part of DemosWebAuthenticator (e.g. DemosWebAuth.getInstance().rsa().refresh())
class RSA {
    constructor() {
        this.keypair = null;
        this.stringified_keypair = "";
    }
    // INFO Singleton pattern
    static getInstance() {
        if (!RSA._instance) {
            RSA._instance = new RSA();
        }
        return RSA._instance;
    }
    // INFO Generating, if possible, a RSA keypair
    // NOTE Derived from DemosWebAuth keypairs
    refresh() {
        let pre_seed = null;
        if (DemosWebAuth_1.DemosWebAuth.getInstance().stringified_keypair) {
            pre_seed = DemosWebAuth_1.DemosWebAuth.getInstance().stringified_keypair.privateKey;
        }
        else
            throw new Error('RSA Keypair cannot be generated without a proper ECDSA authentication');
        // If we are here, we can proceed and fill DemosWebAuth instance
        const seed = this.seedForger(pre_seed);
        const pseudorandom = this.PRNG(seed);
        this.keypair = node_forge_1.default.pki.rsa.generateKeyPair({ bits: 4096, prng: pseudorandom });
        this.stringified_keypair = JSON.stringify(this.keypair);
    }
    // INFO Generating a pseudo-random from a seed
    PRNG(seed) {
        const prng = node_forge_1.default.random.createInstance();
        prng.seedFileSync = () => seed;
        return prng;
    }
    // INFO Generating a seed in the right format from a string
    seedForger(pre_seed) {
        const md = node_forge_1.default.md.sha256.create();
        md.update(pre_seed);
        return md.digest().toHex();
    }
    // INFO Encrypting a message using the RSA keypair
    self_encrypt(message) {
        if (!(0, required_1.required)(this.keypair)) {
            throw new Error('RSA Keypair cannot be generated without a proper ECDSA keypair');
        }
        if (!(typeof (message) === 'string')) {
            message = JSON.stringify(message);
        }
        const encoded = node_forge_1.default.util.encode64(message);
        const encrypted = this.keypair.publicKey.encrypt(encoded);
        return node_forge_1.default.util.encode64(encrypted);
    }
    /**
       * @param {forge.pki.rsa.PublicKey} public_key
       */
    encrypt(public_key, message) {
        if (!(typeof (message) === 'string')) {
            message = JSON.stringify(message);
        }
        const encoded = node_forge_1.default.util.encode64(message);
        const encrypted = public_key.encrypt(encoded);
        return node_forge_1.default.util.encode64(encrypted);
    }
    // INFO Decrypting a message using the RSA keypair
    decrypt(message) {
        if (!(0, required_1.required)(this.keypair)) {
            throw new Error('RSA Keypair cannot be generated without a proper ECDSA keypair');
        }
        const debased_encrypted = node_forge_1.default.util.decode64(message);
        const raw_decrypted = this.keypair.privateKey.decrypt(debased_encrypted);
        const decrypted = node_forge_1.default.util.decode64(raw_decrypted);
        return decrypted;
    }
}
exports.RSA = RSA;
RSA._instance = null;
//# sourceMappingURL=rsa.js.map