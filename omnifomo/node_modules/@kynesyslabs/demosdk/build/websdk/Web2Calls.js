"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.web2Calls = exports.Web2Proxy = void 0;
const types_1 = require("../types");
const skeletons_1 = require("./utils/skeletons");
const DemosTransactions_1 = require("./DemosTransactions");
const canonicalJson_1 = require("./utils/canonicalJson");
class Web2InvalidUrlError extends Error {
    constructor(message, code) {
        super(message);
        this.name = "Web2InvalidUrlError";
        this.code = code;
    }
}
function getCanonicalHttpUrlOrThrow(input) {
    if (typeof input !== "string") {
        throw new Web2InvalidUrlError("URL must be a string", "INVALID_URL_TYPE");
    }
    const trimmed = input.trim();
    if (!trimmed) {
        throw new Web2InvalidUrlError("URL is required for startProxy and cannot be empty.", "EMPTY_URL");
    }
    let u;
    try {
        u = new URL(trimmed);
    }
    catch {
        throw new Web2InvalidUrlError("Invalid URL provided to startProxy. Only http(s) URLs are allowed.", "INVALID_URL");
    }
    if (u.protocol !== "http:" && u.protocol !== "https:") {
        throw new Web2InvalidUrlError("Invalid URL provided to startProxy. Only http(s) URLs are allowed.", "INVALID_URL");
    }
    if (u.username || u.password || !u.hostname) {
        throw new Web2InvalidUrlError("Invalid URL provided to startProxy. Only http(s) URLs without embedded credentials are allowed.", "INVALID_URL");
    }
    // Avoid persisting potential secrets in fragments (e.g., OAuth implicit flow tokens)
    u.hash = "";
    // Normalize default ports
    if ((u.protocol === "http:" && u.port === "80") ||
        (u.protocol === "https:" && u.port === "443")) {
        u.port = "";
    }
    return u.toString(); // canonical form
}
class Web2Proxy {
    constructor(sessionId, demos) {
        this._sessionId = sessionId;
        this._demos = demos;
    }
    /**
     * Get the session ID.
     * @returns {string} The session ID.
     */
    get sessionId() {
        return this._sessionId;
    }
    /**
     * Start the proxy.
     * @param {IStartProxyParams} params - The parameters for starting the proxy.
     * @returns {Promise<IWeb2Result>} The result of the proxy.
     */
    async startProxy({ url, method, options = {
        headers: {},
        payload: undefined,
        authorization: "",
    }, }) {
        const canonicalUrl = getCanonicalHttpUrlOrThrow(url);
        // Create a fresh copy of web2Request for each call
        const freshWeb2Request = { ...skeletons_1.web2_request };
        // Shallow-merge headers without mutating caller's object
        const callerHeaders = options?.headers ? { ...options.headers } : {};
        freshWeb2Request.raw = {
            ...freshWeb2Request.raw,
            action: types_1.EnumWeb2Actions.START_PROXY,
            method,
            url: canonicalUrl,
            headers: callerHeaders,
        };
        // Validate and canonicalize
        let canonicalPayload = undefined;
        if (options?.payload !== undefined) {
            if (typeof options.payload === "object") {
                (0, canonicalJson_1.validatePureJson)(options.payload);
                canonicalPayload = (0, canonicalJson_1.canonicalJSONStringify)(options.payload);
                // Only set JSON content-type if not already set by caller
                if (!Object.keys(callerHeaders).some(h => h.toLowerCase() === "content-type")) {
                    callerHeaders["Content-Type"] = "application/json";
                }
            }
            else if (typeof options.payload === "string") {
                // Heuristic warning for accidental double-stringify
                if ((0, canonicalJson_1.looksLikeJsonString)(options.payload)) {
                    console.warn("[Web2Calls] String payload looks like JSON. It will be used as raw bytes; if you intended object canonicalization, pass the object instead.");
                }
                canonicalPayload = options.payload;
            }
            else {
                // numbers/booleans/null are allowed by fetch/XHR as body. Use JSON.stringify semantics explicitly
                canonicalPayload = JSON.stringify(options.payload);
                if (!Object.keys(callerHeaders).some(h => h.toLowerCase() === "content-type")) {
                    callerHeaders["Content-Type"] = "application/json";
                }
            }
        }
        const response = await this._demos.call("web2ProxyRequest", {
            web2Request: freshWeb2Request,
            sessionId: this._sessionId,
            payload: canonicalPayload, // can be undefined â‡’ no body
            authorization: options?.authorization,
        });
        const web2Payload = {
            message: {
                sessionId: this._sessionId,
                payload: "",
                authorization: "",
                web2Request: {
                    ...freshWeb2Request,
                    result: {
                        sessionId: this._sessionId,
                        targetUrl: freshWeb2Request.raw.url,
                        timestamp: Date.now(),
                        status: response.response.status,
                        headers: response.response.headers,
                        responseHash: response.response.responseHash,
                        responseHeadersHash: response.response.responseHeadersHash,
                        ...(response.response.requestHash
                            ? { requestHash: response.response.requestHash }
                            : {}),
                        statusText: response.response.statusText,
                    },
                },
            },
        };
        // Create a transaction to store the web2 payload in the blockchain.
        const web2Tx = DemosTransactions_1.DemosTransactions.empty();
        web2Tx.content.to = await this._demos.getEd25519Address();
        web2Tx.content.type = "web2Request";
        web2Tx.content.data = ["web2Request", web2Payload];
        web2Tx.content.timestamp = Date.now();
        const signedWeb2Tx = await this._demos.sign(web2Tx);
        const validityData = await this._demos.confirm(signedWeb2Tx);
        const txHash = validityData.response.data.transaction.hash;
        await this._demos.broadcast(validityData);
        const result = {
            ...response.response,
            txHash,
        };
        return result;
    }
}
exports.Web2Proxy = Web2Proxy;
/**
 * The Web2Calls object provides functions for creating and managing Web2 proxies.
 */
exports.web2Calls = {
    /**
     * Create a new DAHR instance.
     * @param {Demos} demos - The demos instance to use for the request.
     * @returns {Promise<Web2Proxy>} A new Web2Proxy instance.
     */
    createDahr: async (demos) => {
        const usedKeyPair = demos.keypair;
        if (!usedKeyPair) {
            throw new Error("No keypair provided and no wallet connected");
        }
        // Create a fresh copy of web2Request for creation
        const freshWeb2Request = { ...skeletons_1.web2_request };
        freshWeb2Request.raw = {
            ...freshWeb2Request.raw,
            action: types_1.EnumWeb2Actions.CREATE,
        };
        const response = await demos.call("web2ProxyRequest", {
            web2Request: freshWeb2Request,
        });
        const sessionId = response.response?.dahr?.sessionId;
        if (!sessionId) {
            throw new Error("Failed to create proxy session");
        }
        return new Web2Proxy(sessionId, demos);
    },
};
//# sourceMappingURL=Web2Calls.js.map