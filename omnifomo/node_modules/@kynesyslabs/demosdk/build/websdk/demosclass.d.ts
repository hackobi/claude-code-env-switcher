import { Buffer } from "buffer/";
import * as skeletons from "./utils/skeletons";
import { DemosWebAuth } from "./DemosWebAuth";
import { Block, IPeer, RawTransaction, SigningAlgorithm, Transaction, TransactionContent, XMScript } from "../types";
import { AddressInfo } from "../types/blockchain/address";
import { RPCRequest, RPCResponse, RPCResponseWithValidityData } from "../types/communication/rpc";
import { IKeyPair } from "./types/KeyPair";
import { UnifiedCrypto } from "../encryption/unifiedCrypto";
import { TweetSimplified } from "../types";
import { GetDiscordMessageResult } from "../types/web2/discord";
/**
 * This class provides methods to interact with the DEMOS blockchain.
 */
export declare class Demos {
    algorithm: SigningAlgorithm;
    crypto: UnifiedCrypto;
    private static _instance;
    /** The RPC URL of the demos node */
    private rpc_url;
    /** Connection status of the RPC URL */
    connected: boolean;
    dual_sign: boolean;
    /** Connection status of the wallet */
    get walletConnected(): boolean;
    /** The keypair of the connected wallet */
    get keypair(): {
        publicKey: import("node-forge").pki.ed25519.NativeBuffer;
        privateKey: import("node-forge").pki.ed25519.NativeBuffer;
    };
    constructor();
    static get instance(): Demos;
    /**
     * Generates a new mnemonic.
     *
     * @param strength - The strength of the mnemonic in bits. (128 bits = 12 words, 256 bits = 24 words). Default is 128 bits.
     * @returns The mnemonic
     */
    newMnemonic(strength?: 128 | 256): string;
    /**
     * Connects to a RPC URL. Throws an error if the connection fails.
     *
     * @param rpc_url - The URL of the demos node
     * @returns Whether the connection was successful
     */
    connect(rpc_url: string): Promise<boolean>;
    /**
     * Connects to a Demos wallet using the provided master seed.
     *
     * @param masterSeed - The master seed of the wallet
     * @param algorithm - The algorithm to use for the wallet
     * @param options - The options for the wallet connection
     * @param options.algorithm - The algorithm to use for the wallet
     * @param options.dual_sign - Whether to include the ed25519 signature along with the PQC signature, when
     * signing with unlinked PQC keypairs (i.e. PQC keypairs not linked to your ed25519 address on the network).
     *
     * @returns The public key of the wallet
     */
    connectWallet(masterSeed: string | Uint8Array, options?: {
        algorithm?: SigningAlgorithm;
        /**
         * Whether to include the ed25519 signature along with the PQC signature, when
         * signing with unlinked PQC keypairs (i.e. PQC keypairs not linked to your ed25519 address on the network).
         */
        dual_sign?: boolean;
    }): Promise<string>;
    /**
     * Returns the public key of the connected wallet.
     *
     * @returns The public key of the wallet
     */
    getAddress(): string;
    /**
     * Returns the ed25519 address of the connected wallet.
     *
     */
    getEd25519Address(): Promise<string>;
    /**
     * Generates a random MUID.
     *
     * @returns The MUID
     */
    generateMuid(): string;
    /**
     * Create a signed DEMOS transaction to send native tokens to a given address.
     *
     * @param to - The reciever
     * @param amount - The amount in DEM
     *
     * @returns The signed transaction.
     */
    pay(to: string, amount: number): Promise<Transaction>;
    /**
     * Create a signed DEMOS transaction to send native tokens to a given address.
     *
     * @param to - The reciever
     * @param amount - The amount in DEM
     *
     * @returns The signed transaction.
     */
    transfer(to: string, amount: number): Promise<Transaction>;
    /**
     * Create a signed DEMOS transaction to store binary data on the blockchain.
     * Data is stored in the sender's account.
     *
     * @param bytes - The binary data to store
     *
     * @returns The signed storage transaction.
     */
    store(bytes: Uint8Array): Promise<Transaction>;
    /**
     * Confirms a transaction.
     *
     * @param transaction - The transaction to confirm
     * @returns The validity data of the transaction containing the gas information.
     */
    confirm(transaction: Transaction): Promise<RPCResponseWithValidityData>;
    /**
     * Broadcasts a transaction for execution.
     *
     * @param validationData - The validity data of the transaction
     * @returns The response from the node
     */
    broadcast(validationData: RPCResponseWithValidityData): Promise<any>;
    /**
     * Signs a transaction.
     *
     * @param raw_tx - The transaction to sign
     * @param options - The dual-signing options
     * @returns The signed transaction
     */
    sign(raw_tx: Transaction): Promise<Transaction>;
    /**
     * Signs a message.
     *
     * @param message - The message to sign
     * @param options - The options for the message signing
     * @param options.algorithm - The algorithm to use for the message signing. Defaults to the connected wallet's algorithm.
     * @returns The signature of the message
     */
    signMessage(message: string | Buffer, options?: {
        algorithm?: SigningAlgorithm;
    }): Promise<{
        type: SigningAlgorithm;
        data: string;
    }>;
    /**
     * Verifies a message.
     *
     * @param message - The message to verify
     * @param signature - The signature of the message
     * @param publicKey - The public key of the message
     * @param options - The options for the message verification
     * @param options.algorithm - The algorithm to use for the message verification. Defaults to the connected wallet's algorithm or ed25519 if no wallet is connected.
     *
     * @returns Whether the message is verified
     */
    verifyMessage(message: string | Buffer, signature: string, publicKey: string, options?: {
        algorithm?: SigningAlgorithm;
    }): Promise<boolean>;
    /**
     * @private
     * Calculates and applies the gas fee for a transaction (SDK-level fallback).
     * NOTE: We infer the fee by analyzing the generated GCR (Gas Consumption Record) edits:
     * - Sum all "balance" edits with operation "remove" for the sender
     * - Subtract the declared transaction `amount`
     * The remainder is treated as the network fee. If a fee already exists on the tx, we only raise
     * `network_fee` if the newly inferred fee is higher (prevents double-charging on re-sign).
     * This is an interim approach; the preferred design is for the node to return fees explicitly.
     *
     * @param raw_tx - The transaction for which to calculate the fee.
     * @returns The updated transaction with the fee applied.
     */
    private _calculateAndApplyGasFee;
    rpcCall(request: RPCRequest, isAuthenticated?: boolean, retries?: number, sleepTime?: number, allowedErrorCodes?: number[]): Promise<RPCResponse>;
    call(method: any, message: any, data?: any, extra?: any, sender?: any, receiver?: any): Promise<any>;
    /**
     * Performs a nodeCall on the connected RPC.
     *
     * @param message - The message to send to the node
     * @param args - The arguments to send to the node
     *
     * @returns The nodeCall response
     */
    nodeCall(message: any, args?: {}): Promise<any>;
    /**
     * Get the last block number.
     */
    getLastBlockNumber(): Promise<number>;
    /**
     * Get the last block hash.
     */
    getLastBlockHash(): Promise<string | null>;
    /**
     * Get list of blocks.
     *
     */
    getBlocks(start?: number | "latest", limit?: number): Promise<Block[]>;
    /**
     * Get block by number.
     *
     * @param blockNumber - The block number
     */
    getBlockByNumber(blockNumber: number): Promise<Block>;
    /**
     * Get block by hash.
     *
     * @param blockHash - The block hash
     */
    getBlockByHash(blockHash: string): Promise<Block>;
    /**
     * Get transaction by hash.
     *
     * @param txHash - The transaction hash
     */
    getTxByHash(txHash?: string): Promise<Transaction>;
    /**
     * @deprecated
     * Use `demos.getTransactions()` instead
     *
     * Get all transactions.
     */
    getAllTxs(): Promise<RawTransaction[]>;
    /**
     * Get the transaction history of an address.
     *
     * @param address - The address
     * @param type - The type of transaction. Defaults to "all".
     * @param start - The start index. Defaults to 0.
     * @param limit - The number of transactions to return. Defaults to 100.
     *
     * @returns A list of transaction ordered from the most recent to the oldest.
     */
    getTransactionHistory(address: string, type?: TransactionContent["type"] | "all", options?: {
        start?: number;
        limit?: number;
    }): Promise<Transaction[]>;
    /**
     * Get all transactions.
     */
    getTransactions(start?: number | "latest", limit?: number): Promise<RawTransaction[]>;
    /**
     * Get the peerlist.
     */
    getPeerlist(): Promise<IPeer[]>;
    /**
     * Get the mempool.
     */
    getMempool(): Promise<Transaction[]>;
    /**
     * Get the identity of the connected RPC.
     */
    getPeerIdentity(): Promise<string>;
    /**
     * Get information about an address.
     *
     * @param address - The address
     */
    getAddressInfo(address: string): Promise<AddressInfo | null>;
    /**
     * Get address nonce.
     *
     * @param address - The address
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Disconnects from the RPC URL and the wallet.
     */
    disconnect(): void;
    web2: {
        createDahr: () => Promise<import("./Web2Calls").Web2Proxy>;
        getTweet: (tweetUrl: string) => Promise<{
            success: boolean;
            tweet: TweetSimplified;
            error?: string;
        }>;
        getDiscordMessage: (discordUrl: string) => Promise<{
            success: boolean;
            message: GetDiscordMessageResult;
            error?: string;
        }>;
    };
    xm: {
        createPayload: (xm_payload: XMScript, keypair?: IKeyPair) => Promise<Transaction>;
    };
    tx: {
        /**
         * Same as `demos.sign`.
         * Signs a transaction after hashing its content.
         *
         * @param raw_tx - The transaction to be signed.
         */
        sign: (raw_tx: Transaction) => Promise<Transaction>;
        empty: () => Transaction;
        prepare: (data?: any) => Promise<Transaction>;
        pay(to: string, amount: number, demos: Demos): Promise<Transaction>;
        transfer(to: string, amount: number, demos: Demos): Promise<Transaction>;
        signWithAlgorithm: (data: string, keypair: IKeyPair, options: {
            algorithm: SigningAlgorithm;
        }) => Promise<{
            type: SigningAlgorithm;
            data: string;
        }>;
        confirm: (transaction: Transaction, demos: Demos) => Promise<RPCResponseWithValidityData>;
        broadcast: (validationData: RPCResponseWithValidityData, demos: Demos) => Promise<any>;
        store(bytes: Uint8Array, demos: Demos): Promise<Transaction>;
        createL2PSHashUpdate(l2psUid: string, consolidatedHash: string, transactionCount: number, demos: Demos): Promise<Transaction>;
    };
    DemosTransactions: {
        empty: () => Transaction;
        prepare: (data?: any) => Promise<Transaction>;
        pay(to: string, amount: number, demos: Demos): Promise<Transaction>;
        transfer(to: string, amount: number, demos: Demos): Promise<Transaction>;
        sign: (raw_tx: Transaction, keypair: IKeyPair, options: {
            algorithm: SigningAlgorithm;
        }) => Promise<Transaction>;
        signWithAlgorithm: (data: string, keypair: IKeyPair, options: {
            algorithm: SigningAlgorithm;
        }) => Promise<{
            type: SigningAlgorithm;
            data: string;
        }>;
        confirm: (transaction: Transaction, demos: Demos) => Promise<RPCResponseWithValidityData>;
        broadcast: (validationData: RPCResponseWithValidityData, demos: Demos) => Promise<any>;
        store(bytes: Uint8Array, demos: Demos): Promise<Transaction>;
        createL2PSHashUpdate(l2psUid: string, consolidatedHash: string, transactionCount: number, demos: Demos): Promise<Transaction>;
    };
    transactions: {
        empty: () => Transaction;
        prepare: (data?: any) => Promise<Transaction>;
        pay(to: string, amount: number, demos: Demos): Promise<Transaction>;
        transfer(to: string, amount: number, demos: Demos): Promise<Transaction>;
        sign: (raw_tx: Transaction, keypair: IKeyPair, options: {
            algorithm: SigningAlgorithm;
        }) => Promise<Transaction>;
        signWithAlgorithm: (data: string, keypair: IKeyPair, options: {
            algorithm: SigningAlgorithm;
        }) => Promise<{
            type: SigningAlgorithm;
            data: string;
        }>;
        confirm: (transaction: Transaction, demos: Demos) => Promise<RPCResponseWithValidityData>;
        broadcast: (validationData: RPCResponseWithValidityData, demos: Demos) => Promise<any>;
        store(bytes: Uint8Array, demos: Demos): Promise<Transaction>;
        createL2PSHashUpdate(l2psUid: string, consolidatedHash: string, transactionCount: number, demos: Demos): Promise<Transaction>;
    };
    DemosWebAuth: typeof DemosWebAuth;
    skeletons: typeof skeletons;
}
