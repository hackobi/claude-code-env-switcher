"use strict";
/**
 * Smart contract functionality for Demos SDK
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DemosContracts = void 0;
const ContractFactory_1 = require("../contracts/ContractFactory");
const TemplateRegistry_1 = require("../contracts/templates/TemplateRegistry");
class DemosContracts {
    constructor(demos) {
        this.demos = demos;
        this.factory = new ContractFactory_1.ContractFactory(demos);
    }
    /**
     * Deploy a new smart contract
     *
     * @example
     * ```typescript
     * const contract = await demos.contracts.deploy(`
     *   class MyToken extends DemosContract {
     *     constructor() {
     *       this.state.set('totalSupply', 1000000)
     *     }
     *   }
     * `)
     * ```
     */
    async deploy(source, constructorArgs = [], options = {}) {
        if (!this.demos.walletConnected) {
            throw new Error('Wallet not connected');
        }
        return await this.factory.deploy(source, constructorArgs, options);
    }
    /**
     * Get an instance of an existing contract
     *
     * @example
     * ```typescript
     * const contract = await demos.contracts.at('contract_address')
     * const result = await contract.call('balanceOf', ['my_address'])
     * ```
     */
    async at(address, abi) {
        return await this.factory.at(address, abi);
    }
    /**
     * Call a contract method directly
     *
     * @example
     * ```typescript
     * const result = await demos.contracts.call(
     *   'contract_address',
     *   'transfer',
     *   ['recipient', 100]
     * )
     * ```
     */
    async call(contractAddress, method, args = [], options = {}) {
        const instance = await this.at(contractAddress);
        return await instance.call(method, args, options);
    }
    /**
     * Create a batch operation
     *
     * @example
     * ```typescript
     * const batch = demos.contracts.batch()
     *   .deploy(tokenContract)
     *   .call(existingContract, 'initialize', [])
     *   .call(anotherContract, 'setOwner', [newOwner])
     *
     * const results = await batch.execute()
     * ```
     */
    batch() {
        return this.factory.batch();
    }
    /**
     * Estimate gas for a contract call
     *
     * @example
     * ```typescript
     * const gasEstimate = await demos.contracts.estimateGas(
     *   'contract_address',
     *   'transfer',
     *   ['recipient', 100]
     * )
     * ```
     */
    async estimateGas(contractAddress, method, args = []) {
        return await this.factory.estimateGas(contractAddress, method, args);
    }
    /**
     * Deploy a contract from a template
     *
     * @example
     * ```typescript
     * const token = await demos.contracts.deployTemplate('Token', {
     *   TOKEN_NAME: 'MyToken',
     *   TOKEN_SYMBOL: 'MTK',
     *   TOTAL_SUPPLY: 1000000,
     *   DECIMALS: 18
     * })
     * ```
     */
    async deployTemplate(templateName, params = {}) {
        if (!this.demos.walletConnected) {
            throw new Error('Wallet not connected');
        }
        // Generate contract source from template
        const result = TemplateRegistry_1.TemplateRegistry.generateContract(templateName, params);
        if (!result.success) {
            const errorMessage = result.errors.join('; ');
            throw new Error(`Template deployment failed: ${errorMessage}`);
        }
        // Extract constructor arguments based on template
        const constructorArgs = this.extractConstructorArgs(templateName, params);
        // Deploy the generated contract
        return await this.deploy(result.source, constructorArgs);
    }
    /**
     * Get available contract templates
     *
     * @example
     * ```typescript
     * const templates = demos.contracts.getAvailableTemplates()
     * // ['Token', 'Storage']
     * ```
     */
    getAvailableTemplates() {
        return TemplateRegistry_1.TemplateRegistry.getAvailableTemplates();
    }
    /**
     * Get template information and parameters
     *
     * @example
     * ```typescript
     * const schema = demos.contracts.getTemplateSchema('Token')
     * console.log(schema.parameters) // List of required/optional parameters
     * ```
     */
    getTemplateSchema(templateName) {
        return TemplateRegistry_1.TemplateRegistry.getTemplateSchema(templateName);
    }
    /**
     * Validate template parameters before deployment
     *
     * @example
     * ```typescript
     * const validation = demos.contracts.validateTemplate('Token', {
     *   TOKEN_NAME: 'MyToken',
     *   TOTAL_SUPPLY: 1000000
     * })
     *
     * if (!validation.valid) {
     *   console.error('Validation errors:', validation.errors)
     * }
     * ```
     */
    validateTemplate(templateName, params) {
        return TemplateRegistry_1.TemplateRegistry.validateParameters(templateName, params);
    }
    /**
     * Get usage example for a template
     *
     * @example
     * ```typescript
     * const example = demos.contracts.getTemplateExample('Token')
     * console.log(example) // Shows deployment and usage example
     * ```
     */
    getTemplateExample(templateName) {
        return TemplateRegistry_1.TemplateRegistry.getTemplateExample(templateName);
    }
    /**
     * Extract constructor arguments from template parameters
     */
    extractConstructorArgs(_templateName, _params) {
        // Templates now have parameters embedded in constructor,
        // so we don't need to pass separate constructor args
        return [];
    }
}
exports.DemosContracts = DemosContracts;
//# sourceMappingURL=DemosContracts.js.map