import { Demos } from "./demosclass";
import type { SigningAlgorithm, Transaction } from "../types";
import { IKeyPair } from "./types/KeyPair";
import { RPCResponseWithValidityData } from "../types/communication/rpc";
export declare const DemosTransactions: {
    empty: () => Transaction;
    prepare: (data?: any) => Promise<Transaction>;
    /**
     * Create a signed DEMOS transaction to send native tokens to a given address.
     *
     * @param to - The reciever
     * @param amount - The amount in DEM
     * @param demos - The demos instance (for getting the address nonce)
     *
     * @returns The signed transaction.
     */
    pay(to: string, amount: number, demos: Demos): Promise<Transaction>;
    /**
     * Create a signed DEMOS transaction to send native tokens to a given address.
     *
     * @param to - The reciever
     * @param amount - The amount in DEM
     * @param demos - The demos instance (for getting the address nonce)
     *
     * @returns The signed transaction.
     */
    transfer(to: string, amount: number, demos: Demos): Promise<Transaction>;
    /**
     * Signs a transaction after hashing its content.
     *
     * @deprecated Use demos.sign(tx) instead
     *
     * @param raw_tx - The transaction to be signed.
     * @param keypair - The keypair to use for signing.
     * @returns A Promise that resolves to the signed transaction.
     */
    sign: (raw_tx: Transaction, keypair: IKeyPair, options: {
        algorithm: SigningAlgorithm;
    }) => Promise<Transaction>;
    /**
     * Signs a message with a given algorithm.
     *
     * @param data - The message to sign.
     * @param keypair - The keypair to use for signing.
     * @param options.algorithm - The algorithm related to the keypair.
     * @returns A Promise that resolves to the signed message.
     */
    signWithAlgorithm: (data: string, keypair: IKeyPair, options: {
        algorithm: SigningAlgorithm;
    }) => Promise<{
        type: SigningAlgorithm;
        data: string;
    }>;
    /**
     * Confirms a transaction.
     *
     * @param transaction - The transaction to confirm
     * @returns The validity data of the transaction containing the gas information.
     */
    confirm: (transaction: Transaction, demos: Demos) => Promise<RPCResponseWithValidityData>;
    /**
     * Broadcasts a transaction for execution.
     *
     * @param validationData - The validity data of the transaction
     * @param demos - The demos instance
     *
     * @returns The response from the node
     */
    broadcast: (validationData: RPCResponseWithValidityData, demos: Demos) => Promise<any>;
    /**
     * Create a signed DEMOS transaction to store binary data on the blockchain.
     * Data is stored in the sender's account.
     *
     * @param bytes - The binary data to store (will be base64-encoded)
     * @param demos - The demos instance (for getting the address nonce)
     *
     * @returns The signed storage transaction.
     */
    store(bytes: Uint8Array, demos: Demos): Promise<Transaction>;
    /**
     * Create a signed L2PS hash update transaction for DTR relay to validators.
     *
     * L2PS hash updates are self-directed transactions that carry consolidated
     * hash information representing multiple L2PS transactions. These transactions
     * are automatically relayed to validators via DTR (Distributed Transaction Routing)
     * to enable consensus on L2PS network activity without exposing transaction content.
     *
     * @param l2psUid - The unique identifier of the L2PS network
     * @param consolidatedHash - SHA-256 hash representing all L2PS transactions
     * @param transactionCount - Number of transactions included in this hash update
     * @param demos - The demos instance (for getting the address nonce)
     *
     * @returns The signed L2PS hash update transaction
     *
     * @example
     * ```typescript
     * const hashUpdateTx = await DemosTransactions.createL2PSHashUpdate(
     *   "l2ps_network_123",
     *   "0x1234567890abcdef...",
     *   5,
     *   demos
     * )
     * ```
     */
    createL2PSHashUpdate(l2psUid: string, consolidatedHash: string, transactionCount: number, demos: Demos): Promise<Transaction>;
};
