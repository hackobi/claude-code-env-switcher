"use strict";
/**
 * ProofGenerator - Client-side ZK-SNARK proof generation
 *
 * REVIEW: Phase 9 - SDK Integration
 * REVIEW: Phase 10.1 - Production Implementation (Real snarkjs proof generation)
 * REVIEW: Phase 10.4 - CDN Integration (Production-ready with CDN URLs)
 *
 * Generates Groth16 ZK-SNARK proofs for identity attestations using snarkjs.
 * Circuit artifacts (WASM, proving key, verification key) are loaded from CDN.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateIdentityProof = generateIdentityProof;
exports.verifyProof = verifyProof;
// REVIEW: Phase 10.1 - Production cryptographic implementation
const snarkjs = __importStar(require("@cryptkeeperzk/snarkjs"));
/**
 * Generate a ZK-SNARK proof for identity attestation
 *
 * @param providerId - Provider identifier (e.g., "github:12345")
 * @param secret - User's secret value
 * @param context - Context string for this attestation
 * @param merkleProof - Merkle proof from node RPC
 * @param merkleRoot - Current Merkle root from node RPC
 * @returns Proof and public signals
 *
 * @example
 * ```typescript
 * const result = await ProofGenerator.generateIdentityProof(
 *     "github:12345",
 *     "secret123",
 *     "dao_vote_123",
 *     merkleProof,
 *     merkleRoot
 * )
 * // result: { proof: {...}, publicSignals: [nullifier, merkleRoot, context] }
 * ```
 */
async function generateIdentityProof(providerId, secret, context, merkleProof, merkleRoot) {
    // Convert inputs to BigInt/field elements
    const providerIdBigInt = stringToBigInt(providerId);
    const secretBigInt = stringToBigInt(secret);
    const contextBigInt = stringToBigInt(context);
    // Prepare circuit inputs
    const circuitInputs = {
        // Private inputs
        provider_id: providerIdBigInt.toString(),
        secret: secretBigInt.toString(),
        pathElements: merkleProof.siblings.map(s => s.map(v => v.toString())),
        pathIndices: merkleProof.pathIndices,
        // Public inputs
        context: contextBigInt.toString(),
        merkle_root: merkleRoot,
    };
    // REVIEW: Phase 10.4 - Production CDN URLs for circuit artifacts
    const wasmPath = 'https://files.demos.sh/zk-circuits/v1/identity_with_merkle.wasm';
    const zkeyPath = 'https://files.demos.sh/zk-circuits/v1/identity_with_merkle_final.zkey';
    // REVIEW: Phase 10.1 - Production-ready proof generation using snarkjs
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(circuitInputs, wasmPath, zkeyPath);
    // Convert proof to our ZKProof format
    const zkProof = {
        pi_a: [
            proof.pi_a[0].toString(),
            proof.pi_a[1].toString(),
            proof.pi_a[2].toString(),
        ],
        pi_b: [
            [proof.pi_b[0][0].toString(), proof.pi_b[0][1].toString()],
            [proof.pi_b[1][0].toString(), proof.pi_b[1][1].toString()],
            [proof.pi_b[2][0].toString(), proof.pi_b[2][1].toString()],
        ],
        pi_c: [
            proof.pi_c[0].toString(),
            proof.pi_c[1].toString(),
            proof.pi_c[2].toString(),
        ],
        protocol: 'groth16',
    };
    return {
        proof: zkProof,
        publicSignals: publicSignals.map((s) => s.toString()),
    };
}
/**
 * Verify a proof locally (optional - mainly for testing)
 *
 * @param proof - The proof to verify
 * @param publicSignals - Public signals for the proof
 * @returns True if proof is valid
 *
 * NOTE: Node RPC will do the actual verification, this is mainly for debugging
 * REVIEW: Phase 10.4 - Production verification implementation with CDN
 */
async function verifyProof(proof, publicSignals) {
    // REVIEW: Phase 10.4 - Load verification key from CDN
    const vkeyUrl = 'https://files.demos.sh/zk-circuits/v1/verification_key_merkle.json';
    try {
        const response = await fetch(vkeyUrl);
        if (!response.ok) {
            throw new Error(`Failed to load verification key: ${response.status} ${response.statusText}`);
        }
        const vkey = await response.json();
        // REVIEW: Phase 10.1 - Production-ready verification using snarkjs
        // Convert our ZKProof format to snarkjs format
        const snarkjsProof = {
            pi_a: proof.pi_a,
            pi_b: proof.pi_b,
            pi_c: proof.pi_c,
            protocol: proof.protocol,
        };
        return await snarkjs.groth16.verify(vkey, publicSignals, snarkjsProof);
    }
    catch (error) {
        throw new Error(`ZK proof verification failed: ${error instanceof Error ? error.message : String(error)}`);
    }
}
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Convert string to BigInt using simple hashing
 *
 * @param str - Input string to convert
 * @returns BigInt representation of the string
 */
function stringToBigInt(str) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    const hex = Array.from(bytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    return BigInt('0x' + hex);
}
//# sourceMappingURL=ProofGenerator.js.map