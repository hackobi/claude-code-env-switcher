import { Enigma } from "./PQC/enigma";
import * as forge from "node-forge";
import { PQCAlgorithm } from '../types/cryptography';
export interface encryptedObject {
    algorithm: "ml-kem-aes" | "rsa";
    encryptedData: Uint8Array;
    cipherText?: Uint8Array;
}
export interface SerializedEncryptedObject {
    algorithm: "ml-kem-aes" | "rsa";
    serializedEncryptedData: string;
    serializedCipherText?: string;
}
export interface SerializedSignedObject {
    algorithm: "ml-dsa" | "falcon" | "ed25519";
    serializedSignedData: string;
    serializedPublicKey: string;
    serializedMessage: string;
}
export interface Ed25519SignedObject {
    algorithm: "ed25519";
    signature: Uint8Array;
    publicKey: forge.pki.ed25519.NativeBuffer;
    message: Uint8Array;
}
export interface PqcSignedObject {
    algorithm: "ml-dsa" | "falcon";
    signature: Uint8Array;
    publicKey: Uint8Array;
    message: Uint8Array;
}
export type signedObject = Ed25519SignedObject | PqcSignedObject;
/**
 * Converts a Uint8Array to a hexadecimal string representation, prefixed with '0x'.
 *
 * @param bytes - The Uint8Array to convert.
 * @returns The hexadecimal string representation (e.g., "0x0a1b2c").
 */
export declare function uint8ArrayToHex(bytes: Uint8Array): string;
/**
 * Converts a hexadecimal string (with or without '0x' prefix) to a Uint8Array.
 *
 * @param hexString - The hexadecimal string to convert (e.g., "0x0a1b2c" or "0a1b2c").
 * @returns The corresponding Uint8Array.
 * @throws {Error} If the input string (after removing '0x') has an odd length
 * or contains non-hexadecimal characters.
 */
export declare function hexToUint8Array(hexString: string): Uint8Array;
/**
 * UnifiedCrypto is a class that provides a unified interface for the different encryption algorithms
 * It is used to encrypt and decrypt messages, sign and verify messages, and generate identities for the different algorithms
 * It uses Enigma for PQC encryption/decryption and Cryptography for RSA encryption/decryption
 * It uses Enigma for PQC signing and Cryptography for Ed25519 signing
 * It uses the master seed to derive seeds for the different algorithms using HKDF
 * Manages encryptedObjects and signedObjects to route data through the supported algorithms
 * REVIEW: Check race conditions
 * REVIEW: Check stability of the master seed transformation
 * TODO: Build a test suite for the UnifiedCrypto class
 */
export declare class UnifiedCrypto {
    static supportedPQCAlgorithms: PQCAlgorithm[];
    private static instances;
    private static DEFAULT_INSTANCE_ID;
    enigma: Enigma;
    ed25519KeyPair: {
        publicKey: forge.pki.ed25519.NativeBuffer;
        privateKey: forge.pki.ed25519.NativeBuffer;
    };
    rsaKeyPair: forge.pki.rsa.KeyPair;
    masterSeed: Uint8Array;
    private instanceId;
    private constructor();
    static getInstance(instanceId?: string, masterSeed?: Uint8Array): UnifiedCrypto;
    getId(): string;
    static getInstanceIds(): string[];
    static removeInstance(instanceId: string): boolean;
    /**
     * Ensures that the master seed is set and generates a new one if not set
     * @param masterSeed (optional) The master seed to set, or undefined to generate a new one
     */
    ensureSeed(masterSeed?: Uint8Array): Promise<void>;
    /**
     * Derives a seed for the given algorithm
     * @param algorithm The algorithm to derive the seed for
     * @param seed (optional) The seed to derive the seed from, or undefined to generate a new one or use the master seed if set
     * @returns The derived seed
     */
    deriveSeed(algorithm: "ed25519" | "falcon" | "ml-dsa" | "ml-kem-aes" | "rsa", seed?: Uint8Array): Promise<Uint8Array>;
    generateAllIdentities(masterSeed?: Uint8Array): Promise<void>;
    generateIdentity(algorithm: "ed25519" | "falcon" | "ml-dsa" | "ml-kem-aes" | "rsa", masterSeed?: Uint8Array): Promise<void>;
    getIdentity(algorithm: "ed25519" | "falcon" | "ml-dsa" | "ml-kem-aes" | "rsa"): Promise<{
        publicKey: Uint8Array | forge.pki.rsa.PublicKey | forge.pki.ed25519.NativeBuffer;
        privateKey: Uint8Array | forge.pki.rsa.PrivateKey | forge.pki.ed25519.NativeBuffer;
        genKey?: Uint8Array;
    }>;
    /**
     * Encrypts a message based on the algorithm using the previously generated identity
     * @param algorithm The algorithm to encrypt the message with
     * @param data The message to encrypt
     * @param peerPublicKey The public key of the peer to encrypt the message to
     * @returns The encrypted object as an encryptedObject
     */
    encrypt(algorithm: "ml-kem-aes" | "rsa", data: Uint8Array, peerPublicKey: Uint8Array): Promise<encryptedObject>;
    /**
     * Signs a message based on the algorithm using the previously generated identity
     * @param algorithm The algorithm to sign the message with
     * @param data The message to sign
     * @returns The signed object as a signedObject
     */
    sign(algorithm: "ml-dsa" | "falcon" | "ed25519", data: Uint8Array): Promise<signedObject>;
    /**
     * Decrypts an encrypted object based on the algorithm
     * @param encryptedObject The encrypted object to decrypt
     * @returns The decrypted data
     */
    decrypt(encryptedObject: encryptedObject): Promise<Uint8Array>;
    /**
     * Verifies a signed object based on the algorithm
     * @param signedObject The signed object to verify
     * @returns True if the signed object is valid, false otherwise
     * @throws Error if publicKey is not in the expected format for the algorithm
     */
    verify(signedObject: signedObject): Promise<boolean>;
}
export declare const unifiedCrypto: UnifiedCrypto & typeof UnifiedCrypto;
export declare function getUnifiedCryptoInstance(instanceId: string, masterSeed?: Uint8Array): UnifiedCrypto;
