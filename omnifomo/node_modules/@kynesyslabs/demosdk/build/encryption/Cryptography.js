"use strict";
/* LICENSE

Â© 2023 by KyneSys Labs, licensed under CC BY-NC-ND 4.0

Full license text: https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode
Human readable license: https://creativecommons.org/licenses/by-nc-nd/4.0/

KyneSys Labs: https://www.kynesys.xyz/

*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cryptography = void 0;
const crypto = __importStar(require("crypto"));
const fs_1 = require("fs");
const path = __importStar(require("path"));
const node_forge_1 = __importDefault(require("node-forge"));
const bip39 = __importStar(require("@scure/bip39"));
const dataManipulation_1 = require("../utils/dataManipulation");
const Hashing_1 = require("./Hashing");
const algorithm = "aes-256-cbc";
class Cryptography {
    /**
     * Validates and sanitizes file paths to prevent path traversal attacks
     * @param filePath The file path to validate
     * @returns The sanitized absolute path
     * @throws Error if the path contains dangerous characters or patterns
     */
    static validateFilePath(filePath) {
        // Check for null bytes which can be used in path injection attacks
        if (filePath.includes('\0')) {
            throw new Error('Invalid file path: null byte detected');
        }
        const safeBaseDir = path.resolve(process.cwd());
        const resolvedPath = path.resolve(safeBaseDir, filePath);
        // Verify the resolved path is within the safe base directory
        if (!resolvedPath.startsWith(safeBaseDir + path.sep) && resolvedPath !== safeBaseDir) {
            throw new Error('Path traversal attempt detected. Access is restricted.');
        }
        return resolvedPath;
    }
    static new() {
        const seed = node_forge_1.default.random.getBytesSync(32);
        const keys = node_forge_1.default.pki.ed25519.generateKeyPair({ seed });
        return keys;
    }
    // INFO Method to generate a new key pair from a seed
    /**
     * Creates a new keypair from a mnemonic
     * @param seed White-space separated string of words
     * @returns A new keypair
     */
    static newFromSeed(seed) {
        if (typeof seed === "string") {
            seed = bip39.mnemonicToSeedSync(seed);
        }
        const stringSeed = seed.toString();
        const hashedSeed = Hashing_1.Hashing.sha256(stringSeed);
        const bufferSeed = Buffer.from(hashedSeed, "hex");
        return node_forge_1.default.pki.ed25519.generateKeyPair({ seed: bufferSeed });
    }
    // TODO Eliminate the old legacy compatibility
    static async save(keypair, path, mode = "hex") {
        if (mode === "hex") {
            let hexPrivKey = Cryptography.saveToHex(keypair.privateKey);
            await fs_1.promises.writeFile(path, hexPrivKey);
        }
        else {
            await fs_1.promises.writeFile(path, JSON.stringify(keypair.privateKey));
        }
    }
    static saveToHex(forgeBuffer) {
        //console.log(forgeBuffer) // REVIEW if it is like this
        let stringBuffer = forgeBuffer.toString("hex");
        return "0x" + stringBuffer;
    }
    // SECTION Encrypted save and load
    static async saveEncrypted(keypair, path, password) {
        const key = crypto.createCipher(algorithm, password);
        // Getting the private key in hex form
        const hex_key = keypair.privateKey.toString("hex");
        // Encrypting and saving
        const encryptedMessage = key.update(hex_key, "utf8", "hex");
        await fs_1.promises.writeFile(path, encryptedMessage);
    }
    static async loadEncrypted(path, password) {
        let keypair = {
            privateKey: null,
            publicKey: null,
        };
        // Validate and sanitize the file path to prevent path traversal attacks
        const safePath = Cryptography.validateFilePath(path);
        // Preparing the environment
        const decipher = crypto.createDecipher(algorithm, password);
        const contentOfFile = await fs_1.promises.readFile(safePath, "utf8");
        // Decrypting
        const decryptedKey = decipher.update(contentOfFile, "hex", "utf8");
        // Loading
        if (decryptedKey.includes("{")) {
            keypair = Cryptography.loadFromBufferString(contentOfFile);
        }
        else {
            keypair = Cryptography.loadFromHex(contentOfFile);
        }
        return keypair;
    }
    // !SECTION Encrypted save and load
    // NOTE Accepts both file paths and strings being either hex or buffer strings
    static async load(path, isFile = true) {
        let keypair = {
            privateKey: null,
            publicKey: null,
        };
        let content;
        if (isFile) {
            // Validate and sanitize the file path to prevent path traversal attacks
            const safePath = Cryptography.validateFilePath(path);
            content = await fs_1.promises.readFile(safePath, "utf8");
        }
        else {
            content = path;
        }
        if (content.includes("{")) {
            keypair = Cryptography.loadFromBufferString(content);
        }
        else {
            keypair = Cryptography.loadFromHex(content);
        }
        return keypair;
    }
    static loadFromHex(content) {
        let keypair = { publicKey: null, privateKey: null };
        content = content.slice(2);
        let finalArray = new Uint8Array(64);
        for (let i = 0; i < content.length; i += 2) {
            const hexValue = content.substr(i, 2);
            const decimalValue = parseInt(hexValue, 16);
            finalArray[i / 2] = decimalValue;
        }
        keypair.privateKey = Buffer.from(finalArray);
        keypair.publicKey = node_forge_1.default.pki.ed25519.publicKeyFromPrivateKey({
            privateKey: keypair.privateKey,
        });
        return keypair;
    }
    static loadFromBufferString(content) {
        let keypair = { publicKey: null, privateKey: null };
        keypair.privateKey = Buffer.from(JSON.parse(content));
        keypair.publicKey = node_forge_1.default.pki.ed25519.publicKeyFromPrivateKey({
            privateKey: keypair.privateKey,
        });
        return keypair;
    }
    static sign(message, privateKey) {
        // REVIEW Test HexToForge support
        if (privateKey.type == "string") {
            privateKey = (0, dataManipulation_1.HexToForge)(privateKey);
        }
        return node_forge_1.default.pki.ed25519.sign({
            message,
            encoding: "utf8",
            privateKey,
        });
    }
    static verify(signed, signature, publicKey) {
        // REVIEW Test HexToForge support
        if (signature.type == "string") {
            signature = (0, dataManipulation_1.HexToForge)(signature);
        }
        if (publicKey.type == "string") {
            publicKey = (0, dataManipulation_1.HexToForge)(publicKey);
        }
        // Also, we have to sanitize buffers so that they are forge compatible
        if (signature.type == "Buffer") {
            signature = Buffer.from(signature); // REVIEW Does not work in bun
        }
        if (publicKey.type == "Buffer") {
            publicKey = Buffer.from(publicKey); // REVIEW Does not work in bun
        }
        return node_forge_1.default.pki.ed25519.verify({
            message: signed,
            encoding: "utf8",
            signature: signature,
            publicKey: publicKey,
        });
    }
}
exports.Cryptography = Cryptography;
Cryptography.ed25519 = {
    sign: (message, privateKey) => {
        // REVIEW Test HexToForge support
        if (privateKey.type == "string") {
            console.log("[HexToForge] Deriving a buffer from privateKey...");
            privateKey = (0, dataManipulation_1.HexToForge)(privateKey);
        }
        return node_forge_1.default.pki.ed25519.sign({
            message,
            encoding: "utf8",
            privateKey,
        });
    },
    verify: (signed, signature, publicKey) => {
        // REVIEW Test HexToForge support
        if (signature.type == "string") {
            signature = (0, dataManipulation_1.HexToForge)(signature);
        }
        if (publicKey.type == "string") {
            publicKey = (0, dataManipulation_1.HexToForge)(publicKey);
        }
        // Also, we have to sanitize buffers so that they are forge compatible
        if (signature.type == "Buffer") {
            signature = Buffer.from(signature); // REVIEW Does not work in bun
        }
        if (publicKey.type == "Buffer") {
            publicKey = Buffer.from(publicKey); // REVIEW Does not work in bun
        }
        return node_forge_1.default.pki.ed25519.verify({
            message: signed,
            encoding: "utf8",
            signature: signature,
            publicKey: publicKey,
        });
    },
};
Cryptography.rsa = {
    // INFO Encryption method using the public key
    encrypt: (message, publicKey) => {
        // NOTE Supporting "fake buffers" from web browsers
        if (publicKey.type == "Buffer") {
            publicKey = Buffer.from(publicKey);
        }
        // Converting the message and decrypting it
        let based = node_forge_1.default.util.encode64(message);
        const encrypted = publicKey.encrypt(based);
        return [true, encrypted];
    },
    // INFO Decryption method using the private key
    decrypt: (message, privateKey = null) => {
        // NOTE Supporting "fake buffers" from web browsers
        try {
            if (privateKey.type == "Buffer") {
                privateKey = Buffer.from(privateKey);
            }
        }
        catch (e) {
            console.error("[DECRYPTION] Looks like there is nothing to normalize here, let's proceed\n");
            console.error(e);
        }
        // Converting back the message and decrypting it
        // NOTE If no private key is provided, we try to use our one
        if (!privateKey) {
            return [false, "No private key found"];
        }
        let debased = node_forge_1.default.util.decode64(message);
        const decrypted = privateKey.decrypt(debased);
        return [true, decrypted.toString()];
    },
};
//# sourceMappingURL=Cryptography.js.map