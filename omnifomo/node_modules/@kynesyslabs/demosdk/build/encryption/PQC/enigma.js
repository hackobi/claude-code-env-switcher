"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enigma = void 0;
/* INFO Enigma - An experimental wrapper for Post Quantum Cryptography in Typescript designed with ease of use in mind
  Currently suggested and tested schemas for each algorithm are:
  - Signing: ml-dsa or falcon
  - Encryption: NTRU
  - Hashing: SHA-3

  While implemented, the following algorithms are not included in the pqc test suite:
  - Key Encapsulation: McEliece

  While implemented, the following algorithms are not fully tested:
  - ChaCha20-Poly1305
  To properly test the encryption and decryption of data, please see the pqc test suite.
*/
const ml_kem_1 = require("@noble/post-quantum/ml-kem");
const ml_dsa_1 = require("@noble/post-quantum/ml-dsa");
const sha3_1 = require("@noble/hashes/sha3");
const crypto = __importStar(require("crypto"));
const falconts_1 = require("./falconts");
const crypto_1 = require("crypto");
class Enigma {
    constructor() {
        // ml-dsa signing keypair
        this.ml_dsa_signing_keypair = null;
        // falcon signing keypair
        this.falcon_signing_keypair = null;
        // ml-kem encryption keypair
        this.ml_kem_encryption_keypair = null;
        // ml-kem-aes parameters
        this.ml_kem_aes_parameters = null;
    }
    // Static methods
    /**
     * Hashes data using SHA-3-256
     * @param data The data to hash
     * @returns The hash of the data
     */
    static async hash(data, algorithm = "sha3-256") {
        // NOTE: algorithm is not used yet, but will be used in the future
        return sha3_1.sha3_256.create().update(data).digest();
    }
    /**
     * Verifies a signature using ml-dsa
     * @param signature The signature to verify
     * @param message The message to verify the signature against
     * @param publicKey The public key to verify the signature against
     * @returns True if the signature is valid, false otherwise
     */
    static async verify_ml_dsa(signature, message, publicKey) {
        return ml_dsa_1.ml_dsa65.verify(publicKey, message, signature);
    }
    /**
     * Verifies a signature using falcon
     * @param signature The signature to verify
     * @param message The message to verify the signature against
     * @param publicKey The public key to verify the signature against
     * @returns True if the signature is valid, false otherwise
     */
    static async verify_falcon(signature, message, publicKey) {
        const falcon = new falconts_1.Falcon(); // Initialize falcon kernel
        await falcon.init();
        return falcon.verify(message, signature, publicKey);
    }
    // Dynamic methods
    /** Sign data using ml_dsa
     * @param message The message to sign
     * @returns The signature of the message
     */
    async sign_ml_dsa(message, keypair) {
        if (!keypair) {
            keypair = this.ml_dsa_signing_keypair;
        }
        if (!keypair.privateKey) {
            throw new Error("ml_dsa_signing_keypair.privateKey is not set");
        }
        return ml_dsa_1.ml_dsa65.sign(keypair.privateKey, message);
    }
    /** Sign data using falcon
     * @param message The message to sign
     * @returns The signature of the message
     */
    async sign_falcon(message, keypair) {
        if (!keypair) {
            keypair = this.falcon_signing_keypair;
        }
        if (!keypair.privateKey) {
            throw new Error("falcon_signing_keypair.privateKey is not set");
        }
        const falcon = new falconts_1.Falcon();
        await falcon.init();
        await falcon.setKeypair({
            genkeySeed: this.falcon_signing_keypair.genKey,
            sk: this.falcon_signing_keypair.privateKey,
            pk: this.falcon_signing_keypair.publicKey,
        });
        return falcon.sign(message);
    }
    async encapsulate_ml_kem(peerPublicKey) {
        if (!this.ml_kem_encryption_keypair.privateKey) {
            throw new Error("ml_kem_encryption_keypair.privateKey is not set");
        }
        return ml_kem_1.ml_kem768.encapsulate(peerPublicKey);
    }
    async decapsulate_ml_kem(cipherText) {
        if (!this.ml_kem_encryption_keypair.privateKey) {
            throw new Error("ml_kem_encryption_keypair.privateKey is not set");
        }
        return ml_kem_1.ml_kem768.decapsulate(cipherText, this.ml_kem_encryption_keypair.privateKey);
    }
    /** Encrypt data using ml_kem + aes
     * @param message The message to encrypt
     * @returns The encrypted message
     */
    async encrypt_ml_kem_aes(message, peerPublicKey) {
        if (!this.ml_kem_encryption_keypair.privateKey) {
            throw new Error("ml_kem_encryption_keypair.privateKey is not set");
        }
        // Generate shared secret and encapsulate it in a cipher text using ml_kem and the peer's public key
        const encapsulatedSecret = ml_kem_1.ml_kem768.encapsulate(peerPublicKey);
        // Encrypt the message using AES-256-GCM with the shared secret
        const iv = crypto.randomBytes(12); // 96-bit IV for GCM mode
        const cipher = crypto.createCipheriv("aes-256-gcm", encapsulatedSecret.sharedSecret, iv);
        // Encrypt the message
        const encryptedMessage = Buffer.concat([
            cipher.update(message),
            cipher.final(),
        ]);
        // Get the authentication tag
        const authTag = cipher.getAuthTag();
        // Combine IV, encrypted message, and auth tag for transmission
        const combinedEncryptedData = Buffer.concat([
            iv,
            encryptedMessage,
            authTag,
        ]);
        return {
            cipherText: encapsulatedSecret.cipherText,
            encryptedMessage: combinedEncryptedData,
        };
    }
    /** Decrypt data using ml_kem + aes
     * @param encryptedMessage The encrypted message to decrypt
     * @param cipherText The cipher text containing the encapsulated shared secret
     * @returns The decrypted message
     */
    async decrypt_ml_kem_aes(encryptedMessage, cipherText) {
        if (!this.ml_kem_encryption_keypair.privateKey) {
            throw new Error("ml_kem_encryption_keypair.privateKey is not set");
        }
        // Get the shared secret from the cipher text
        const sharedSecret = ml_kem_1.ml_kem768.decapsulate(cipherText, this.ml_kem_encryption_keypair.privateKey);
        // Decrypt the message using AES-256-GCM with the shared secret
        const iv = encryptedMessage.slice(0, 12);
        const message = encryptedMessage.slice(12, -16);
        const authTag = encryptedMessage.slice(-16);
        // Decrypt the message
        const decipher = crypto.createDecipheriv("aes-256-gcm", sharedSecret, iv);
        decipher.setAuthTag(authTag);
        const decryptedMessage = Buffer.concat([
            decipher.update(message),
            decipher.final(),
        ]);
        return decryptedMessage;
    }
    // Keypair generation methods
    /**
     * Generates a ml_dsa signing keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    async generate_ml_dsa_signing_keypair(seed = null) {
        if (!seed) {
            seed = (0, crypto_1.randomBytes)(32);
        }
        const keypair = ml_dsa_1.ml_dsa65.keygen(seed);
        this.ml_dsa_signing_keypair = {
            publicKey: keypair.publicKey,
            privateKey: keypair.secretKey,
        };
    }
    /**
     * Generates a falcon signing keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    async generate_falcon_signing_keypair(seed = null) {
        if (!seed) {
            seed = (0, crypto_1.randomBytes)(48);
        }
        const falcon = new falconts_1.Falcon();
        await falcon.init();
        await falcon.genkey(seed);
        const falconKeyPair = await falcon.getKeypair();
        this.falcon_signing_keypair = {
            genKey: falconKeyPair.genkeySeed,
            publicKey: falconKeyPair.pk,
            privateKey: falconKeyPair.sk,
        };
    }
    /**
     * Generates a ml_kem encryption keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    async generate_ml_kem_encryption_keypair(seed = null) {
        if (!seed) {
            seed = (0, crypto_1.randomBytes)(64);
        }
        let keys = ml_kem_1.ml_kem768.keygen(seed);
        this.ml_kem_encryption_keypair = {
            privateKey: keys.secretKey,
            publicKey: keys.publicKey,
        };
    }
}
exports.Enigma = Enigma;
//# sourceMappingURL=enigma.js.map