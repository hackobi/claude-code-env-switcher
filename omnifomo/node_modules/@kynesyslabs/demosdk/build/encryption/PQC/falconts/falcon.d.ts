interface FalconKernel {
    genkey: (seed?: Uint8Array) => FalconKeypair;
    publicKeyCreate: (privateKey: Uint8Array) => Uint8Array;
    sign: (message: string, privateKey: Uint8Array, salt?: Uint8Array) => Uint8Array;
    verify: (signature: Uint8Array, message: string, publicKey: Uint8Array) => boolean;
    algid: string;
    genkeySeedByte: number;
    skByte: number;
    pkByte: number;
    signByte: number;
    signSaltByte: number;
    signNonceByte: number;
}
export interface FalconKeypair {
    genkeySeed: Uint8Array;
    sk: Uint8Array;
    pk: Uint8Array;
}
export default class Falcon {
    private kernel;
    private keypair;
    private algid;
    constructor(algid?: string);
    init(): Promise<void>;
    genkey(seed?: Uint8Array): Promise<void>;
    sign(message: string, salt?: Uint8Array): Promise<Uint8Array>;
    verify(message: string, signature: Uint8Array, publicKey: Uint8Array): Promise<boolean>;
    publicKeyCreate(privateKey: Uint8Array): Promise<Uint8Array>;
    setKeypair(keypair: FalconKeypair): Promise<void>;
    getPublicKey(): Promise<Uint8Array>;
    getPrivateKey(): Promise<Uint8Array>;
    getAlgid(): Promise<string>;
    getKeypair(): Promise<FalconKeypair>;
    getKernel(): Promise<FalconKernel>;
    /**
     * Convert a Uint8Array to a hex string
     * @param array The Uint8Array to convert
     * @returns A hex string representation of the Uint8Array
     */
    static uint8ArrayToHex(array: Uint8Array): string;
    /**
     * Convert a hex string to a Uint8Array
     * @param hex The hex string to convert
     * @returns A Uint8Array representation of the hex string
     */
    static hexToUint8Array(hex: string): Uint8Array;
    /**
     * Get the public key as a hex string
     * @returns A hex string representation of the public key
     */
    getPublicKeyHex(): Promise<string>;
    /**
     * Get the private key as a hex string
     * @returns A hex string representation of the private key
     */
    getPrivateKeyHex(): Promise<string>;
    /**
     * Sign a message and return the signature as a hex string
     * @param message The message to sign
     * @returns A hex string representation of the signature
     */
    signHex(message: string): Promise<string>;
    /**
     * Verify a signature provided as a hex string
     * @param message The message that was signed
     * @param signatureHex The signature as a hex string
     * @returns True if the signature is valid, false otherwise
     */
    verifyHex(message: string, signatureHex: string, publicKeyHex: string): Promise<boolean>;
    /**
     * Create a public key from a private key provided as a hex string
     * @param privateKeyHex The private key as a hex string
     * @returns A hex string representation of the public key
     */
    publicKeyCreateHex(privateKeyHex: string): Promise<string>;
    /**
     * Set a private key from a hex string
     * @param privateKeyHex The private key as a hex string
     * @returns The public key as a hex string
     */
    setPrivateKeyHex(privateKeyHex: string): Promise<string>;
    /**
     * Convert a Uint8Array to a base64 string
     * @param array The Uint8Array to convert
     * @returns A base64 string representation of the Uint8Array
     */
    static uint8ArrayToBase64(array: Uint8Array): string;
    /**
     * Convert a base64 string to a Uint8Array
     * @param base64 The base64 string to convert
     * @returns A Uint8Array representation of the base64 string
     */
    static base64ToUint8Array(base64: string): Uint8Array;
    /**
     * Get the public key as a base64 string
     * @returns A base64 string representation of the public key
     */
    getPublicKeyBase64(): Promise<string>;
    /**
     * Get the private key as a base64 string
     * @returns A base64 string representation of the private key
     */
    getPrivateKeyBase64(): Promise<string>;
    /**
     * Sign a message and return the signature as a base64 string
     * @param message The message to sign
     * @returns A base64 string representation of the signature
     */
    signBase64(message: string): Promise<string>;
    /**
     * Verify a signature provided as a base64 string
     * @param message The message that was signed
     * @param signatureBase64 The signature as a base64 string
     * @returns True if the signature is valid, false otherwise
     */
    verifyBase64(message: string, signatureBase64: string, publicKeyBase64: string): Promise<boolean>;
    /**
     * Create a public key from a private key provided as a base64 string
     * @param privateKeyBase64 The private key as a base64 string
     * @returns A base64 string representation of the public key
     */
    publicKeyCreateBase64(privateKeyBase64: string): Promise<string>;
    /**
     * Set a private key from a base64 string
     * @param privateKeyBase64 The private key as a base64 string
     * @returns The public key as a base64 string
     */
    setPrivateKeyBase64(privateKeyBase64: string): Promise<string>;
}
export {};
