"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const falcon_sign_1 = require("falcon-sign");
class Falcon {
    constructor(algid) {
        if (algid && (algid !== 'falcon512_n3_v1' && algid !== 'falcon1024_n3_v1')) {
            throw new Error(`Invalid algorithm ID: ${algid}\nSupported algorithms: falcon512_n3_v1, falcon1024_n3_v1\nLeave blank for default: falcon512_n3_v1`);
        }
        this.algid = algid || 'falcon512_n3_v1';
    }
    async init() {
        this.kernel = await (0, falcon_sign_1.getKernel)(this.algid);
    }
    // SECTION: Signing
    async genkey(seed) {
        if (seed) {
            this.keypair = this.kernel.genkey(seed);
        }
        else {
            this.keypair = this.kernel.genkey();
        }
    }
    async sign(message, salt) {
        if (salt) {
            return this.kernel.sign(message, this.keypair.sk, salt);
        }
        else {
            return this.kernel.sign(message, this.keypair.sk);
        }
    }
    async verify(message, signature, publicKey) {
        return this.kernel.verify(signature, message, publicKey);
    }
    async publicKeyCreate(privateKey) {
        return this.kernel.publicKeyCreate(privateKey);
    }
    // SECTION: Setters
    async setKeypair(keypair) {
        this.keypair = keypair;
    }
    // SECTION: Getters
    async getPublicKey() {
        return this.keypair.pk;
    }
    async getPrivateKey() {
        return this.keypair.sk;
    }
    async getAlgid() {
        return this.algid;
    }
    async getKeypair() {
        return this.keypair;
    }
    async getKernel() {
        return this.kernel;
    }
    // Helper methods for hex string conversion
    /**
     * Convert a Uint8Array to a hex string
     * @param array The Uint8Array to convert
     * @returns A hex string representation of the Uint8Array
     */
    static uint8ArrayToHex(array) {
        return Array.from(array)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    }
    /**
     * Convert a hex string to a Uint8Array
     * @param hex The hex string to convert
     * @returns A Uint8Array representation of the hex string
     */
    static hexToUint8Array(hex) {
        // Remove any non-hex characters
        hex = hex.replace(/[^0-9a-fA-F]/g, '');
        // Ensure the hex string has an even length
        if (hex.length % 2 !== 0) {
            hex = '0' + hex;
        }
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            array[i / 2] = parseInt(hex.substring(i, i + 2), 16);
        }
        return array;
    }
    /**
     * Get the public key as a hex string
     * @returns A hex string representation of the public key
     */
    async getPublicKeyHex() {
        const publicKey = await this.getPublicKey();
        return Falcon.uint8ArrayToHex(publicKey);
    }
    /**
     * Get the private key as a hex string
     * @returns A hex string representation of the private key
     */
    async getPrivateKeyHex() {
        const privateKey = await this.getPrivateKey();
        return Falcon.uint8ArrayToHex(privateKey);
    }
    /**
     * Sign a message and return the signature as a hex string
     * @param message The message to sign
     * @returns A hex string representation of the signature
     */
    async signHex(message) {
        const signature = await this.sign(message);
        return Falcon.uint8ArrayToHex(signature);
    }
    /**
     * Verify a signature provided as a hex string
     * @param message The message that was signed
     * @param signatureHex The signature as a hex string
     * @returns True if the signature is valid, false otherwise
     */
    async verifyHex(message, signatureHex, publicKeyHex) {
        const signature = Falcon.hexToUint8Array(signatureHex);
        const publicKey = Falcon.hexToUint8Array(publicKeyHex);
        return this.verify(message, signature, publicKey);
    }
    /**
     * Create a public key from a private key provided as a hex string
     * @param privateKeyHex The private key as a hex string
     * @returns A hex string representation of the public key
     */
    async publicKeyCreateHex(privateKeyHex) {
        const privateKey = Falcon.hexToUint8Array(privateKeyHex);
        const publicKey = await this.publicKeyCreate(privateKey);
        return Falcon.uint8ArrayToHex(publicKey);
    }
    /**
     * Set a private key from a hex string
     * @param privateKeyHex The private key as a hex string
     * @returns The public key as a hex string
     */
    async setPrivateKeyHex(privateKeyHex) {
        const privateKey = Falcon.hexToUint8Array(privateKeyHex);
        const publicKey = await this.publicKeyCreate(privateKey);
        // Update the keypair
        this.keypair = {
            genkeySeed: new Uint8Array(0), // We don't have the seed
            sk: privateKey,
            pk: publicKey
        };
        return Falcon.uint8ArrayToHex(publicKey);
    }
    /**
     * Convert a Uint8Array to a base64 string
     * @param array The Uint8Array to convert
     * @returns A base64 string representation of the Uint8Array
     */
    static uint8ArrayToBase64(array) {
        return Buffer.from(array).toString('base64');
    }
    /**
     * Convert a base64 string to a Uint8Array
     * @param base64 The base64 string to convert
     * @returns A Uint8Array representation of the base64 string
     */
    static base64ToUint8Array(base64) {
        return Buffer.from(base64, 'base64');
    }
    /**
     * Get the public key as a base64 string
     * @returns A base64 string representation of the public key
     */
    async getPublicKeyBase64() {
        const publicKey = await this.getPublicKey();
        return Falcon.uint8ArrayToBase64(publicKey);
    }
    /**
     * Get the private key as a base64 string
     * @returns A base64 string representation of the private key
     */
    async getPrivateKeyBase64() {
        const privateKey = await this.getPrivateKey();
        return Falcon.uint8ArrayToBase64(privateKey);
    }
    /**
     * Sign a message and return the signature as a base64 string
     * @param message The message to sign
     * @returns A base64 string representation of the signature
     */
    async signBase64(message) {
        const signature = await this.sign(message);
        return Falcon.uint8ArrayToBase64(signature);
    }
    /**
     * Verify a signature provided as a base64 string
     * @param message The message that was signed
     * @param signatureBase64 The signature as a base64 string
     * @returns True if the signature is valid, false otherwise
     */
    async verifyBase64(message, signatureBase64, publicKeyBase64) {
        const signature = Falcon.base64ToUint8Array(signatureBase64);
        const publicKey = Falcon.base64ToUint8Array(publicKeyBase64);
        return this.verify(message, signature, publicKey);
    }
    /**
     * Create a public key from a private key provided as a base64 string
     * @param privateKeyBase64 The private key as a base64 string
     * @returns A base64 string representation of the public key
     */
    async publicKeyCreateBase64(privateKeyBase64) {
        const privateKey = Falcon.base64ToUint8Array(privateKeyBase64);
        const publicKey = await this.publicKeyCreate(privateKey);
        return Falcon.uint8ArrayToBase64(publicKey);
    }
    /**
     * Set a private key from a base64 string
     * @param privateKeyBase64 The private key as a base64 string
     * @returns The public key as a base64 string
     */
    async setPrivateKeyBase64(privateKeyBase64) {
        const privateKey = Falcon.base64ToUint8Array(privateKeyBase64);
        const publicKey = await this.publicKeyCreate(privateKey);
        // Update the keypair
        this.keypair = {
            genkeySeed: new Uint8Array(0), // We don't have the seed
            sk: privateKey,
            pk: publicKey
        };
        return Falcon.uint8ArrayToBase64(publicKey);
    }
}
exports.default = Falcon;
//# sourceMappingURL=falcon.js.map