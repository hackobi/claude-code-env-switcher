export declare class Enigma {
    ml_dsa_signing_keypair: {
        publicKey: Uint8Array;
        privateKey: Uint8Array;
    };
    falcon_signing_keypair: {
        genKey: Uint8Array;
        publicKey: Uint8Array;
        privateKey: Uint8Array;
    };
    ml_kem_encryption_keypair: {
        publicKey: Uint8Array;
        privateKey: Uint8Array;
    };
    ml_kem_aes_parameters: string;
    constructor();
    /**
     * Hashes data using SHA-3-256
     * @param data The data to hash
     * @returns The hash of the data
     */
    static hash(data: string, algorithm?: string): Promise<Uint8Array>;
    /**
     * Verifies a signature using ml-dsa
     * @param signature The signature to verify
     * @param message The message to verify the signature against
     * @param publicKey The public key to verify the signature against
     * @returns True if the signature is valid, false otherwise
     */
    static verify_ml_dsa(signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array): Promise<boolean>;
    /**
     * Verifies a signature using falcon
     * @param signature The signature to verify
     * @param message The message to verify the signature against
     * @param publicKey The public key to verify the signature against
     * @returns True if the signature is valid, false otherwise
     */
    static verify_falcon(signature: Uint8Array, message: string, publicKey: Uint8Array): Promise<boolean>;
    /** Sign data using ml_dsa
     * @param message The message to sign
     * @returns The signature of the message
     */
    sign_ml_dsa(message: Uint8Array, keypair?: typeof this.ml_dsa_signing_keypair): Promise<Uint8Array>;
    /** Sign data using falcon
     * @param message The message to sign
     * @returns The signature of the message
     */
    sign_falcon(message: string, keypair?: typeof this.falcon_signing_keypair): Promise<Uint8Array>;
    encapsulate_ml_kem(peerPublicKey: Uint8Array): Promise<{
        cipherText: Uint8Array;
        sharedSecret: Uint8Array;
    }>;
    decapsulate_ml_kem(cipherText: Uint8Array): Promise<Uint8Array>;
    /** Encrypt data using ml_kem + aes
     * @param message The message to encrypt
     * @returns The encrypted message
     */
    encrypt_ml_kem_aes(message: Uint8Array, peerPublicKey: Uint8Array): Promise<{
        cipherText: Uint8Array;
        encryptedMessage: Uint8Array;
    }>;
    /** Decrypt data using ml_kem + aes
     * @param encryptedMessage The encrypted message to decrypt
     * @param cipherText The cipher text containing the encapsulated shared secret
     * @returns The decrypted message
     */
    decrypt_ml_kem_aes(encryptedMessage: Uint8Array, cipherText: Uint8Array): Promise<Uint8Array>;
    /**
     * Generates a ml_dsa signing keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    generate_ml_dsa_signing_keypair(seed?: Uint8Array): Promise<void>;
    /**
     * Generates a falcon signing keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    generate_falcon_signing_keypair(seed?: Uint8Array): Promise<void>;
    /**
     * Generates a ml_kem encryption keypair given a seed or creating one
     * @param seed (optional) the seed used to generate the keypair
     */
    generate_ml_kem_encryption_keypair(seed?: Uint8Array): Promise<void>;
}
