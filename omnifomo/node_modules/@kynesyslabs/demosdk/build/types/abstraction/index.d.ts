import { SigningAlgorithm } from "../cryptography";
export interface XMCoreTargetIdentityPayload {
    chain: string;
    subchain: string;
    targetAddress: string;
    isEVM: boolean;
}
/**
 * The identity of the target address to bind to the Demos identity
 */
export interface InferFromSignatureTargetIdentityPayload extends XMCoreTargetIdentityPayload {
    chainId: number | string;
    signature: string;
    targetAddress: string;
    signedData: string;
    publicKey?: string;
    displayAddress?: string;
}
/**
 * The identity of the target address to bind to the Demos identity
 */
export interface InferFromWriteTargetIdentityPayload extends XMCoreTargetIdentityPayload {
    txHash: string;
    chainId: number | string;
    rpcUrl?: string;
}
export interface InferFromWritePayload {
    method: "identity_assign_from_write";
    /**
     * The identity of the target address to bind to the Demos identity
     */
    target_identity: InferFromWriteTargetIdentityPayload;
    referralCode?: string;
}
export interface InferFromSignaturePayload {
    method: "identity_assign_from_signature";
    /**
     * The identity of the target address to bind to the Demos identity
     */
    target_identity: InferFromSignatureTargetIdentityPayload;
    referralCode?: string;
}
export interface BaseXmIdentityPayload {
    context: "xm";
}
export interface XmIdentityAssignPayload extends BaseXmIdentityPayload {
    method: "xm_identity_assign";
    payload: InferFromSignaturePayload | InferFromWritePayload;
}
export interface XmIdentityRemovePayload extends BaseXmIdentityPayload {
    method: "xm_identity_remove";
    payload: XMCoreTargetIdentityPayload;
}
export type XmIdentityPayload = XmIdentityAssignPayload | XmIdentityRemovePayload;
/**
 * NOTE: The payload for the inferIdentityFromWeb2 method contains a context (e.g. "github", "twitter", "telegram", etc.)
 *  and a proof (e.g. a link to the actual proof of the identity).
 *
 *  The context is used to identify the type of identity being provided, and the proof is the actual proof of the identity.
 *
 *  The proof is a string that contains the proof of the identity usually in the form of a link to the proof.
 *
 *
 */
export interface Web2CoreTargetIdentityPayload {
    context: string;
    proof: string | TelegramProof;
    username: string;
    userId: string;
    referralCode?: string;
}
type GistProofUrl = `https://gist.github.com/${string}/${string}`;
type RawGistProofUrl = `https://gist.githubusercontent.com/${string}/${string}`;
type RawGithubProofUrl = `https://raw.githubusercontent.com/${string}/${string}`;
export type GithubProof = RawGistProofUrl | GistProofUrl | RawGithubProofUrl;
export interface InferFromGithubPayload extends Web2CoreTargetIdentityPayload {
    context: "github";
    proof: GithubProof;
}
export type XProof = `https://x.com/${string}/${string}`;
export type TwitterProof = XProof;
export type DiscordProof = `https://discord.com/channels/${string}/${string}/${string}` | `https://ptb.discord.com/channels/${string}/${string}/${string}` | `https://canary.discord.com/channels/${string}/${string}/${string}` | `https://discordapp.com/channels/${string}/${string}/${string}`;
export interface InferFromXPayload extends Web2CoreTargetIdentityPayload {
    context: "twitter";
    username: string;
    userId: string;
}
export interface InferFromTwitterPayload extends InferFromXPayload {
}
/**
 * Telegram bot attestation payload structure
 */
export interface TelegramAttestationPayload {
    telegram_user_id: string;
    challenge: string;
    signature: string;
    username: string;
    public_key: string;
    timestamp: number;
    bot_address: string;
    group_membership: boolean;
}
/**
 * Signed attestation from Telegram bot containing dual signatures
 */
export interface TelegramSignedAttestation {
    payload: TelegramAttestationPayload;
    signature: {
        type: SigningAlgorithm;
        data: string;
    };
}
/**
 * Telegram proof is a stringified signed attestation with dual signatures
 */
export type TelegramProof = TelegramSignedAttestation;
export interface InferFromTelegramPayload extends Web2CoreTargetIdentityPayload {
    context: "telegram";
    username: string;
    userId: string;
    proof: TelegramProof;
}
export interface InferFromDiscordPayload extends Web2CoreTargetIdentityPayload {
    context: "discord";
    username: string;
    userId: string;
}
export interface BaseWeb2IdentityPayload {
    context: "web2";
}
export interface Web2IdentityAssignPayload extends BaseWeb2IdentityPayload {
    method: "web2_identity_assign";
    payload: InferFromGithubPayload | InferFromTwitterPayload | InferFromTelegramPayload | InferFromDiscordPayload;
}
export interface Web2IdentityRemovePayload extends BaseWeb2IdentityPayload {
    method: "web2_identity_remove";
    payload: {
        context: string;
        username: string;
    };
}
export type Web2IdentityPayload = Web2IdentityAssignPayload | Web2IdentityRemovePayload;
export interface BasePqcIdentityPayload {
    context: "pqc";
}
export interface PqcIdentityAssignPayload extends BasePqcIdentityPayload {
    method: "pqc_identity_assign";
    payload: {
        algorithm: "falcon" | "ml-dsa";
        address: string;
        signature: string;
    }[];
}
export interface PqcIdentityRemovePayload extends BasePqcIdentityPayload {
    method: "pqc_identity_remove";
    payload: {
        algorithm: "falcon" | "ml-dsa";
        address: string;
    }[];
}
export type PqcIdentityPayload = PqcIdentityAssignPayload | PqcIdentityRemovePayload;
export interface BaseUdIdentityPayload {
    context: "ud";
}
/**
 * Unstoppable Domains identity payload
 *
 * Follows signature-based verification pattern (like XM identities)
 * User signs challenge with any authorized address from domain records
 *
 * Multi-chain support: Polygon L2, Base L2, Sonic, Ethereum L1, and Solana
 * Multi-signature support: EVM (secp256k1) and Solana (ed25519)
 */
export interface UDIdentityPayload {
    domain: string;
    signingAddress: string;
    signatureType: "evm" | "solana";
    signature: string;
    publicKey: string;
    signedData: string;
    network: "polygon" | "ethereum" | "base" | "sonic" | "solana";
    registryType: "UNS" | "CNS";
    timestamp?: number;
}
export interface UDIdentityAssignPayload extends BaseUdIdentityPayload {
    method: "ud_identity_assign";
    payload: UDIdentityPayload;
    referralCode?: string;
}
export interface UDIdentityRemovePayload extends BaseUdIdentityPayload {
    method: "ud_identity_remove";
    payload: {
        domain: string;
    };
}
export type UdIdentityPayload = UDIdentityAssignPayload | UDIdentityRemovePayload;
export type IdentityPayload = XmIdentityPayload | Web2IdentityPayload | PqcIdentityPayload | UdIdentityPayload;
export interface UserPoints {
    userId: string;
    referralCode: string;
    totalPoints: number;
    breakdown: {
        web3Wallets: {
            [chain: string]: number;
        };
        socialAccounts: {
            twitter: number;
            github: number;
            discord: number;
            telegram?: number;
        };
        udDomains?: {
            [domain: string]: number;
        };
        referrals: number;
        demosFollow: number;
    };
    linkedWallets: string[];
    linkedSocials: {
        twitter?: string;
    };
    linkedUDDomains?: {
        [network: string]: string[];
    };
    lastUpdated: Date;
    flagged: boolean | null;
    flaggedReason: string | null;
}
export interface FindDemosIdByWeb2IdentityQuery {
    type: "web2";
    context: "twitter" | "telegram" | "github" | "discord";
    username: string;
    userId?: string;
}
export interface FindDemosIdByWeb3IdentityQuery {
    type: "xm";
    chain: string;
    address: string;
}
export {};
