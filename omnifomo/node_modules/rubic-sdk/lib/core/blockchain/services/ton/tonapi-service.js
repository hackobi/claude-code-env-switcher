"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonApiService = void 0;
const errors_1 = require("../../../../common/errors");
const injector_1 = require("../../../injector/injector");
const ton_constants_1 = require("../constants/ton-constants");
class TonApiService {
    constructor() {
        this.xApiUrl = 'https://x-api.rubic.exchange/tonapi';
        this.xApiKey = 'sndfje3u4b3fnNSDNFUSDNVSunw345842hrnfd3b4nt4';
    }
    /**
     *
     * @param walletAddress in any format: raw or friendly
     */
    async fetchWalletSeqno(walletAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/wallet/${walletAddress}/seqno`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchWalletSeqno - ${res.error}`);
        }
        return res.seqno;
    }
    async fetchTxInfo(txHash) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/blockchain/transactions/${txHash}`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchTxInfo - ${res.error}`);
        }
        return res;
    }
    async fetchTxInfoByMessageHash(txHash) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/blockchain/messages/${txHash}/transaction`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchTxInfoByMessageHash - ${res.error}`);
        }
        return res;
    }
    async checkIsTxCompleted(txHash) {
        try {
            const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/events/${txHash}`, { headers: { apikey: this.xApiKey } });
            if ('error' in res) {
                throw new errors_1.RubicSdkError(`[TonApiService] Error in checkIsTxCompleted - ${res.error}`);
            }
            return Object.hasOwn(res, 'in_progress') && !res.in_progress;
        }
        catch {
            return false;
        }
    }
    async healthcheck() {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/status`, { headers: { apikey: this.xApiKey } });
        if ('error' in res || !res.rest_online) {
            return false;
        }
        return true;
    }
    async fetchLastBlockInfo() {
        const res = await injector_1.Injector.httpClient.get(`${ton_constants_1.TONCENTER_API_V3_URL}/blocks`, {
            params: {
                sort: 'desc',
                limit: 1,
                offset: 0
            }
        });
        if ('detail' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchWalletSeqno - ${res.detail[0]?.msg}`);
        }
        return res.blocks[0];
    }
    /**
     *
     * @param walletAddress in any format: raw or friendly
     */
    async callContractMethod(walletAddress, methodName, methodArgs) {
        let argsParam = '';
        if (methodArgs.length) {
            argsParam += '?' + methodArgs.map(param => `args=${param}`).join('&');
        }
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/blockchain/accounts/${walletAddress}/methods/${methodName}${argsParam}`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in callContractMethod - ${res.error}`);
        }
        return res.decoded;
    }
    async fetchTokenInfo(tokenAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/jettons/${tokenAddress}`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchTokenInfo - ${res.error}`);
        }
        return res.metadata;
    }
    /**
     *
     * @param tokenAddress in any form: raw or friendly
     * @returns balance, decimals, name, symbol, walletJettonAddress, jettonAddress
     */
    async fetchTokenInfoForWallet(walletAddress, tokenAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/accounts/${walletAddress}/jettons/${tokenAddress}`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchTokenInfoForWallet - ${res.error}`);
        }
        return res;
    }
    async fetchAllNonNullableTokensInfoForWallet(walletAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/accounts/${walletAddress}/jettons`, {
            headers: { apikey: this.xApiKey }
        });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchAllNonNullableTokensInfoForWallet - ${res.error}`);
        }
        return res.balances;
    }
    /**
     * @returns available methods for walletAddress(contract), raw address and native coin TON balance
     */
    async fetchAccountInfo(walletAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/accounts/${walletAddress}`, { headers: { apikey: this.xApiKey } });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonApiService] Error in fetchAccountInfo - ${res.error}`);
        }
        return res;
    }
}
exports.TonApiService = TonApiService;
//# sourceMappingURL=tonapi-service.js.map