"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiWeb3Private = void 0;
const errors_1 = require("../../../../../common/errors");
const blockchain_name_1 = require("../../../models/blockchain-name");
const evm_web3_private_1 = require("../evm-web3-private/evm-web3-private");
const web3_private_1 = require("../web3-private");
const sui_web3_pure_1 = require("../../../web3-pure/typed-web3-pure/sui-web3-pure/sui-web3-pure");
const injector_1 = require("../../../../injector/injector");
class SuiWeb3Private extends web3_private_1.Web3Private {
    async getBlockchainName() {
        return blockchain_name_1.BLOCKCHAIN_NAME.SUI;
    }
    async sendTransaction(options) {
        try {
            const account = this.core.core.accounts[0];
            const signedTx = await this.core.core.features['sui:signTransaction'].signTransaction({
                account: account,
                transaction: options.transactionBlock,
                chain: 'sui:mainnet'
            });
            const tx = await injector_1.Injector.web3PublicService
                .getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.SUI)
                .executeTxBlock({
                transactionBlock: signedTx.bytes,
                signature: signedTx.signature
            });
            options.onTransactionHash?.(tx.digest);
            return tx.digest;
        }
        catch (err) {
            if (err?.message.includes('User rejected the request.') ||
                err?.message.includes('User rejection | (UserRejectionError:-4005)')) {
                throw new errors_1.UserRejectError();
            }
            console.error(`Send transaction error. ${err}`);
            throw evm_web3_private_1.EvmWeb3Private.parseError(err);
        }
    }
    constructor(core) {
        super(core.address);
        this.core = core;
        this.Web3Pure = sui_web3_pure_1.SuiWeb3Pure;
    }
}
exports.SuiWeb3Private = SuiWeb3Private;
//# sourceMappingURL=sui-web3-private.js.map