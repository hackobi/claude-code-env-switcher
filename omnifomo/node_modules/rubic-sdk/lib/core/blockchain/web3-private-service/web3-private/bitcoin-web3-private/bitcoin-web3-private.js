"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinWeb3Private = void 0;
const blockchain_name_1 = require("../../../models/blockchain-name");
const bitcoin_web3_pure_1 = require("../../../web3-pure/typed-web3-pure/bitcoin-web3-pure");
const on_chain_status_manager_1 = require("../../../../../features/on-chain/status-manager/on-chain-status-manager");
const web3_private_1 = require("../web3-private");
class BitcoinWeb3Private extends web3_private_1.Web3Private {
    getBlockchainName() {
        return Promise.resolve(blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN);
    }
    async transfer(recipient, amount, memo, options) {
        const hashPromise = new Promise((resolve, reject) => {
            this.wallet.core.request({
                method: 'transfer',
                params: [
                    {
                        feeRate: 10,
                        from: this.wallet.address,
                        recipient,
                        amount: {
                            amount,
                            decimals: 8
                        },
                        ...(memo && { memo })
                    }
                ]
            }, (error, txHash) => {
                if (error) {
                    reject(error);
                }
                else {
                    const hash = txHash;
                    options?.onTransactionHash?.(hash);
                    resolve(hash);
                }
            });
        });
        try {
            const hash = await hashPromise;
            if (typeof hash === 'string') {
                const statusData = await on_chain_status_manager_1.OnChainStatusManager.getBitcoinTransaction(hash);
                return statusData.hash;
            }
            throw new Error();
        }
        catch {
            throw new Error('Failed to transfer funds');
        }
    }
    async sendPsbtTransaction(psbt, userAddress, inputIndexes, options) {
        const hashPromise = new Promise((resolve, reject) => {
            this.wallet.core.request({
                method: 'sign_psbt',
                params: {
                    psbt,
                    signInputs: {
                        [userAddress]: inputIndexes
                    },
                    allowedSignHash: 1,
                    broadcast: true
                }
            }, (error, txHash) => {
                if (error) {
                    reject(error);
                }
                else {
                    const txData = txHash;
                    options?.onTransactionHash?.(txData.result.txId);
                    resolve(txData.result.txId);
                }
            });
        });
        try {
            const hash = await hashPromise;
            if (typeof hash === 'string') {
                const statusData = await on_chain_status_manager_1.OnChainStatusManager.getBitcoinTransaction(hash);
                return statusData.hash;
            }
            throw new Error();
        }
        catch {
            throw new Error('Failed to sign psbt transaction');
        }
    }
    constructor(wallet) {
        super(wallet.address);
        this.wallet = wallet;
        this.Web3Pure = bitcoin_web3_pure_1.BitcoinWeb3Pure;
    }
    async getPublicKeyFromWallet() {
        const res = await this.wallet.core.request({
            method: 'request_accounts_and_keys',
            params: {
                purposes: ['payment']
            }
        }, () => { });
        if (res.error) {
            console.error(res.error);
            throw res.error;
        }
        return res.result[0]?.publicKey;
    }
}
exports.BitcoinWeb3Private = BitcoinWeb3Private;
//# sourceMappingURL=bitcoin-web3-private.js.map