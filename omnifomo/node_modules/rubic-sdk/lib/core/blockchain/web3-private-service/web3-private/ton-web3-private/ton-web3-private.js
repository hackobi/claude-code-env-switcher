"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonWeb3Private = void 0;
const core_1 = require("@ton/core");
const errors_1 = require("../../../../../common/errors");
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const blockchain_1 = require("../../../../../common/utils/blockchain");
const errors_2 = require("../../../../../common/utils/errors");
const waitFor_1 = require("../../../../../common/utils/waitFor");
const blockchain_name_1 = require("../../../models/blockchain-name");
const tonapi_service_1 = require("../../../services/ton/tonapi-service");
const ton_web3_pure_1 = require("../../../web3-pure/typed-web3-pure/ton-web3-pure/ton-web3-pure");
const web3_private_1 = require("../web3-private");
class TonWeb3Private extends web3_private_1.Web3Private {
    getBlockchainName() {
        return Promise.resolve(blockchain_name_1.BLOCKCHAIN_NAME.TON);
    }
    async sendTransaction(options) {
        try {
            const { boc } = await this.tonConnectUI.sendTransaction({
                validUntil: Math.floor(Date.now() / 1000) + 360,
                messages: options.messages
            });
            const txHash = ton_web3_pure_1.TonWeb3Pure.fromBocToBase64Hash(boc);
            options.onTransactionHash?.(txHash);
            const isCompleted = await this.waitForTransactionReceipt(txHash);
            if (!isCompleted) {
                throw new errors_1.RubicSdkError('[BitcoinWeb3Private] TON transaction timeout expired!');
            }
            return boc;
        }
        catch (err) {
            console.error(`Send transaction error. ${err}`);
            if (err.message.includes('Reject request')) {
                throw new errors_1.UserRejectError();
            }
            throw (0, errors_2.parseError)(err);
        }
    }
    /**
     * Transfer asset from on wallet to another
     * @param tokenAddress Token address to transfer
     * @param walletAddress Wallet address to transfer from
     * @param receiver Receiver wallet address
     * @param amount Transfer amount
     * @param options Transaction options
     */
    transferAsset(tokenAddress, walletAddress, receiver, amount, options) {
        if ((0, blockchain_1.compareAddresses)(native_tokens_1.nativeTokensList.TON.address, tokenAddress)) {
            return this.transferNative(receiver, amount, options);
        }
        return this.transferJetton(tokenAddress, walletAddress, receiver, amount, options);
    }
    transferNative(receiver, amount, options) {
        const transferAmount = BigInt(amount);
        const encodeConfig = {
            address: receiver,
            amount: transferAmount.toString()
        };
        return this.sendTransaction({ ...options, messages: [encodeConfig] });
    }
    async transferJetton(tokenAddress, walletAddress, receiver, amount, options) {
        const fromAddress = core_1.Address.parse(walletAddress);
        const contractAddress = core_1.Address.parse(tokenAddress);
        const transferAmount = BigInt(amount);
        const receiverAddress = core_1.Address.parse(receiver);
        const jettonWalletAddress = await ton_web3_pure_1.TonWeb3Pure.getWalletAddress(fromAddress, contractAddress);
        const body = (0, core_1.beginCell)()
            .storeUint(0xf8a7ea5, 32)
            .storeUint(0, 64)
            .storeCoins(transferAmount)
            .storeAddress(receiverAddress)
            .storeAddress(receiverAddress)
            .storeBit(0)
            .storeCoins((0, core_1.toNano)('0.02'))
            .storeBit(0)
            .endCell();
        const encodeConfig = {
            address: jettonWalletAddress.toRawString(),
            amount: (0, core_1.toNano)('0.05').toString(),
            payload: body.toBoc().toString('base64')
        };
        return this.sendTransaction({ ...options, messages: [encodeConfig] });
    }
    async waitForTransactionReceipt(txHash) {
        let isCompleted = false;
        const startTimeMS = Date.now();
        const timeLimitMS = 600 * 1000;
        while (true) {
            const currentTimeMS = Date.now();
            if (currentTimeMS > startTimeMS + timeLimitMS) {
                return false;
            }
            if (isCompleted) {
                return true;
            }
            await (0, waitFor_1.waitFor)(30000);
            isCompleted = await this.tonApi.checkIsTxCompleted(txHash);
        }
    }
    constructor(tonProviderCore) {
        super(tonProviderCore.address);
        this.Web3Pure = ton_web3_pure_1.TonWeb3Pure;
        this.tonApi = new tonapi_service_1.TonApiService();
        this.tonConnectUI = tonProviderCore.core;
    }
}
exports.TonWeb3Private = TonWeb3Private;
//# sourceMappingURL=ton-web3-private.js.map