"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TonWeb3Pure_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonWeb3Pure = void 0;
const core_1 = require("@ton/core");
const utils_1 = require("ethers/lib/utils");
const errors_1 = require("../../../../../common/errors");
const blockchain_1 = require("../../../../../common/utils/blockchain");
const decorators_1 = require("../../../../../common/utils/decorators");
const ton_client_1 = require("../../../web3-private-service/web3-private/ton-web3-private/ton-client/ton-client");
const injector_1 = require("../../../../injector/injector");
let TonWeb3Pure = TonWeb3Pure_1 = class TonWeb3Pure {
    static get nativeTokenAddress() {
        return TonWeb3Pure_1.EMPTY_ADDRESS;
    }
    static isNativeAddress(address) {
        return (0, blockchain_1.compareAddresses)(address, TonWeb3Pure_1.nativeTokenAddress);
    }
    static isEmptyAddress(address) {
        return address === TonWeb3Pure_1.EMPTY_ADDRESS;
    }
    static async isAddressCorrect(address) {
        return /^(EQ|UQ)[0-9a-zA-Z-_!]{46}$/.test(address);
    }
    /**
     *
     * @param boc Boc returned in connector.sendTransaction
     * @returns boc converter in base 64 string
     */
    static fromBocToBase64Hash(boc) {
        const inMsgCell = core_1.Cell.fromBase64(boc);
        const inMsgHash = inMsgCell.hash();
        const inMsgHashBase64 = inMsgHash.toString('base64');
        const inMsgHashBase64Url = inMsgHashBase64.replace(/\+/g, '-').replace(/\//g, '_');
        return inMsgHashBase64Url;
    }
    /**
     * @param walletAddress in any format: raw or friendly
     */
    static async getAllFormatsOfAddress(walletAddress) {
        const res = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v2/address/${walletAddress}/parse`, {
            headers: {
                apikey: this.xApiKey
            }
        });
        if ('error' in res) {
            throw new errors_1.RubicSdkError(`[TonWeb3Pure] Error in getAllFormatsOfAddress - ${res.error}`);
        }
        return res;
    }
    static addressToHex(friendlyTonAddress) {
        const rawAddress = core_1.Address.parse(friendlyTonAddress).toRawString();
        const addressBuffer = Buffer.from(rawAddress.slice(2), 'hex');
        const addressHashed = (0, utils_1.keccak256)(addressBuffer);
        const hexAddress = '0x' + addressHashed.slice(-40);
        return hexAddress;
    }
    static async getWalletAddress(address, contractAddress) {
        const addressResult = await ton_client_1.TonClientInstance.getInstance().runMethod(contractAddress, 'get_wallet_address', [{ type: 'slice', cell: (0, core_1.beginCell)().storeAddress(address).endCell() }]);
        return addressResult.stack.readAddress();
    }
};
exports.TonWeb3Pure = TonWeb3Pure;
TonWeb3Pure.xApiUrl = 'https://x-api.rubic.exchange/tonapi';
TonWeb3Pure.xApiKey = 'sndfje3u4b3fnNSDNFUSDNVSunw345842hrnfd3b4nt4';
TonWeb3Pure.EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000';
exports.TonWeb3Pure = TonWeb3Pure = TonWeb3Pure_1 = __decorate([
    (0, decorators_1.staticImplements)()
], TonWeb3Pure);
//# sourceMappingURL=ton-web3-pure.js.map