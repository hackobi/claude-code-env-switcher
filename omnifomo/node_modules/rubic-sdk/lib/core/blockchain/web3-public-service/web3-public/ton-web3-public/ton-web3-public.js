"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonWeb3Public = void 0;
const core_1 = require("@ton/core");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const p_timeout_1 = __importDefault(require("../../../../../common/utils/p-timeout"));
const blockchain_name_1 = require("../../../models/blockchain-name");
const tonapi_service_1 = require("../../../services/ton/tonapi-service");
const ton_web3_pure_1 = require("../../../web3-pure/typed-web3-pure/ton-web3-pure/ton-web3-pure");
const tx_status_1 = require("../models/tx-status");
const web3_public_1 = require("../web3-public");
class TonWeb3Public extends web3_public_1.Web3Public {
    constructor() {
        super(blockchain_name_1.BLOCKCHAIN_NAME.TON);
        this.tonApi = new tonapi_service_1.TonApiService();
    }
    async getTransactionStatus(txHash) {
        const isCompleted = await this.tonApi.checkIsTxCompleted(txHash);
        if (isCompleted) {
            return tx_status_1.TX_STATUS.SUCCESS;
        }
        return tx_status_1.TX_STATUS.PENDING;
    }
    async getBlockchainTransaction(hash) {
        return this.tonApi.fetchTxInfo(hash);
    }
    getBlockchainTransactionByMessageHash(hash) {
        return this.tonApi.fetchTxInfoByMessageHash(hash);
    }
    async healthCheck(timeoutMs) {
        const isAlive = await (0, p_timeout_1.default)(this.tonApi.healthcheck(), timeoutMs, () => false);
        return isAlive;
    }
    async getBalance(userAddress, tokenAddress) {
        const isNative = !tokenAddress || ton_web3_pure_1.TonWeb3Pure.isNativeAddress(tokenAddress);
        const balance = isNative
            ? (await this.tonApi.fetchAccountInfo(userAddress)).balance
            : (await this.tonApi.fetchTokenInfoForWallet(userAddress, tokenAddress)).balance;
        return new bignumber_js_1.default(balance || 0);
    }
    /**
     * @deprecated Use getBalance instead for all tokens and native currency
     */
    async getTokenBalance(userAddress, tokenAddress) {
        const info = await this.tonApi.fetchTokenInfoForWallet(userAddress, tokenAddress);
        return new bignumber_js_1.default(info.balance || 0);
    }
    async getTokensBalances(userAddress, tokensAddresses) {
        const tokensWithBalance = await this.tonApi.fetchAllNonNullableTokensInfoForWallet(userAddress);
        const nativeIndex = tokensAddresses.findIndex(ton_web3_pure_1.TonWeb3Pure.isNativeAddress);
        if (!tokensWithBalance.length && nativeIndex === -1) {
            return [];
        }
        const balances = tokensAddresses
            .filter(address => !ton_web3_pure_1.TonWeb3Pure.isNativeAddress(address))
            .map(address => {
            const tokenWithBalance = tokensWithBalance.find(token => token.jetton.address.toLowerCase() ===
                core_1.Address.parse(address).toRawString().toLowerCase());
            if (tokenWithBalance) {
                return new bignumber_js_1.default(tokenWithBalance.balance);
            }
            return new bignumber_js_1.default(0);
        });
        if (nativeIndex !== -1) {
            const acountInfo = await this.tonApi.fetchAccountInfo(userAddress);
            const nativeBalance = new bignumber_js_1.default(acountInfo.balance);
            balances.splice(nativeIndex, 0, nativeBalance);
        }
        return balances;
    }
    async callForTokensInfo(tokensAddresses, tokenFields = ['decimals', 'symbol', 'name']) {
        const info = await Promise.all(tokensAddresses.map(address => {
            if (ton_web3_pure_1.TonWeb3Pure.isNativeAddress(address)) {
                const nativeToken = native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.TON];
                return nativeToken;
            }
            return this.tonApi.fetchTokenInfo(address);
        }));
        if (!info.length) {
            return [];
        }
        const necessaryInfo = info.map(token => {
            const tokenInfo = tokenFields.reduce((acc, field) => ({ ...acc, [field]: token[field] }), {});
            return tokenInfo;
        });
        return necessaryInfo;
    }
    callContractMethod() {
        throw new Error('Method not implemented.');
    }
    async getBlockNumber() {
        try {
            const block = await this.tonApi.fetchLastBlockInfo();
            return block.seqno;
        }
        catch {
            return 0;
        }
    }
    setProvider() {
        throw new Error('Method not implemented.');
    }
    getAllowance() {
        throw new Error('Method not implemented.');
    }
    multicallContractsMethods() {
        throw new Error('Method not implemented.');
    }
}
exports.TonWeb3Public = TonWeb3Public;
//# sourceMappingURL=ton-web3-public.js.map