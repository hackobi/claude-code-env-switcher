"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiWeb3Public = void 0;
const client_1 = require("@mysten/sui/client");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const blockchain_1 = require("../../../../../common/utils/blockchain");
const blockchain_name_1 = require("../../../models/blockchain-name");
const tx_status_1 = require("../models/tx-status");
const web3_public_1 = require("../web3-public");
const sui_web3_pure_1 = require("../../../web3-pure/typed-web3-pure/sui-web3-pure/sui-web3-pure");
/**
 * Class containing methods for calling contracts in order to obtain information from the blockchain.
 * To send transaction or execute contract method use {@link Web3Private}.
 */
class SuiWeb3Public extends web3_public_1.Web3Public {
    constructor(url) {
        super(blockchain_name_1.BLOCKCHAIN_NAME.SUI);
        this.client = new client_1.SuiClient({ url });
    }
    async getBlockNumber() {
        const epochInfo = await this.client.getEpochs({ limit: 1 });
        const stringEpoch = epochInfo.data[0].epoch;
        return Number(stringEpoch);
    }
    multicallContractsMethods(_contractAbi, _contractsData) {
        throw new Error('Method multicall is not supported');
    }
    async getTransactionStatus(hash) {
        try {
            const txDetails = await this.client.getTransactionBlock({ digest: hash });
            const status = txDetails?.effects?.status.status;
            if (!status) {
                return tx_status_1.TX_STATUS.PENDING;
            }
            return status === 'success' ? tx_status_1.TX_STATUS.SUCCESS : tx_status_1.TX_STATUS.FAIL;
        }
        catch {
            return tx_status_1.TX_STATUS.PENDING;
        }
    }
    async callForTokenInfo(tokenAddress, tokenFields = ['decimals', 'symbol', 'name', 'image']) {
        return (await this.callForTokensInfo([tokenAddress], tokenFields))[0];
    }
    async callForTokensInfo(tokenAddresses, _tokenFields = ['decimals', 'symbol', 'name']) {
        const nativeTokenIndex = tokenAddresses.findIndex(address => this.Web3Pure.isNativeAddress(address));
        const filteredTokenAddresses = tokenAddresses.filter((_, index) => index !== nativeTokenIndex);
        const blockchainNativeToken = native_tokens_1.nativeTokensList[this.blockchainName];
        const nativeToken = {
            ...blockchainNativeToken,
            decimals: blockchainNativeToken.decimals.toString()
        };
        // only native token in array
        if (!filteredTokenAddresses.length && nativeTokenIndex !== -1) {
            return [nativeToken];
        }
        const allTokensMeta = await Promise.all(filteredTokenAddresses.map(coinType => this.client.getCoinMetadata({ coinType })));
        const tokens = allTokensMeta.map(metadata => metadata
            ? {
                decimals: String(metadata.decimals),
                symbol: metadata.symbol,
                name: metadata.name
            }
            : {});
        if (nativeTokenIndex === -1) {
            return tokens;
        }
        tokens.splice(nativeTokenIndex, 0, nativeToken);
        return tokens;
    }
    async getBalance(userAddress, tokenAddress) {
        const isToken = tokenAddress && !sui_web3_pure_1.SuiWeb3Pure.isNativeAddress(tokenAddress);
        if (isToken) {
            const balance = await this.client.getBalance({
                owner: userAddress,
                coinType: tokenAddress
            });
            return new bignumber_js_1.default(balance.totalBalance);
        }
        const balance = await this.client.getBalance({ owner: userAddress });
        return new bignumber_js_1.default(balance.totalBalance);
    }
    async getTokenBalance(address, tokenAddress) {
        const balance = await this.client.getBalance({
            owner: address,
            coinType: tokenAddress
        });
        return new bignumber_js_1.default(balance.totalBalance);
    }
    async callContractMethod(_contractAddress, _contractAbi, _methodName, _methodArguments = [], _options = {}) {
        throw new Error('Method call is not supported');
    }
    async healthCheck() {
        try {
            const state = await this.client.getLatestSuiSystemState();
            return state.activeValidators.length > 0;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Gets balance of multiple tokens.
     * @param address Wallet address.
     * @param tokensAddresses Tokens addresses.
     */
    async getTokensBalances(address, tokensAddresses) {
        const allUserTokens = await this.client.getAllBalances({ owner: address });
        return tokensAddresses.map(address => {
            const possibleBalance = allUserTokens.find(el => (0, blockchain_1.compareAddresses)(address, el.coinType) ||
                SuiWeb3Public.compareSuiAddress(address, el.coinType));
            return new bignumber_js_1.default(possibleBalance?.totalBalance || 0);
        });
    }
    async getAllowance() {
        return new bignumber_js_1.default(Infinity);
    }
    setProvider(_provider) {
        return;
    }
    static compareSuiAddress(addressA, addressB) {
        const pureAddressA = addressA.split(':')[0];
        const pureAddressB = addressB.split(':')[0];
        return (0, blockchain_1.compareAddresses)(new bignumber_js_1.default(pureAddressA).toFixed(), new bignumber_js_1.default(pureAddressB).toFixed());
    }
    executeTxBlock(params) {
        return this.client.executeTransactionBlock(params);
    }
}
exports.SuiWeb3Public = SuiWeb3Public;
//# sourceMappingURL=sui-web3-public.js.map