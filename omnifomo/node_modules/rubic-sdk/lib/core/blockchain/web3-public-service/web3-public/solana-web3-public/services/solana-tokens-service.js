"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaTokensService = void 0;
const spl_token_1 = require("@solana/spl-token");
const utl_sdk_1 = require("@solflare-wallet/utl-sdk");
const blockchain_1 = require("../../../../../../common/utils/blockchain");
const p_timeout_1 = __importDefault(require("../../../../../../common/utils/p-timeout"));
const solana_tokens_api_service_1 = require("./solana-tokens-api-service");
class SolanaTokensService {
    constructor(connection) {
        // key - address of token, value - idx of token in initial tokensAddress
        this.tokensOrder = {};
        this.initialMints = [];
        this.connection = connection;
    }
    async fetchTokensData(mints) {
        const tokensAddresses = mints.map(mint => mint.toString());
        this.initialMints = mints;
        this.tokensOrder = tokensAddresses.reduce((acc, address, idx) => ({ ...acc, [address.toLowerCase()]: idx }), {});
        const fromBackend = await this.fetchTokensFromBackend(mints);
        if (!fromBackend.hasNotFetchedTokens)
            return this.sortTokensByIdx(fromBackend.tokensList);
        const fromOldBackend = await this.fetchTokensFromOldBackend(fromBackend.notFetchedMints, fromBackend.tokensList);
        if (!fromOldBackend.hasNotFetchedTokens) {
            return this.sortTokensByIdx([...fromBackend.tokensList, ...fromOldBackend.tokensList]);
        }
        const fromMetaplex = await this.fetchTokensFromMetaplex(fromBackend.notFetchedMints, [
            ...fromBackend.tokensList,
            ...fromOldBackend.tokensList
        ]);
        if (!fromMetaplex.hasNotFetchedTokens) {
            return this.sortTokensByIdx([
                ...fromBackend.tokensList,
                ...fromOldBackend.tokensList,
                ...fromMetaplex.tokensList
            ]);
        }
        const fromSplApi = await this.fetchTokensFromSplApi(fromMetaplex.notFetchedMints, [
            ...fromBackend.tokensList,
            ...fromOldBackend.tokensList,
            ...fromMetaplex.tokensList
        ]);
        return this.sortTokensByIdx([
            ...fromBackend.tokensList,
            ...fromOldBackend.tokensList,
            ...fromMetaplex.tokensList,
            ...fromSplApi.tokensList
        ]);
    }
    async fetchTokensFromBackend(mints) {
        const tokensAddresses = mints.map(mint => mint.toString());
        const tokensList = await solana_tokens_api_service_1.SolanaTokensApiService.getTokensList(tokensAddresses);
        const notFetchedMints = this.getNotFetchedTokensList(tokensList);
        return {
            tokensList,
            notFetchedMints,
            hasNotFetchedTokens: notFetchedMints.length > 0
        };
    }
    async fetchTokensFromOldBackend(mints, prevFetchedTokens) {
        const tokensAddresses = mints.map(mint => mint.toString());
        const { content: tokensFromOlbBackend } = await (0, p_timeout_1.default)(solana_tokens_api_service_1.SolanaTokensApiService.getTokensListOld(tokensAddresses), 3000, new Error('Api Timeout!')).catch(() => ({ content: [] }));
        const notSortedTokensList = [...prevFetchedTokens, ...tokensFromOlbBackend];
        const notFetchedMints = this.getNotFetchedTokensList(notSortedTokensList);
        return {
            tokensList: notSortedTokensList,
            notFetchedMints,
            hasNotFetchedTokens: notFetchedMints.length > 0
        };
    }
    async fetchTokensFromMetaplex(mints, prevFetchedTokens) {
        const config = new utl_sdk_1.UtlConfig({
            connection: this.connection,
            timeout: 5000
        });
        const tokenSDK = new utl_sdk_1.Client(config);
        const metaplexTokens = await tokenSDK.getFromMetaplex(mints).catch(() => []);
        const notSortedTokensList = [...prevFetchedTokens, ...metaplexTokens];
        const notFetchedMints = this.getNotFetchedTokensList(notSortedTokensList);
        return {
            tokensList: metaplexTokens,
            notFetchedMints,
            hasNotFetchedTokens: notFetchedMints.length > 0
        };
    }
    async fetchTokensFromSplApi(mints, prevFetchedTokens) {
        const splApiResp = await Promise.all(mints.map(mint => (0, spl_token_1.getMint)(this.connection, mint, 'confirmed'))).catch(() => []);
        const splApiTokens = splApiResp.filter(Boolean).map(token => ({
            name: `Token ${token.address.toString().slice(0, 10)}`,
            symbol: `Token ${token.address.toString().slice(0, 10)}`,
            logoURI: null,
            decimals: token.decimals,
            address: token.address.toString(),
            verified: token.isInitialized
        }));
        const notSortedTokensList = [...prevFetchedTokens, ...splApiTokens];
        const notFetchedMints = this.getNotFetchedTokensList(notSortedTokensList);
        return {
            tokensList: notSortedTokensList,
            notFetchedMints,
            hasNotFetchedTokens: notFetchedMints.length > 0
        };
    }
    sortTokensByIdx(notSortedList) {
        const sortedList = [];
        for (const token of notSortedList) {
            const originalIdx = this.tokensOrder[token.address.toLowerCase()];
            sortedList[originalIdx] = token;
        }
        return sortedList;
    }
    getNotFetchedTokensList(tokensList) {
        const notFetchedTokensList = this.initialMints.filter(mint => tokensList.every(token => !(0, blockchain_1.compareAddresses)(token.address, mint.toString())));
        return notFetchedTokensList;
    }
}
exports.SolanaTokensService = SolanaTokensService;
//# sourceMappingURL=solana-tokens-service.js.map