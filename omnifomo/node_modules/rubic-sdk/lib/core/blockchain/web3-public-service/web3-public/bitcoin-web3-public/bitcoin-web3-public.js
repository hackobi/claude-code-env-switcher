"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinWeb3Public = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../models/blockchain-name");
const chain_type_1 = require("../../../models/chain-type");
const tx_status_1 = require("../models/tx-status");
const injector_1 = require("../../../../injector/injector");
const web3_public_1 = require("../web3-public");
class BitcoinWeb3Public extends web3_public_1.Web3Public {
    constructor() {
        super(blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN);
    }
    async getTransactionStatus(txHash) {
        const url = `https://api.blockcypher.com/v1/btc/main/txs/${txHash}`;
        const { confirmations } = await injector_1.Injector.httpClient.get(url);
        return confirmations > 0 ? tx_status_1.TX_STATUS.SUCCESS : tx_status_1.TX_STATUS.PENDING;
    }
    async healthCheck() {
        return true;
    }
    async getBalance(userAddress) {
        const url = `https://api.blockcypher.com/v1/btc/main/addrs/${userAddress}/balance`;
        const response = await injector_1.Injector.httpClient.get(url);
        return new bignumber_js_1.default(response.final_balance);
    }
    /**
     * @deprecated Use getBalance instead for all tokens and native currency
     */
    async getTokenBalance(userAddress) {
        return this.getBalance(userAddress);
    }
    async getTokensBalances(userAddress) {
        return this.getBalance(userAddress).then(el => [el]);
    }
    async callForTokensInfo(_tokensAddresses, _tokenFields = ['decimals', 'symbol', 'name']) {
        const btc = native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN];
        return [{ decimals: String(btc.decimals), symbol: btc.symbol, name: btc.name }];
    }
    callContractMethod() {
        throw new Error('Method not implemented.');
    }
    async getBlockNumber() {
        throw new Error('Method not implemented.');
    }
    setProvider() {
        throw new Error('Method not implemented.');
    }
    getAllowance() {
        throw new Error('Method not implemented.');
    }
    multicallContractsMethods() {
        throw new Error('Method not implemented.');
    }
    async getPublicKey(userAddress) {
        try {
            const url = `https://api.blockcypher.com/v1/btc/main/addrs/${userAddress}/full`;
            const response = await injector_1.Injector.httpClient.get(url);
            const txs = response.txs;
            let publicKey = null;
            for (const txData of txs) {
                const userInputData = txData.inputs.find(inputData => {
                    const isInputFromUserAddress = inputData.addresses.includes(userAddress);
                    const publicKey = inputData.witness?.[1];
                    return isInputFromUserAddress && publicKey;
                });
                if (userInputData) {
                    publicKey = userInputData.witness[1];
                    break;
                }
            }
            if (!publicKey) {
                throw new Error();
            }
            return publicKey;
        }
        catch {
            const web3Private = injector_1.Injector.web3PrivateService.getWeb3Private(chain_type_1.CHAIN_TYPE.BITCOIN);
            return web3Private.getPublicKeyFromWallet();
        }
    }
}
exports.BitcoinWeb3Public = BitcoinWeb3Public;
//# sourceMappingURL=bitcoin-web3-public.js.map