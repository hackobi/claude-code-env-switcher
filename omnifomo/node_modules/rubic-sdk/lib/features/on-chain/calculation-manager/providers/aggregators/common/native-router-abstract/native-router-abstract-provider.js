"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeRouterAbstractProvider = void 0;
const tokens_1 = require("../../../../../../../common/tokens");
const web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/web3-pure");
const aggregator_on_chain_provider_abstract_1 = require("../../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const native_router_abstract_supported_blockchains_1 = require("./constants/native-router-abstract-supported-blockchains");
const native_router_api_service_1 = require("./services/native-router-api-service");
class NativeRouterAbstractProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.nativeTokenAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
    }
    async calculate(from, toToken, options) {
        try {
            const fakeAddress = '0xe388Ed184958062a2ea29B7fD049ca21244AE02e';
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, options);
            const fromAddress = this.getWalletAddress(from.blockchain) || fakeAddress;
            const fromChain = this.getBlockchainById(from.blockchain);
            const toChain = this.getBlockchainById(toToken.blockchain);
            const path = this.getRoutePath(from, toToken);
            const fromTokenAddress = from.isNative ? this.nativeTokenAddress : from.address;
            const toTokenAddress = toToken.isNative ? this.nativeTokenAddress : toToken.address;
            const nativeRouterQuoteParams = {
                src_chain: fromChain,
                dst_chain: toChain,
                token_out: toTokenAddress,
                token_in: fromTokenAddress,
                amount: fromWithoutFee.tokenAmount.toString(),
                from_address: fromAddress,
                slippage: options.slippageTolerance * 100
            };
            const { amountOut, txRequest } = await native_router_api_service_1.NativeRouterApiService.getFirmQuote(nativeRouterQuoteParams);
            const providerGateway = txRequest.target;
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: web3_pure_1.Web3Pure.fromWei(amountOut, toToken.decimals)
            });
            const tradeStruct = {
                from,
                to,
                slippageTolerance: options.slippageTolerance,
                path,
                gasFeeInfo: await this.getGasFeeInfo(),
                useProxy: options.useProxy,
                proxyFeeInfo,
                fromWithoutFee,
                withDeflation: options.withDeflation,
                usedForCrossChain: options.usedForCrossChain,
                txRequest
            };
            const tradeInstance = {
                tradeStruct,
                providerAddress: options.providerAddress,
                nativeRouterQuoteParams,
                providerGateway
            };
            return this.createNativeRouterTradeInstance(tradeInstance);
        }
        catch (err) {
            return {
                type: this.tradeType,
                error: err
            };
        }
    }
    getBlockchainById(blockchain) {
        return native_router_abstract_supported_blockchains_1.blockchainNameMapping[blockchain];
    }
}
exports.NativeRouterAbstractProvider = NativeRouterAbstractProvider;
//# sourceMappingURL=native-router-abstract-provider.js.map