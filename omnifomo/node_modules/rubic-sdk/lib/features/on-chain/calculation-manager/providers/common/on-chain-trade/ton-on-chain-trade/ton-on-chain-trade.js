"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonOnChainTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../../common/errors");
const native_tokens_1 = require("../../../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../../core/injector/injector");
const check_unsupported_receiver_address_1 = require("../../../../../../common/utils/check-unsupported-receiver-address");
const on_chain_trade_1 = require("../on-chain-trade");
class TonOnChainTrade extends on_chain_trade_1.OnChainTrade {
    get spenderAddress() {
        throw new errors_1.RubicSdkError('No spender address!');
    }
    get web3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.TON);
    }
    get web3Private() {
        return injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(blockchain_name_1.BLOCKCHAIN_NAME.TON);
    }
    constructor(tradeStruct, providerAddress) {
        super(providerAddress);
        this.feeInfo = {};
        this.path = [];
        this.skipAmountCheck = false;
        this.from = tradeStruct.from;
        this.to = tradeStruct.to;
        this.slippageTolerance = tradeStruct.slippageTolerance;
        this.gasFeeInfo = tradeStruct.gasFeeInfo;
        this.routingPath = tradeStruct.routingPath;
        this.additionalInfo = {
            isMultistep: this.routingPath.length > 1,
            isChangedSlippage: tradeStruct.isChangedSlippage
        };
    }
    async needApprove() {
        return false;
    }
    async approve() {
        throw new errors_1.RubicSdkError('Method not implemented!');
    }
    async encodeApprove() {
        throw new Error('Method is not supported');
    }
    async encode() {
        throw new errors_1.RubicSdkError('Method not implemented! Use custom swap methods on each child class!');
    }
    async checkNativeBalance() {
        const balanceWei = await this.web3Public.getBalance(this.walletAddress);
        const balanceNonWei = web3_pure_1.Web3Pure.fromWei(balanceWei, native_tokens_1.nativeTokensList.TON.decimals);
        const requiredBalanceNonWei = this.gasFeeInfo?.totalGas
            ? web3_pure_1.Web3Pure.fromWei(this.gasFeeInfo.totalGas, native_tokens_1.nativeTokensList.TON.decimals)
            : new bignumber_js_1.default(0);
        if (balanceWei.lt(requiredBalanceNonWei)) {
            throw new errors_1.InsufficientFundsError(native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.TON], balanceNonWei, requiredBalanceNonWei);
        }
    }
    async makePreSwapChecks(options) {
        (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options.receiverAddress, this.walletAddress);
        await this.checkFromAddress(options.fromAddress);
        await this.checkNativeBalance();
        await this.checkBalance();
        if (!options.skipAmountCheck) {
            this.skipAmountCheck = true;
            const toWeiAmount = await this.calculateOutputAmount(options);
            this.checkAmountChange(toWeiAmount, this.to.stringWeiAmount);
        }
    }
    getTradeInfo() {
        return {
            estimatedGas: null,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact ?? null,
            slippage: this.slippageTolerance * 100,
            routePath: this.routingPath
        };
    }
}
exports.TonOnChainTrade = TonOnChainTrade;
//# sourceMappingURL=ton-on-chain-trade.js.map