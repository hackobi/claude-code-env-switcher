"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoffeeSwapProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const tokens_1 = require("../../../../../../common/tokens");
const native_tokens_1 = require("../../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const ton_web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/typed-web3-pure/ton-web3-pure/ton-web3-pure");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const fake_wallet_address_1 = require("../../../../../common/constants/fake-wallet-address");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const get_ton_multistep_data_1 = require("../common/utils/get-ton-multistep-data");
const coffe_swap_on_chain_trade_1 = require("./coffe-swap-on-chain-trade");
const coffee_swap_api_service_1 = require("./services/coffee-swap-api-service");
class CoffeeSwapProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.COFFEE_SWAP;
    }
    isSupportedBlockchain(blockchain) {
        return blockchain === blockchain_name_1.BLOCKCHAIN_NAME.TON;
    }
    async calculate(from, toToken, options) {
        try {
            const quote = await coffee_swap_api_service_1.CoffeeSwapApiService.fetchQuote({
                srcToken: from,
                dstToken: toToken,
                walletAddress: options.fromAddress || fake_wallet_address_1.FAKE_TON_ADDRESS
            });
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: new bignumber_js_1.default(quote.output_amount)
            });
            const routingPath = await this.getRoutingPath(quote.paths);
            const { isChangedSlippage, slippage } = (0, get_ton_multistep_data_1.getMultistepData)(routingPath, options.slippageTolerance);
            const totalGas = new bignumber_js_1.default(web3_pure_1.Web3Pure.toWei(quote.recommended_gas, native_tokens_1.nativeTokensList.TON.decimals));
            return new coffe_swap_on_chain_trade_1.CoffeSwapTrade({
                from,
                to,
                gasFeeInfo: { totalGas },
                slippageTolerance: slippage,
                useProxy: false,
                withDeflation: options.withDeflation,
                usedForCrossChain: false,
                routingPath,
                txSteps: quote.paths,
                isChangedSlippage
            }, options.providerAddress);
        }
        catch (err) {
            return {
                type: this.tradeType,
                error: err
            };
        }
    }
    async getRoutingPath(txSteps) {
        const promises = [];
        const path = txSteps[0];
        const getAddress = (addr) => addr === 'native' ? ton_web3_pure_1.TonWeb3Pure.nativeTokenAddress : addr;
        let next = path;
        while (!!next) {
            const from = tokens_1.PriceTokenAmount.createToken({
                address: getAddress(next.input_token.address.address),
                blockchain: blockchain_name_1.BLOCKCHAIN_NAME.TON,
                tokenAmount: new bignumber_js_1.default(next.swap.input_amount)
            });
            const to = tokens_1.PriceTokenAmount.createToken({
                address: getAddress(next.output_token.address.address),
                blockchain: blockchain_name_1.BLOCKCHAIN_NAME.TON,
                tokenAmount: new bignumber_js_1.default(next.swap.output_amount)
            });
            const stepPromises = Promise.all([from, to]);
            promises.push(stepPromises);
            next = next.next?.[0];
        }
        const resolved = await Promise.all(promises);
        const steps = resolved.map(step => ({
            type: 'on-chain',
            provider: this.tradeType,
            path: [step[0], step[1]]
        }));
        return steps;
    }
    getGasFeeInfo() {
        throw new errors_1.RubicSdkError('Method not implemented!');
    }
}
exports.CoffeeSwapProvider = CoffeeSwapProvider;
//# sourceMappingURL=coffee-swap-on-chain-provider.js.map