"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrontoFinanceQuoterController = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../../common/errors");
const blockchain_1 = require("../../../../../../../common/utils/blockchain");
const object_1 = require("../../../../../../../common/utils/object");
const uniswap_v3_quoter_controller_1 = require("./utils/quoter-controller/uniswap-v3-quoter-controller");
class BrontoFinanceQuoterController extends uniswap_v3_quoter_controller_1.UniswapV3QuoterController {
    constructor(blockchain, routerConfiguration, contractAddress, contractAbi, factoryAddress) {
        super(blockchain, routerConfiguration, contractAddress, contractAbi, factoryAddress);
        this.feeAmounts = [100, 200];
    }
    /**
     * Returns swap method's name and arguments to pass it to Quoter contract.
     * @param poolsPath Pools, included in the route.
     * @param from From token.
     * @param to To token.
     * @param exact Is exact input or output trade.
     * @param weiAmount Amount of tokens to trade.
     */
    static getQuoterMethodData(poolsPath, from, to, exact, weiAmount) {
        // if (poolsPath.length === 1 && poolsPath?.[0]) {
        //     const methodName =
        //         exact === 'input' ? 'quoteExactInputSingle' : 'quoteExactOutputSingle';
        //     const sqrtPriceLimitX96 = 0;
        //     //const tickSpacing = feeToTickSpacing[poolsPath[0].fee!];
        //     return {
        //         poolsPath,
        //         methodData: {
        //             methodName,
        //             methodArguments: [
        //                 {
        //                     tokenIn: from.address,
        //                     tokenOut: to.address,
        //                     amountIn: weiAmount,
        //                     tickSpacing: poolsPath[0].fee,
        //                     sqrtPriceLimitX96
        //                 }
        //             ] as QuoteExactInputSingleParams[]
        //         }
        //     };
        // }
        const methodName = exact === 'input' ? 'quoteExactInput' : 'quoteExactOutput';
        const tokensPath = exact === 'input' ? poolsPath : poolsPath.reverse();
        const initialTokenAddress = exact === 'input' ? from.address : to.address;
        return {
            poolsPath,
            methodData: {
                methodName,
                methodArguments: [
                    uniswap_v3_quoter_controller_1.UniswapV3QuoterController.getEncodedPoolsPath(tokensPath, initialTokenAddress),
                    weiAmount
                ]
            }
        };
    }
    /**
     * Returns swap methods' names and arguments, built with passed pools' addresses, to use it in Quoter contract.
     */
    getQuoterMethodsData(options, path, lastTokenAddress) {
        const { routesLiquidityPools, from, to, exact, weiAmount, maxTransitTokens } = options;
        if (path.length === maxTransitTokens) {
            const pools = routesLiquidityPools.filter(pool => pool.isPoolWithTokens(lastTokenAddress, to.address));
            return pools.map(pool => BrontoFinanceQuoterController.getQuoterMethodData(path.concat(pool), from, to, exact, weiAmount));
        }
        return routesLiquidityPools
            .filter(pool => !path.includes(pool))
            .map(pool => {
            const methodsData = [];
            if ((0, blockchain_1.compareAddresses)(pool.token0.address, lastTokenAddress)) {
                const extendedPath = path.concat(pool);
                methodsData.push(...this.getQuoterMethodsData(options, extendedPath, pool.token1.address));
            }
            if ((0, blockchain_1.compareAddresses)(pool.token1.address, lastTokenAddress)) {
                const extendedPath = path.concat(pool);
                methodsData.push(...this.getQuoterMethodsData(options, extendedPath, pool.token0.address));
            }
            return methodsData;
        })
            .flat();
    }
    async getAllRoutes(from, to, exact, weiAmount, routeMaxTransitTokens) {
        const routesLiquidityPools = await this.getAllLiquidityPools(from, to);
        const options = {
            routesLiquidityPools,
            from,
            to,
            exact,
            weiAmount
        };
        const quoterMethodsData = [...Array(routeMaxTransitTokens + 1)]
            .map((_, maxTransitTokens) => this.getQuoterMethodsData({
            ...options,
            maxTransitTokens
        }, [], from.address))
            .flat()
            .slice(0, 40);
        const results = await this.web3Public.multicallContractMethods(this.quoterContractAddress, this.quoterContractABI, quoterMethodsData.map(quoterMethodData => quoterMethodData.methodData));
        return results
            .map((result, index) => {
            const pool = quoterMethodsData?.[index];
            if (!pool) {
                throw new errors_1.RubicSdkError('Pool has to be defined');
            }
            if (result.success) {
                return {
                    outputAbsoluteAmount: new bignumber_js_1.default(result?.output instanceof Object
                        ? result?.output?.amountOut
                        : result.output),
                    poolsPath: pool.poolsPath,
                    initialTokenAddress: from.address
                };
            }
            return null;
        })
            .filter(object_1.notNull);
    }
}
exports.BrontoFinanceQuoterController = BrontoFinanceQuoterController;
//# sourceMappingURL=bronto-finance-quoter-controller.js.map