"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OkuSwapOnChainProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const tokens_1 = require("../../../../../../common/tokens");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const fake_wallet_address_1 = require("../../../../../common/constants/fake-wallet-address");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const get_gas_fee_info_1 = require("../../common/utils/get-gas-fee-info");
const get_gas_price_info_1 = require("../../common/utils/get-gas-price-info");
const okuswap_chain_names_1 = require("./models/okuswap-chain-names");
const okuswap_on_chain_supported_chains_1 = require("./models/okuswap-on-chain-supported-chains");
const okuswap_on_chain_trade_1 = require("./okuswap-on-chain-trade");
const okuswap_api_service_1 = require("./services/okuswap-api-service");
class OkuSwapOnChainProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OKU_SWAP;
    }
    isSupportedBlockchain(blockchain) {
        return okuswap_on_chain_supported_chains_1.OKUSWAP_ON_CHAIN_SUPPORTED_BLOCKCHAINS.some(chain => chain === blockchain);
    }
    async calculate(from, toToken, options) {
        const fullOptions = { ...options, useProxy: false };
        if (!this.isSupportedBlockchain(from.blockchain)) {
            throw new errors_1.RubicSdkError(`OkuSwap doesn't support ${from.blockchain} chain!`);
        }
        const fromBlockchain = from.blockchain;
        const walletAddress = fullOptions.fromAddress || this.getWalletAddress(fromBlockchain) || fake_wallet_address_1.FAKE_WALLET_ADDRESS;
        try {
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, fullOptions);
            const path = this.getRoutePath(from, toToken);
            const subProviders = await okuswap_api_service_1.OkuSwapApiService.getOkuSubProvidersForChain(from.blockchain);
            const quoteReqBody = {
                account: walletAddress,
                chain: okuswap_chain_names_1.OKUSWAP_BLOCKCHAINS[fromBlockchain],
                inTokenAddress: from.address,
                outTokenAddress: toToken.address,
                isExactIn: true,
                slippage: fullOptions.slippageTolerance * 10000,
                inTokenAmount: fromWithoutFee.tokenAmount.toFixed()
            };
            const { subProvider, swapReqBody, toAmount, gas } = await this.getBestRoute(subProviders, quoteReqBody);
            const providerGateway = swapReqBody.coupon.raw.universalRouter;
            const permit2Address = swapReqBody.signingRequest?.permit2Address;
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: new bignumber_js_1.default(web3_pure_1.Web3Pure.toWei(toAmount, toToken.decimals))
            });
            const tradeStruct = {
                from,
                to,
                fromWithoutFee,
                proxyFeeInfo,
                gasFeeInfo: await this.getGasFeeInfo(from, gas),
                slippageTolerance: fullOptions.slippageTolerance,
                useProxy: fullOptions.useProxy,
                withDeflation: fullOptions.withDeflation,
                path,
                quoteReqBody,
                swapReqBody,
                subProvider,
                ...(permit2Address && { permit2ApproveAddress: permit2Address })
            };
            return new okuswap_on_chain_trade_1.OkuSwapOnChainTrade(tradeStruct, fullOptions.providerAddress, providerGateway);
        }
        catch (err) {
            return {
                type: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OKU_SWAP,
                error: err
            };
        }
    }
    async getBestRoute(subProviders, body) {
        const promises = subProviders.map(p => okuswap_api_service_1.OkuSwapApiService.makeQuoteRequest(p, body));
        const routes = await Promise.all(promises);
        const [bestRoute] = routes.sort((a, b) => new bignumber_js_1.default(b.outAmount).minus(a.outAmount).toNumber());
        if (!bestRoute) {
            throw new errors_1.RubicSdkError('[OKU_SWAP_PROVIDER] No route available!');
        }
        return {
            subProvider: bestRoute.market,
            swapReqBody: {
                coupon: bestRoute.coupon,
                signingRequest: bestRoute?.signingRequest
            },
            toAmount: bestRoute.outAmount,
            gas: bestRoute.estimatedGas
        };
    }
    async getGasFeeInfo(from, gasLimit) {
        try {
            const gasPriceInfo = await (0, get_gas_price_info_1.getGasPriceInfo)(from.blockchain);
            return (0, get_gas_fee_info_1.getGasFeeInfo)(gasPriceInfo, { gasLimit: new bignumber_js_1.default(gasLimit) });
        }
        catch {
            return null;
        }
    }
}
exports.OkuSwapOnChainProvider = OkuSwapOnChainProvider;
//# sourceMappingURL=okuswap-on-chain-provider.js.map