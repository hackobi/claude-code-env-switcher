"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnosysFlareTrade = void 0;
const errors_1 = require("../../../../../../../../common/errors");
const evm_web3_pure_1 = require("../../../../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const check_unsupported_receiver_address_1 = require("../../../../../../../common/utils/check-unsupported-receiver-address");
const rubic_proxy_contract_address_1 = require("../../../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const proxy_cross_chain_evm_trade_1 = require("../../../../../../../cross-chain/calculation-manager/providers/common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const on_chain_trade_type_1 = require("../../../../common/models/on-chain-trade-type");
const uniswap_v2_abstract_trade_1 = require("../../../common/uniswap-v2-abstract/uniswap-v2-abstract-trade");
const constants_1 = require("./constants");
const enosys_flare_abi_1 = require("./enosys-flare-abi");
const enosys_swap_methods_1 = require("./enosys-swap-methods");
class EnosysFlareTrade extends uniswap_v2_abstract_trade_1.UniswapV2AbstractTrade {
    constructor() {
        super(...arguments);
        this.dexContractAddress = constants_1.ENOSYS_FLARE_CONTRACT_ADDRESS;
    }
    static get type() {
        return on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.ENOSYS;
    }
    async getTransactionConfigAndAmount(options) {
        await this.checkFromAddress(options.fromAddress, true);
        (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options?.receiverAddress, options?.fromAddress || this.walletAddress);
        if (options.supportFee === undefined) {
            const needApprove = await this.needApprove(options.fromAddress);
            if (needApprove) {
                throw new errors_1.RubicSdkError('To use `encode` function, token must be approved for wallet');
            }
            try {
                await this.checkBalance();
            }
            catch (_err) {
                throw new errors_1.RubicSdkError('To use `encode` function, wallet must have enough balance or you must provider `supportFee` parameter in options.');
            }
        }
        const methodName = await this.getMethodName(options, options.fromAddress, false);
        const gasParams = this.getGasParams(options);
        const config = evm_web3_pure_1.EvmWeb3Pure.encodeMethodCall(this.dexContractAddress, this.constructor.contractAbi, methodName, this.getCallParameters(options.receiverAddress || options.fromAddress), this.nativeValueToSend, gasParams);
        return { tx: config, toAmount: this.to.stringWeiAmount };
    }
    async getSwapData(options) {
        const directTransactionConfig = await this.encodeDirect({
            ...options,
            fromAddress: rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router,
            supportFee: false,
            receiverAddress: options.receiverAddress || rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router
        });
        const availableDexs = (await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getWhitelistedDexes(this.from.blockchain)).map(address => address.toLowerCase());
        const routerAddress = directTransactionConfig.to;
        const method = directTransactionConfig.data.slice(0, 10);
        if (!availableDexs.includes(routerAddress.toLowerCase())) {
            throw new errors_1.NotWhitelistedProviderError(routerAddress, undefined, 'dex');
        }
        await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.checkDexWhiteList(this.from.blockchain, routerAddress, method);
        return [
            [
                routerAddress,
                routerAddress,
                this.from.address,
                this.to.address,
                this.from.stringWeiAmount,
                directTransactionConfig.data,
                true
            ]
        ];
    }
}
exports.EnosysFlareTrade = EnosysFlareTrade;
EnosysFlareTrade.contractAbi = enosys_flare_abi_1.ENOSYS_FLARE_ABI;
EnosysFlareTrade.swapMethods = enosys_swap_methods_1.ENOSYS_METHOD;
//# sourceMappingURL=enosys-flare-trade.js.map