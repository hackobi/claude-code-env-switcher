"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToncoSdkFacade = void 0;
const core_1 = require("@ton/core");
const sdk_1 = require("@toncodex/sdk");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const native_tokens_1 = require("../../../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const ton_client_1 = require("../../../../../../../core/blockchain/web3-private-service/web3-private/ton-web3-private/ton-client/ton-client");
const ton_web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/typed-web3-pure/ton-web3-pure/ton-web3-pure");
const web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../../core/injector/injector");
const fake_wallet_address_1 = require("../../../../../../common/constants/fake-wallet-address");
const addresses_1 = require("../../stonfi/constants/addresses");
const convert_params_to_ton_config_1 = require("../../stonfi/utils/convert-params-to-ton-config");
class ToncoSdkFacade {
    static async calculateAmountOut(params, srcToken) {
        const poolV3Contract = ton_client_1.TonClientInstance.getInstance().open(new sdk_1.PoolV3Contract(params.poolAddress));
        const amountIn = BigInt(srcToken.stringWeiAmount);
        if (params.zeroToOne) {
            const estimate = await poolV3Contract.getSwapEstimate(params.zeroToOne, amountIn, BigInt(sdk_1.TickMath.MIN_SQRT_RATIO.toString()) + BigInt(1));
            return new bignumber_js_1.default(-estimate.amount1.toString());
        }
        else {
            const estimate = await poolV3Contract.getSwapEstimate(params.zeroToOne, amountIn, BigInt(sdk_1.TickMath.MAX_SQRT_RATIO.toString()) - BigInt(1));
            return new bignumber_js_1.default(-estimate.amount0.toString());
        }
    }
    static async createTonConfig(params, fromAmountWei, toMinAmountWei) {
        try {
            const web3Private = injector_1.Injector.web3PrivateService.getWeb3Private(blockchain_name_1.BLOCKCHAIN_NAME.TON);
            const walletAddress = web3Private.address;
            const parsedWalletAddress = core_1.Address.parse(walletAddress);
            const priceLimitSqrt = params.zeroToOne
                ? BigInt(sdk_1.TickMath.MIN_SQRT_RATIO.toString()) + 1n
                : BigInt(sdk_1.TickMath.MAX_SQRT_RATIO.toString()) - 1n;
            const txParams = await sdk_1.PoolMessageManager.createSwapExactInMessage(params.jettonWallets.srcUserJettonWallet, params.jettonWallets.dstRouterJettonWallet, parsedWalletAddress, BigInt(fromAmountWei.toFixed(0)), BigInt(toMinAmountWei.toFixed(0)), priceLimitSqrt, params.swapType);
            return (0, convert_params_to_ton_config_1.convertTxParamsToTonConfig)(txParams);
        }
        catch (err) {
            throw err;
        }
    }
    /**
     * @returns gasLimit non wei
     */
    static async estimateGas(params, fromAmountWei, toMinAmountWei) {
        const web3Private = injector_1.Injector.web3PrivateService.getWeb3Private(blockchain_name_1.BLOCKCHAIN_NAME.TON);
        const walletAddress = web3Private?.address ?? fake_wallet_address_1.FAKE_TON_ADDRESS;
        const parsedWalletAddress = core_1.Address.parse(walletAddress);
        const priceLimitSqrt = params.zeroToOne
            ? BigInt(sdk_1.TickMath.MIN_SQRT_RATIO.toString()) + 1n
            : BigInt(sdk_1.TickMath.MAX_SQRT_RATIO.toString()) - 1n;
        const emulation = await sdk_1.PoolMessageManager.createEmulatedSwapExactInMessage(params.jettonWallets.srcUserJettonWallet, params.jettonWallets.dstRouterJettonWallet, parsedWalletAddress, BigInt(fromAmountWei.toFixed(0)), BigInt(toMinAmountWei.toFixed(0)), priceLimitSqrt, params.swapType);
        const nativeTon = native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.TON];
        // forwardGas is a part of gasLimit(gasLimit = forwardGas + txFee), used for boost tonco in calculation
        const gasLimit = web3_pure_1.Web3Pure.fromWei(emulation.forwardGas.toString(), nativeTon.decimals);
        return gasLimit;
    }
    static async fetchCommonParams(srcToken, dstToken) {
        const web3Private = injector_1.Injector.web3PrivateService.getWeb3Private(blockchain_name_1.BLOCKCHAIN_NAME.TON);
        const walletAddress = web3Private?.address ?? fake_wallet_address_1.FAKE_TON_ADDRESS;
        const parsedRouterAddress = core_1.Address.parse(sdk_1.ROUTER);
        const parsedWalletAddress = core_1.Address.parse(walletAddress);
        let srcRouterJettonWallet;
        let dstRouterJettonWallet;
        let srcUserJettonWallet;
        if (srcToken.isNative) {
            const parsedDstAddress = core_1.Address.parse(dstToken.address);
            [srcRouterJettonWallet, dstRouterJettonWallet, srcUserJettonWallet] = await Promise.all([
                Promise.resolve(core_1.Address.parse(sdk_1.pTON_ROUTER_WALLET)),
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedRouterAddress, parsedDstAddress),
                // tonco-sdk internally echanges userJettonWallet if src token is native
                Promise.resolve(core_1.Address.parse(addresses_1.STONFI_REFERRAL_ADDRESS))
            ]);
        }
        else if (dstToken.isNative) {
            const parsedSrcAddress = core_1.Address.parse(srcToken.address);
            [srcRouterJettonWallet, dstRouterJettonWallet, srcUserJettonWallet] = await Promise.all([
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedRouterAddress, parsedSrcAddress),
                Promise.resolve(core_1.Address.parse(sdk_1.pTON_ROUTER_WALLET)),
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedWalletAddress, parsedSrcAddress)
            ]);
        }
        else {
            const parsedSrcAddress = core_1.Address.parse(srcToken.address);
            const parsedDstAddress = core_1.Address.parse(dstToken.address);
            [srcRouterJettonWallet, dstRouterJettonWallet, srcUserJettonWallet] = await Promise.all([
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedRouterAddress, parsedSrcAddress),
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedRouterAddress, parsedDstAddress),
                ton_web3_pure_1.TonWeb3Pure.getWalletAddress(parsedWalletAddress, parsedSrcAddress)
            ]);
        }
        const poolAddress = (0, sdk_1.computePoolAddress)(srcRouterJettonWallet, dstRouterJettonWallet);
        const poolV3Contract = ton_client_1.TonClientInstance.getInstance().open(new sdk_1.PoolV3Contract(poolAddress));
        const { jetton0_minter } = await poolV3Contract.getPoolStateAndConfiguration();
        const zeroToOne = srcToken.isNative
            ? core_1.Address.parse(sdk_1.pTON_MINTER).equals(jetton0_minter)
            : core_1.Address.parse(srcToken.address).equals(jetton0_minter);
        const swapType = this.getSwapType(srcToken, dstToken);
        return {
            jettonWallets: { srcRouterJettonWallet, dstRouterJettonWallet, srcUserJettonWallet },
            zeroToOne,
            swapType,
            poolAddress: poolAddress
        };
    }
    static getSwapType(srcToken, dstToken) {
        if (srcToken.isNative)
            return sdk_1.SwapType.TON_TO_JETTON;
        if (dstToken.isNative)
            return sdk_1.SwapType.JETTON_TO_TON;
        return sdk_1.SwapType.JETTON_TO_JETTON;
    }
}
exports.ToncoSdkFacade = ToncoSdkFacade;
//# sourceMappingURL=tonco-sdk-facade.js.map