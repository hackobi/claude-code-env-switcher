"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeRouterAbstractTrade = void 0;
const errors_1 = require("../../../../../../../common/errors");
const check_unsupported_receiver_address_1 = require("../../../../../../common/utils/check-unsupported-receiver-address");
const rubic_proxy_contract_address_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
const native_router_api_service_1 = require("./services/native-router-api-service");
class NativeRouterAbstractTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    get spenderAddress() {
        return this.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway
            : this.providerGateway;
    }
    get dexContractAddress() {
        throw new errors_1.RubicSdkError('Dex address is unknown before swap is started');
    }
    constructor(tradeInstance) {
        super(tradeInstance.tradeStruct, tradeInstance.providerAddress);
        this.providerGateway = tradeInstance.providerGateway;
        this.nativeRouterQuoteParams = tradeInstance.nativeRouterQuoteParams;
    }
    async encode(options) {
        await (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options.receiverAddress, this.walletAddress);
        await this.checkFromAddress(options.fromAddress, true);
        await this.checkReceiverAddress(options.receiverAddress);
        if (this.useProxy) {
            return this.encodeProxy(options);
        }
        return this.encodeDirect(options);
    }
    async getTransactionConfigAndAmount(options) {
        const account = options.receiverAddress || options.fromAddress;
        try {
            const { amountOut, txRequest } = await native_router_api_service_1.NativeRouterApiService.getFirmQuote({
                ...this.nativeRouterQuoteParams,
                from_address: account
            });
            const tx = {
                to: txRequest.target,
                data: txRequest.calldata,
                value: txRequest.value
            };
            return {
                tx,
                toAmount: amountOut
            };
        }
        catch (err) {
            if ('statusCode' in err && 'message' in err) {
                throw new errors_1.RubicSdkError(err.message);
            }
            throw err;
        }
    }
}
exports.NativeRouterAbstractTrade = NativeRouterAbstractTrade;
//# sourceMappingURL=native-router-abstract-trade.js.map