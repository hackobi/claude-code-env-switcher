"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragonSwapTrade = void 0;
const check_unsupported_receiver_address_1 = require("../../../../../../common/utils/check-unsupported-receiver-address");
const on_chain_trade_type_1 = require("../../../common/models/on-chain-trade-type");
const DRAGON_SWAP_METHOD_1 = require("../../common/uniswap-v2-abstract/constants/DRAGON_SWAP_METHOD");
const uniswap_v2_abstract_trade_1 = require("../../common/uniswap-v2-abstract/uniswap-v2-abstract-trade");
const constants_1 = require("./constants");
class DragonSwapTrade extends uniswap_v2_abstract_trade_1.UniswapV2AbstractTrade {
    constructor() {
        super(...arguments);
        this.dexContractAddress = constants_1.DRAGON_SWAP_CONTRACT_ADDRESS;
    }
    static get type() {
        return on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.DRAGON_SWAP;
    }
    async encode(options) {
        await (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options.receiverAddress, this.walletAddress);
        await this.checkFromAddress(options.fromAddress, true);
        await this.checkReceiverAddress(options.receiverAddress);
        if (this.useProxy) {
            return this.encodeProxy(options);
        }
        return this.encodeDirect(options);
    }
}
exports.DragonSwapTrade = DragonSwapTrade;
DragonSwapTrade.swapMethods = DRAGON_SWAP_METHOD_1.DRAGON_SWAP_METHOD;
DragonSwapTrade.contractAbi = constants_1.DRAGON_SWAP_CONTRACT_ABI;
//# sourceMappingURL=dragonswap-trade.js.map