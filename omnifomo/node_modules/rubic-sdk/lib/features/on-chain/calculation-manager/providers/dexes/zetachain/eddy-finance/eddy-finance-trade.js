"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EddyFinanceTrade = void 0;
const errors_1 = require("../../../../../../../common/errors");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const evm_web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const check_unsupported_receiver_address_1 = require("../../../../../../common/utils/check-unsupported-receiver-address");
const rubic_proxy_contract_address_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const proxy_cross_chain_evm_trade_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const on_chain_trade_type_1 = require("../../../common/models/on-chain-trade-type");
const EDDY_SWAP_METHOD_1 = require("../../common/uniswap-v2-abstract/constants/EDDY_SWAP_METHOD");
const uniswap_v2_abstract_trade_1 = require("../../common/uniswap-v2-abstract/uniswap-v2-abstract-trade");
const constants_1 = require("./constants");
class EddyFinanceTrade extends uniswap_v2_abstract_trade_1.UniswapV2AbstractTrade {
    constructor() {
        super(...arguments);
        this.dexContractAddress = constants_1.EDDY_FINANCE_CALCULATE_CONTRACT_ADDRESS;
    }
    static get type() {
        return on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.EDDY_FINANCE;
    }
    get spenderAddress() {
        return this.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway
            : constants_1.EDDY_FINANCE_SWAP_CONTRACT_ADDRESS;
    }
    async getTransactionConfigAndAmount(options) {
        await this.checkFromAddress(options.fromAddress, true);
        (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options?.receiverAddress, options?.fromAddress || this.walletAddress);
        if (options.supportFee === undefined) {
            const needApprove = await this.needApprove(options.fromAddress);
            if (needApprove) {
                throw new errors_1.RubicSdkError('To use `encode` function, token must be approved for wallet');
            }
            try {
                await this.checkBalance();
            }
            catch (_err) {
                throw new errors_1.RubicSdkError('To use `encode` function, wallet must have enough balance or you must provider `supportFee` parameter in options.');
            }
        }
        const methodName = await this.getMethodName(options, options.fromAddress, false);
        const gasParams = this.getGasParams(options);
        const config = evm_web3_pure_1.EvmWeb3Pure.encodeMethodCall(constants_1.EDDY_FINANCE_SWAP_CONTRACT_ADDRESS, constants_1.EDDY_FINANCE_SWAP_CONTRACT_ABI, methodName, this.getCallParameters(), this.nativeValueToSend, gasParams);
        return { tx: config, toAmount: this.to.stringWeiAmount };
    }
    getCallParameters() {
        const { amountIn } = this.getAmountInAndAmountOut();
        // EddyFinance 13.05.2024::
        // amountOut is handled at our contracts for now so you can pass it as 0(Will be changed in future)
        const amountOut = '0';
        const amountParameters = this.from.isNative ? [amountOut] : [amountIn, amountOut];
        return [...amountParameters, this.wrappedPath.map(t => t.address)];
    }
    getSwapParametersByMethod(method) {
        const value = this.nativeValueToSend;
        return [
            constants_1.EDDY_FINANCE_SWAP_CONTRACT_ADDRESS,
            constants_1.EDDY_FINANCE_SWAP_CONTRACT_ABI,
            method,
            this.getCallParameters(),
            { value }
        ];
    }
    async getSwapData(options) {
        const directTransactionConfig = await this.encodeDirect({
            ...options,
            fromAddress: rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router,
            supportFee: false,
            receiverAddress: options.receiverAddress || rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router
        });
        const availableDexs = (await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getWhitelistedDexes(this.from.blockchain)).map(address => address.toLowerCase());
        const routerAddress = directTransactionConfig.to;
        const method = directTransactionConfig.data.slice(0, 10);
        if (!availableDexs.includes(routerAddress.toLowerCase())) {
            throw new errors_1.NotWhitelistedProviderError(routerAddress, undefined, 'dex');
        }
        await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.checkDexWhiteList(this.from.blockchain, routerAddress, method);
        return [
            [
                routerAddress,
                routerAddress,
                this.from.address,
                this.to.address,
                this.from.stringWeiAmount,
                directTransactionConfig.data,
                true
            ]
        ];
    }
    getAmountInAndAmountOut() {
        let amountIn = this.fromWithoutFee.stringWeiAmount;
        let amountOut = this.toTokenAmountMin.stringWeiAmount;
        if (this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN &&
            this.type === on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.EDDY_FINANCE &&
            !this.from.isNative) {
            amountIn = this.fromWithoutFee.weiAmount.minus(1).toFixed();
        }
        if (this.exact === 'output') {
            amountIn = this.fromWithoutFee.weiAmountPlusSlippage(this.slippageTolerance).toFixed(0);
            amountOut = this.to.stringWeiAmount;
        }
        return { amountIn, amountOut };
    }
}
exports.EddyFinanceTrade = EddyFinanceTrade;
EddyFinanceTrade.swapMethods = EDDY_SWAP_METHOD_1.EDDY_SWAP_METHOD;
//# sourceMappingURL=eddy-finance-trade.js.map