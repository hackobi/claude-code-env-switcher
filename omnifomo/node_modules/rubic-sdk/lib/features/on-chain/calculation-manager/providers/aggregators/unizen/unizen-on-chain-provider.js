"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniZenOnChainProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tokens_1 = require("../../../../../../common/tokens");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const fake_wallet_address_1 = require("../../../../../common/constants/fake-wallet-address");
const unizen_contract_addresses_1 = require("../../../../../cross-chain/calculation-manager/providers/unizen-provider/constants/unizen-contract-addresses");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const unizen_on_chain_supported_chains_1 = require("./constants/unizen-on-chain-supported-chains");
const unizen_on_chain_trade_1 = require("./unizen-on-chain-trade");
const unizen_on_chain_utils_service_1 = require("./utils/unizen-on-chain-utils-service");
class UniZenOnChainProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.UNIZEN;
    }
    isSupportedBlockchain(blockchainName) {
        return unizen_on_chain_supported_chains_1.unizenOnChainSupportedChains.some(chain => chain === blockchainName);
    }
    async calculate(from, toToken, options) {
        try {
            const fromBlockchain = from.blockchain;
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, options);
            const walletAddress = options.fromAddress || fake_wallet_address_1.FAKE_WALLET_ADDRESS;
            const quoteSendParams = {
                fromTokenAddress: from.address,
                toTokenAddress: toToken.address,
                amount: fromWithoutFee.stringWeiAmount,
                sender: walletAddress,
                slippage: options.slippageTolerance
            };
            const chainId = blockchain_id_1.blockchainId[from.blockchain];
            const quoteInfo = await unizen_on_chain_utils_service_1.UniZenOnChainUtilsService.getBestQuote(quoteSendParams, chainId);
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: new bignumber_js_1.default(quoteInfo.toTokenAmount)
            });
            const routePath = this.getRoutePath(from, to);
            const contractVersion = quoteInfo.contractVersion.toLowerCase();
            const unizenContractAddress = unizen_contract_addresses_1.uniZenContractAddresses[contractVersion][fromBlockchain];
            const onChainTradeStruct = {
                from,
                to,
                fromWithoutFee,
                proxyFeeInfo,
                unizenContractAddress,
                path: routePath,
                slippageTolerance: options.slippageTolerance,
                useProxy: options.useProxy,
                withDeflation: options.withDeflation,
                gasFeeInfo: null,
                minAmountOut: quoteInfo.transactionData.info.amountOutMin
            };
            const trade = new unizen_on_chain_trade_1.UniZenOnChainTrade({
                ...onChainTradeStruct,
                gasFeeInfo: await this.getGasFeeInfo()
            }, options.providerAddress);
            return trade;
        }
        catch (error) {
            return {
                type: this.tradeType,
                error
            };
        }
    }
}
exports.UniZenOnChainProvider = UniZenOnChainProvider;
//# sourceMappingURL=unizen-on-chain-provider.js.map