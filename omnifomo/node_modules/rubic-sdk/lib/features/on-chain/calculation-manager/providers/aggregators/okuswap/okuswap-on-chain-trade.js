"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OkuSwapOnChainTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const check_unsupported_receiver_address_1 = require("../../../../../common/utils/check-unsupported-receiver-address");
const rubic_proxy_contract_address_1 = require("../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
const okuswap_api_service_1 = require("./services/okuswap-api-service");
class OkuSwapOnChainTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    get spenderAddress() {
        return this.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway
            : this.providerGateway;
    }
    get fromBlockchain() {
        return this.from.blockchain;
    }
    get dexContractAddress() {
        throw new errors_1.RubicSdkError('Dex address is unknown before swap is started');
    }
    constructor(tradeStruct, providerAddress, providerGateway) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OKU_SWAP;
        this.providerGateway = providerGateway;
        this.okuSubProvider = tradeStruct.subProvider;
        this.quoteReqBody = tradeStruct.quoteReqBody;
        this.swapReqBody = tradeStruct.swapReqBody;
    }
    /**
     * Sends approve and if needed permit2Approve on UniswapV3Like-contract
     */
    async approve(options, checkNeedApprove = true, amount = 'infinity') {
        const permit2Address = this.permit2ApproveConfig.permit2Address ||
            '0xFcf5986450E4A014fFE7ad4Ae24921B589D039b5';
        if (this.permit2ApproveConfig.usePermit2Approve) {
            const needPermit2Approve = await this.needPermit2Approve();
            if (needPermit2Approve) {
                await this.web3Private.approveOnPermit2(this.from.address, permit2Address, this.spenderAddress, amount, new bignumber_js_1.default(1000000), options);
            }
        }
        if (checkNeedApprove) {
            const needApprove = await this.needApprove(this.walletAddress);
            if (!needApprove) {
                throw new errors_1.UnnecessaryApproveError();
            }
        }
        this.checkWalletConnected();
        await this.checkBlockchainCorrect();
        return this.web3Private.approveTokens(this.from.address, permit2Address, amount, options);
    }
    async needApprove(fromAddress) {
        if (this.from.isNative) {
            return false;
        }
        if (!fromAddress) {
            this.checkWalletConnected();
        }
        const permit2Address = this.permit2ApproveConfig.permit2Address ||
            '0xFcf5986450E4A014fFE7ad4Ae24921B589D039b5';
        const needPermit2Approve = await this.needPermit2Approve();
        const allowance = await this.web3Public.getAllowance(this.from.address, this.walletAddress, permit2Address);
        return allowance.lt(this.from.weiAmount) || needPermit2Approve;
    }
    async needPermit2Approve() {
        const permit2Address = this.permit2ApproveConfig.permit2Address ||
            '0xFcf5986450E4A014fFE7ad4Ae24921B589D039b5';
        const [allowance, expiration] = await this.web3Public.getAllowanceAndExpirationOnPermit2(this.from.address, this.walletAddress, this.spenderAddress, permit2Address);
        return this.from.weiAmount.gt(allowance) || new bignumber_js_1.default(Date.now()).gt(expiration);
    }
    async encode(options) {
        if (this.from.blockchain === 'ROOTSTOCK') {
            await (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options.receiverAddress, this.walletAddress);
        }
        await this.checkFromAddress(options.fromAddress, true);
        await this.checkReceiverAddress(options.receiverAddress);
        if (this.useProxy) {
            return this.encodeProxy(options);
        }
        return this.encodeDirect(options);
    }
    async getTransactionConfigAndAmount(_options) {
        const [{ outAmount, estimatedGas }, evmConfig] = await Promise.all([
            okuswap_api_service_1.OkuSwapApiService.makeQuoteRequest(this.okuSubProvider, this.quoteReqBody),
            okuswap_api_service_1.OkuSwapApiService.makeSwapRequest(this.okuSubProvider, this.swapReqBody)
        ]);
        return {
            toAmount: web3_pure_1.Web3Pure.toWei(outAmount, this.to.decimals),
            tx: { ...evmConfig, gas: estimatedGas }
        };
    }
}
exports.OkuSwapOnChainTrade = OkuSwapOnChainTrade;
//# sourceMappingURL=okuswap-on-chain-trade.js.map