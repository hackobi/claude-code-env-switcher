"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniZenOnChainTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tokens_1 = require("../../../../../../common/tokens");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const unizen_api_service_1 = require("../../../../../common/providers/unizen/services/unizen-api-service");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
const unizen_on_chain_utils_service_1 = require("./utils/unizen-on-chain-utils-service");
class UniZenOnChainTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    get dexContractAddress() {
        return this.unizenContractAddress;
    }
    get toTokenAmountMin() {
        return new tokens_1.PriceTokenAmount({
            ...this.to.asStruct,
            weiAmount: new bignumber_js_1.default(this.minAmountOut)
        });
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.UNIZEN;
        this.unizenContractAddress = tradeStruct.unizenContractAddress;
        this.minAmountOut = tradeStruct.minAmountOut;
    }
    async getTransactionConfigAndAmount(options) {
        const chainId = blockchain_id_1.blockchainId[this.from.blockchain];
        const quoteInfo = await this.getBestQuote(chainId, options.receiverAddress);
        this.minAmountOut = quoteInfo.transactionData.info.amountOutMin;
        const toAmount = quoteInfo.toTokenAmount;
        const swapSendParams = {
            transactionData: quoteInfo.transactionData,
            nativeValue: quoteInfo.nativeValue,
            account: this.walletAddress,
            receiver: options.receiverAddress || this.walletAddress,
            tradeType: quoteInfo.tradeType
        };
        const swapInfo = await unizen_api_service_1.UniZenApiService.getSwapInfo(swapSendParams, chainId, 'single');
        const evmConfig = {
            data: swapInfo.data,
            to: this.unizenContractAddress,
            value: swapInfo.nativeValue
        };
        return { tx: evmConfig, toAmount };
    }
    async getBestQuote(chainId, receiver) {
        const quoteSendParams = {
            fromTokenAddress: this.from.address,
            toTokenAddress: this.to.address,
            amount: this.fromWithoutFee.stringWeiAmount,
            sender: this.walletAddress,
            slippage: this.slippageTolerance,
            receiver: receiver || this.walletAddress
        };
        return unizen_on_chain_utils_service_1.UniZenOnChainUtilsService.getBestQuote(quoteSendParams, chainId);
    }
}
exports.UniZenOnChainTrade = UniZenOnChainTrade;
//# sourceMappingURL=unizen-on-chain-trade.js.map