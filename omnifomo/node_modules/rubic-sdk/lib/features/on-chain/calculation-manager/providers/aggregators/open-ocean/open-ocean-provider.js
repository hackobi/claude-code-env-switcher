"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenOceanProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const tokens_1 = require("../../../../../../common/tokens");
const p_timeout_1 = __importDefault(require("../../../../../../common/utils/p-timeout"));
const open_ocean_on_chain_supported_blockchain_1 = require("./constants/open-ocean-on-chain-supported-blockchain");
const open_ocean_on_chain_factory_1 = require("./open-ocean-on-chain-factory");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const get_gas_fee_info_1 = require("../../common/utils/get-gas-fee-info");
const get_gas_price_info_1 = require("../../common/utils/get-gas-price-info");
const open_ocean_api_service_1 = require("./services/open-ocean-api-service");
class OpenOceanProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN;
    }
    isSupportedBlockchain(blockchain) {
        return open_ocean_on_chain_supported_blockchain_1.openoceanOnChainSupportedBlockchains.some(item => item === blockchain);
    }
    async calculate(from, toToken, options) {
        try {
            // Uncomment after OO answer
            // if (from.blockchain === BLOCKCHAIN_NAME.SUI) {
            //     checkUnsupportedReceiverAddress(
            //         options?.receiverAddress,
            //         options?.fromAddress || this.getWalletAddress(from.blockchain)
            //     );
            // }
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, options);
            const quoteResponse = await (0, p_timeout_1.default)(open_ocean_api_service_1.OpenOceanApiService.fetchQuoteData(fromWithoutFee, toToken, options.slippageTolerance), 7000);
            if ([500, 400].includes(quoteResponse.code)) {
                return {
                    type: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN,
                    error: new errors_1.RubicSdkError(quoteResponse.error)
                };
            }
            const toWeiAmount = new bignumber_js_1.default(quoteResponse.data.outAmount);
            if (toWeiAmount.lte(0))
                throw new errors_1.NotSupportedTokensError();
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: toWeiAmount
            });
            const tradeStruct = {
                from,
                to,
                gasFeeInfo: await this.getGasFeeInfo(from, quoteResponse),
                slippageTolerance: options.slippageTolerance,
                path: [from, to],
                useProxy: options.useProxy,
                proxyFeeInfo,
                fromWithoutFee,
                withDeflation: options.withDeflation
            };
            return open_ocean_on_chain_factory_1.OpenOceanOnChainFactory.createTrade(from.blockchain, tradeStruct, options.providerAddress);
        }
        catch (error) {
            return {
                type: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN,
                error
            };
        }
    }
    async getGasFeeInfo(from, quote) {
        try {
            const gasPriceInfo = await (0, get_gas_price_info_1.getGasPriceInfo)(from.blockchain);
            const gasLimit = new bignumber_js_1.default(quote.data.estimatedGas);
            return (0, get_gas_fee_info_1.getGasFeeInfo)(gasPriceInfo, { gasLimit });
        }
        catch {
            return null;
        }
    }
}
exports.OpenOceanProvider = OpenOceanProvider;
//# sourceMappingURL=open-ocean-provider.js.map