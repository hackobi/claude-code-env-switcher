"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CetusTrade = void 0;
const cetus_sui_clmm_sdk_1 = require("@cetusprotocol/cetus-sui-clmm-sdk");
const errors_1 = require("../../../../../../common/errors");
const updated_rates_error_1 = require("../../../../../../common/errors/cross-chain/updated-rates-error");
const cetus_provider_1 = require("./cetus-provider");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_sui_on_chain_trade_abstract_1 = require("../../common/on-chain-aggregator/aggregator-sui-on-chain-trade-abstract");
class CetusTrade extends aggregator_sui_on_chain_trade_abstract_1.AggregatorSuiOnChainTrade {
    get spenderAddress() {
        throw new Error('Not implemented');
    }
    get dexContractAddress() {
        throw new errors_1.RubicSdkError('Dex address is unknown before swap is started');
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.CETUS;
        this.quoteResult = tradeStruct.aggregatorResult;
    }
    async encodeDirect(options) {
        await this.checkFromAddress(options.fromAddress, true);
        try {
            const transactionData = await this.getTxConfigAndCheckAmount(options.receiverAddress, options.fromAddress, options.skipAmountCheck);
            return {
                transaction: transactionData.transaction
            };
        }
        catch (err) {
            if (err instanceof updated_rates_error_1.UpdatedRatesError || err instanceof errors_1.RubicSdkError) {
                throw err;
            }
            throw new errors_1.RubicSdkError('Can not encode trade');
        }
    }
    async getToAmountAndTxData(receiverAddress, fromAddress) {
        try {
            const allCoinAsset = await cetus_provider_1.CetusProvider.swapSdk.getOwnerCoinAssets(fromAddress);
            const [quoteRes, payload] = await Promise.all([
                cetus_provider_1.CetusProvider.swapSdk.RouterV2.getBestRouter(this.from.address, this.to.address, this.from.stringWeiAmount, true, this.slippageTolerance, '', receiverAddress),
                cetus_sui_clmm_sdk_1.TransactionUtil.buildAggregatorSwapTransaction(cetus_provider_1.CetusProvider.swapSdk, this.quoteResult, allCoinAsset, '', this.slippageTolerance, receiverAddress)
            ]);
            const transaction = await payload.toJSON();
            return {
                tx: { transaction },
                toAmount: String(quoteRes.result.outputAmount)
            };
        }
        catch (err) {
            if ('statusCode' in err && 'message' in err) {
                throw new errors_1.RubicSdkError(err.message);
            }
            throw err;
        }
    }
}
exports.CetusTrade = CetusTrade;
//# sourceMappingURL=cetus-trade.js.map