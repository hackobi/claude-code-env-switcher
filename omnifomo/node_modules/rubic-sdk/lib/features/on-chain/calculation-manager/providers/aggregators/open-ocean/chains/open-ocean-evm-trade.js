"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenOceanEvmTrade = void 0;
const errors_1 = require("../../../../../../../common/errors");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const rubic_proxy_contract_address_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const proxy_cross_chain_evm_trade_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const on_chain_trade_type_1 = require("../../../common/models/on-chain-trade-type");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
const open_ocean_api_service_1 = require("../services/open-ocean-api-service");
class OpenOceanEvmTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    get spenderAddress() {
        const openOceanContractAddress = this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.OKE_X_CHAIN
            ? '0xc0006Be82337585481044a7d11941c0828FFD2D4'
            : '0x6352a56caadC4F1E25CD6c75970Fa768A3304e64';
        return this.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway
            : openOceanContractAddress;
    }
    get dexContractAddress() {
        throw new errors_1.RubicSdkError('Dex address is unknown before swap is started');
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN;
    }
    async getTransactionConfigAndAmount(options) {
        const swapQuoteResponse = await open_ocean_api_service_1.OpenOceanApiService.fetchSwapData(this.fromWithoutFee, this.to, options.receiverAddress || options.fromAddress, this.slippageTolerance);
        const { data, to, value, outAmount: toAmount } = swapQuoteResponse.data;
        return {
            tx: {
                data,
                to,
                value
            },
            toAmount
        };
    }
    async getSwapData(options) {
        const directTransactionConfig = await this.encodeDirect({
            ...options,
            fromAddress: rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router,
            supportFee: false,
            receiverAddress: rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].router
        });
        const availableDexs = (await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getWhitelistedDexes(this.from.blockchain)).map(address => address.toLowerCase());
        const routerAddress = directTransactionConfig.to;
        const method = directTransactionConfig.data.slice(0, 10);
        if (!availableDexs.includes(routerAddress.toLowerCase())) {
            throw new errors_1.NotWhitelistedProviderError(routerAddress, undefined, 'dex');
        }
        await proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.checkDexWhiteList(this.from.blockchain, routerAddress, method);
        return [
            [
                routerAddress,
                routerAddress,
                this.from.isNative && this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.METIS
                    ? '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000'
                    : this.from.address,
                this.to.address,
                this.from.stringWeiAmount,
                directTransactionConfig.data,
                true
            ]
        ];
    }
}
exports.OpenOceanEvmTrade = OpenOceanEvmTrade;
//# sourceMappingURL=open-ocean-evm-trade.js.map