"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PiteasProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tokens_1 = require("../../../../../../common/tokens");
const options_1 = require("../../../../../../common/utils/options");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const rubic_proxy_contract_address_1 = require("../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const piteas_on_chain_supported_blockchains_1 = require("./constants/piteas-on-chain-supported-blockchains");
const piteas_api_service_1 = require("./piteas-api-service");
const piteas_trade_1 = require("./piteas-trade");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const evm_provider_default_options_1 = require("../../dexes/common/on-chain-provider/evm-on-chain-provider/constants/evm-provider-default-options");
const get_gas_fee_info_1 = require("../../common/utils/get-gas-fee-info");
const get_gas_price_info_1 = require("../../common/utils/get-gas-price-info");
class PiteasProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            ...evm_provider_default_options_1.evmProviderDefaultOptions,
            deadlineMinutes: 20,
            disableMultihops: false
        };
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.PITEAS;
    }
    isSupportedBlockchain(blockchain) {
        return piteas_on_chain_supported_blockchains_1.piteasOnChainSupportedBlockchains.some(supportedNetwork => supportedNetwork === blockchain);
    }
    async calculate(from, toToken, options) {
        try {
            const fromAddress = options?.useProxy || this.defaultOptions.useProxy
                ? rubic_proxy_contract_address_1.rubicProxyContractAddress[from.blockchain].gateway
                : this.getWalletAddress(from.blockchain);
            const fullOptions = (0, options_1.combineOptions)(options, {
                ...this.defaultOptions,
                fromAddress
            });
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, {
                ...fullOptions
            });
            const quoteRequestParams = {
                tokenInAddress: from.isNative ? 'PLS' : from.address,
                tokenInChainId: blockchain_id_1.blockchainId[from.blockchain],
                tokenOutAddress: toToken.isNative ? 'PLS' : toToken.address,
                tokenOutChainId: blockchain_id_1.blockchainId[from.blockchain],
                amount: fromWithoutFee.stringWeiAmount,
                allowedSlippage: 0.5,
                ...(options?.fromAddress && { account: options.fromAddress })
            };
            const { destAmount, gasUseEstimate, methodParameters } = await piteas_api_service_1.PiteasApiService.fetchQuote(quoteRequestParams);
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: web3_pure_1.Web3Pure.fromWei(destAmount, toToken.decimals)
            });
            const tradeStruct = {
                from,
                to,
                slippageTolerance: fullOptions.slippageTolerance,
                path: [from, to],
                gasFeeInfo: await this.getGasFeeInfo(from, gasUseEstimate),
                useProxy: fullOptions.useProxy,
                proxyFeeInfo,
                fromWithoutFee,
                withDeflation: fullOptions.withDeflation,
                usedForCrossChain: fullOptions.usedForCrossChain,
                methodParameters
            };
            return new piteas_trade_1.PiteasTrade(tradeStruct, fullOptions.providerAddress, quoteRequestParams);
        }
        catch (err) {
            return {
                type: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.PITEAS,
                error: err
            };
        }
    }
    async getGasFeeInfo(from, gasLimit) {
        try {
            const gasPriceInfo = await (0, get_gas_price_info_1.getGasPriceInfo)(from.blockchain);
            return (0, get_gas_fee_info_1.getGasFeeInfo)(gasPriceInfo, { gasLimit: new bignumber_js_1.default(gasLimit) });
        }
        catch {
            return null;
        }
    }
}
exports.PiteasProvider = PiteasProvider;
//# sourceMappingURL=piteas-provider.js.map