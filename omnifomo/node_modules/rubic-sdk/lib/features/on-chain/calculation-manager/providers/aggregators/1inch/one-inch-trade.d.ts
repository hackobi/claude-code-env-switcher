import { PriceTokenAmount, Token } from "../../../../../../common/tokens";
import { EncodeTransactionOptions } from "../../../../../common/models/encode-transaction-options";
import { OneinchTradeStruct } from "./models/oneinch-trade-struct";
import { OnChainTradeType } from "../../common/models/on-chain-trade-type";
import { AggregatorEvmOnChainTrade } from "../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract";
import { EvmEncodedConfigAndToAmount } from "../../common/on-chain-aggregator/models/aggregator-on-chain-types";
export declare class OneInchTrade extends AggregatorEvmOnChainTrade {
    /** @internal */
    static checkIfNeedApproveAndThrowError(from: PriceTokenAmount, toToken: Token, fromWithoutFee: PriceTokenAmount, fromAddress: string, useProxy: boolean): Promise<void | never>;
    readonly dexContractAddress: string;
    private readonly nativeSupportedFromWithoutFee;
    private readonly nativeSupportedTo;
    private readonly disableMultihops;
    private readonly availableProtocols;
    /**
     * @internal
     * Path with wrapped native address.
     */
    readonly wrappedPath: ReadonlyArray<Token>;
    /** @internal */
    readonly transactionData: string | null;
    get type(): OnChainTradeType;
    constructor(tradeStruct: OneinchTradeStruct, providerAddress: string);
    protected getTransactionConfigAndAmount(options: EncodeTransactionOptions): Promise<EvmEncodedConfigAndToAmount>;
    private getResponseFromApiToTransactionRequest;
    private specifyError;
}
