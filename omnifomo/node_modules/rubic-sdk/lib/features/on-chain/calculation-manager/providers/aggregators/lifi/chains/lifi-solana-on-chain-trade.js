"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LifiSolanaOnChainTrade = void 0;
const errors_1 = require("../../../../../../../common/errors");
const updated_rates_error_1 = require("../../../../../../../common/errors/cross-chain/updated-rates-error");
const tokens_1 = require("../../../../../../../common/tokens");
const errors_2 = require("../../../../../../../common/utils/errors");
const get_solana_fee_1 = require("../../../../../../common/utils/get-solana-fee");
const rubic_proxy_contract_address_1 = require("../../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const aggregator_solana_on_chain_trade_abstract_1 = require("../../../common/on-chain-aggregator/aggregator-solana-on-chain-trade-abstract");
const lifi_on_chain_api_service_1 = require("../services/lifi-on-chain-api-service");
class LifiSolanaOnChainTrade extends aggregator_solana_on_chain_trade_abstract_1.AggregatorSolanaOnChainTrade {
    get spenderAddress() {
        return this.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway
            : this.providerGateway;
    }
    get dexContractAddress() {
        throw new errors_1.RubicSdkError('Dex address is unknown before swap is started');
    }
    get toTokenAmountMin() {
        return this._toTokenAmountMin;
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this._toTokenAmountMin = new tokens_1.PriceTokenAmount({
            ...this.to.asStruct,
            weiAmount: tradeStruct.toTokenWeiAmountMin
        });
        this.type = tradeStruct.type;
        this.route = tradeStruct.route;
        this.providerGateway = this.route.steps[0].estimate.approvalAddress;
    }
    async encodeDirect(options) {
        await this.checkFromAddress(options.fromAddress, true);
        try {
            const transactionData = await this.getTxConfigAndCheckAmount(options.receiverAddress, options.fromAddress, options.skipAmountCheck);
            return {
                data: transactionData.data,
                to: '',
                value: ''
            };
        }
        catch (err) {
            if ([400, 500, 503].includes(err.code)) {
                throw new errors_1.SwapRequestError();
            }
            if (err instanceof updated_rates_error_1.UpdatedRatesError || err instanceof errors_1.RubicSdkError) {
                throw err;
            }
            throw new errors_1.RubicSdkError('Can not encode trade');
        }
    }
    async swap(options = {}) {
        await this.checkWalletState(options?.testMode);
        const { onConfirm } = options;
        let transactionHash;
        const onTransactionHash = (hash) => {
            if (onConfirm) {
                onConfirm(hash);
            }
            transactionHash = hash;
        };
        const fromAddress = this.walletAddress;
        const receiverAddress = options.receiverAddress || this.walletAddress;
        const transactionConfig = await this.encode({
            fromAddress,
            receiverAddress,
            ...options
        });
        try {
            await this.web3Private.sendTransaction({
                data: transactionConfig.data,
                onTransactionHash
            }, false);
            return transactionHash;
        }
        catch (err) {
            if (err instanceof errors_1.FailedToCheckForTransactionReceiptError) {
                return transactionHash;
            }
            throw (0, errors_2.parseError)(err);
        }
    }
    async getToAmountAndTxData(receiverAddress, fromAddress) {
        const firstStep = this.route.steps[0];
        const step = {
            ...firstStep,
            action: {
                ...firstStep.action,
                fromAddress: fromAddress || this.walletAddress,
                toAddress: receiverAddress || this.walletAddress
            },
            execution: {
                status: 'NOT_STARTED',
                process: [
                    {
                        message: 'Preparing swap.',
                        startedAt: Date.now(),
                        status: 'STARTED',
                        type: 'SWAP'
                    }
                ]
            }
        };
        try {
            const rubicFee = (0, get_solana_fee_1.getSolanaFee)(this.from);
            const swapResponse = await lifi_on_chain_api_service_1.LifiOnChainApiService.getQuote(step.action.fromChainId, step.action.toChainId, step.action.fromToken.address, step.action.toToken.address, this.from.stringWeiAmount, step.action.fromAddress, step.action.slippage, rubicFee ? rubicFee : undefined);
            const { transactionRequest, estimate: { toAmount } } = swapResponse;
            return {
                tx: {
                    data: transactionRequest.data,
                    to: transactionRequest.to,
                    value: transactionRequest.value,
                    gas: transactionRequest.gasLimit,
                    gasPrice: transactionRequest.gasPrice
                },
                toAmount
            };
        }
        catch (err) {
            if ('statusCode' in err && 'message' in err) {
                throw new errors_1.RubicSdkError(err.message);
            }
            throw err;
        }
    }
}
exports.LifiSolanaOnChainTrade = LifiSolanaOnChainTrade;
//# sourceMappingURL=lifi-solana-on-chain-trade.js.map