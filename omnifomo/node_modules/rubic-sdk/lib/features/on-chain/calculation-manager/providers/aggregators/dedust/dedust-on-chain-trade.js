"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DedustOnChainTrade = void 0;
const errors_1 = require("../../../../../../common/utils/errors");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const ton_on_chain_trade_1 = require("../../common/on-chain-trade/ton-on-chain-trade/ton-on-chain-trade");
const dedust_swap_service_1 = require("./services/dedust-swap-service");
class DedustOnChainTrade extends ton_on_chain_trade_1.TonOnChainTrade {
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.DEDUST;
        this.dedustSwapService = new dedust_swap_service_1.DedustSwapService();
    }
    async swap(options = {}) {
        let txHash;
        const onTransactionHash = (hash) => {
            if (options.onConfirm) {
                options.onConfirm(hash);
            }
            txHash = hash;
        };
        await this.checkWalletState(options?.testMode);
        await this.makePreSwapChecks({
            fromAddress: this.walletAddress,
            receiverAddress: options.receiverAddress,
            skipAmountCheck: this.skipAmountCheck,
            ...(options?.referrer && { referrer: options?.referrer })
        });
        try {
            await this.dedustSwapService.sendTransaction(this.from, this.to, this.walletAddress, this.slippageTolerance, onTransactionHash);
            return txHash;
        }
        catch (err) {
            throw (0, errors_1.parseError)(err);
        }
    }
    calculateOutputAmount(_options) {
        return this.dedustSwapService.calcOutputAmount(this.from, this.to);
    }
}
exports.DedustOnChainTrade = DedustOnChainTrade;
//# sourceMappingURL=dedust-on-chain-trade.js.map