"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OkuSwapApiService = void 0;
const errors_1 = require("../../../../../../../common/errors");
const decorators_1 = require("../../../../../../../common/utils/decorators");
const injector_1 = require("../../../../../../../core/injector/injector");
const okuswap_api_1 = require("../constants/okuswap-api");
const okuswap_chain_names_1 = require("../models/okuswap-chain-names");
class OkuSwapApiService {
    static async makeQuoteRequest(subProvider, body) {
        try {
            return injector_1.Injector.httpClient.post(`${okuswap_api_1.RUBIC_X_API_OKU_BASE_URL}/${subProvider}/swap_quote`, body, {
                headers: {
                    apikey: okuswap_api_1.RUBIC_X_API_APIKEY
                }
            });
        }
        catch (err) {
            throw new errors_1.RubicSdkError(`[OKUSWAP] Err in api-method makeQuoteRequest - ${err}!`);
        }
    }
    static async makeSwapRequest(subProvider, body) {
        try {
            const { trade } = await injector_1.Injector.httpClient.post(`${okuswap_api_1.RUBIC_X_API_OKU_BASE_URL}/${subProvider}/execution_information`, body, {
                headers: {
                    apikey: okuswap_api_1.RUBIC_X_API_APIKEY
                }
            });
            return {
                to: trade.to,
                data: trade.data,
                value: trade.value
            };
        }
        catch (err) {
            throw new errors_1.RubicSdkError(`[OKUSWAP] Err in api-method makeSwapRequest - ${err}!`);
        }
    }
    static async getOkuSubProvidersForChain(blockchain) {
        try {
            const { status: subProviders } = await injector_1.Injector.httpClient.get(`${okuswap_api_1.RUBIC_X_API_OKU_BASE_URL}/overview`, {
                headers: {
                    apikey: okuswap_api_1.RUBIC_X_API_APIKEY
                }
            });
            return subProviders
                .filter(p => this.isSupportedProvider(p, blockchain))
                .map(p => p.name);
        }
        catch (err) {
            throw new errors_1.RubicSdkError(`[OKUSWAP] Err in api-method getOkuSubProvidersForChain - ${err}!`);
        }
    }
    static isSupportedProvider(provider, blockchain) {
        return (provider.active &&
            !!provider.report?.chains.includes(okuswap_chain_names_1.OKUSWAP_BLOCKCHAINS[blockchain]));
    }
}
exports.OkuSwapApiService = OkuSwapApiService;
__decorate([
    (0, decorators_1.Cache)({
        maxAge: 15000
    })
], OkuSwapApiService, "makeQuoteRequest", null);
__decorate([
    (0, decorators_1.Cache)({
        maxAge: 15000
    })
], OkuSwapApiService, "getOkuSubProvidersForChain", null);
//# sourceMappingURL=okuswap-api-service.js.map