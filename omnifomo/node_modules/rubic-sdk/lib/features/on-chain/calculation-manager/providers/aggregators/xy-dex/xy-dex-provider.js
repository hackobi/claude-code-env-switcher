"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyDexProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const tokens_1 = require("../../../../../../common/tokens");
const options_1 = require("../../../../../../common/utils/options");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const injector_1 = require("../../../../../../core/injector/injector");
const xy_api_params_1 = require("../../../../../common/providers/xy/constants/xy-api-params");
const xy_utils_1 = require("../../../../../common/providers/xy/utils/xy-utils");
const rubic_proxy_contract_address_1 = require("../../../../../cross-chain/calculation-manager/providers/common/constants/rubic-proxy-contract-address");
const xy_supported_blockchains_1 = require("../../../../../cross-chain/calculation-manager/providers/xy-provider/constants/xy-supported-blockchains");
const xy_dex_trade_1 = require("./xy-dex-trade");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
const evm_provider_default_options_1 = require("../../dexes/common/on-chain-provider/evm-on-chain-provider/constants/evm-provider-default-options");
const get_gas_fee_info_1 = require("../../common/utils/get-gas-fee-info");
const get_gas_price_info_1 = require("../../common/utils/get-gas-price-info");
class XyDexProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.defaultOptions = evm_provider_default_options_1.evmProviderDefaultOptions;
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.XY_DEX;
    }
    isSupportedBlockchain(blockchain) {
        return xy_supported_blockchains_1.xySupportedBlockchains.some(item => item === blockchain);
    }
    async calculate(from, toToken, options) {
        const fromAddress = options?.useProxy || this.defaultOptions.useProxy
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[from.blockchain].gateway
            : this.getWalletAddress(from.blockchain);
        const fullOptions = (0, options_1.combineOptions)(options, {
            ...this.defaultOptions,
            fromAddress
        });
        try {
            const { fromWithoutFee, proxyFeeInfo } = await this.handleProxyContract(from, fullOptions);
            const { toTokenAmountInWei, contractAddress, provider } = await this.getTradeInfo(fromWithoutFee, toToken, fullOptions);
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: toTokenAmountInWei
            });
            const tradeStruct = {
                contractAddress,
                from,
                to,
                slippageTolerance: fullOptions.slippageTolerance,
                gasFeeInfo: null,
                useProxy: fullOptions.useProxy,
                proxyFeeInfo,
                fromWithoutFee,
                withDeflation: fullOptions.withDeflation,
                usedForCrossChain: fullOptions.usedForCrossChain,
                path: [from, to],
                provider
            };
            return new xy_dex_trade_1.XyDexTrade(tradeStruct, fullOptions.providerAddress);
        }
        catch (err) {
            return {
                type: this.tradeType,
                error: err
            };
        }
    }
    async getTradeInfo(from, toToken, options) {
        const chainId = blockchain_id_1.blockchainId[from.blockchain];
        const srcQuoteTokenAddress = from.isNative ? xy_api_params_1.XY_NATIVE_ADDRESS : from.address;
        const dstQuoteTokenAddress = toToken.isNative ? xy_api_params_1.XY_NATIVE_ADDRESS : toToken.address;
        const quoteTradeParams = {
            srcChainId: chainId,
            srcQuoteTokenAddress,
            srcQuoteTokenAmount: from.stringWeiAmount,
            dstChainId: chainId,
            dstQuoteTokenAddress,
            slippage: options.slippageTolerance * 100,
            affiliate: xy_api_params_1.XY_AFFILIATE_ADDRESS
        };
        const trade = await injector_1.Injector.httpClient.get(`${xy_api_params_1.XY_API_ENDPOINT}/quote`, {
            params: { ...quoteTradeParams }
        });
        if (!trade.success) {
            (0, xy_utils_1.xyAnalyzeStatusCode)(trade.errorCode, trade.errorMsg);
        }
        const routesWithoutWithholdingFee = trade.routes.filter(route => {
            const withholdingFee = new bignumber_js_1.default(route.withholdingFeeAmount);
            return withholdingFee.lte(0);
        });
        const bestRoute = routesWithoutWithholdingFee[0];
        if (!bestRoute) {
            throw new errors_1.NotSupportedTokensError();
        }
        return {
            gasInfo: await this.getGasFeeInfo(from, bestRoute),
            toTokenAmountInWei: new bignumber_js_1.default(bestRoute.dstQuoteTokenAmount),
            contractAddress: bestRoute.contractAddress,
            provider: bestRoute.srcSwapDescription.provider
        };
    }
    async getGasFeeInfo(from, route) {
        try {
            const gasPriceInfo = await (0, get_gas_price_info_1.getGasPriceInfo)(from.blockchain);
            const gasLimit = new bignumber_js_1.default(route.estimatedGas);
            return (0, get_gas_fee_info_1.getGasFeeInfo)(gasPriceInfo, { gasLimit });
        }
        catch {
            return null;
        }
    }
}
exports.XyDexProvider = XyDexProvider;
//# sourceMappingURL=xy-dex-provider.js.map