"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenOceanApiService = void 0;
const native_tokens_1 = require("../../../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../../core/injector/injector");
const arbitrum_gas_price_1 = require("../constants/arbitrum-gas-price");
const open_ocean_blockchain_1 = require("../constants/open-ocean-blockchain");
class OpenOceanApiService {
    static async fetchQuoteData(fromWithoutFee, toToken, slippageTolerance) {
        const gasPriceNonWei = await this.getGasPriceNonWei(fromWithoutFee);
        const quoteResponse = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v4/${open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain]}/quote`, {
            headers: { apikey: 'sndfje3u4b3fnNSDNFUSDNVSunw345842hrnfd3b4nt4' },
            params: {
                chain: open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain],
                inTokenAddress: this.getTokenAddress(fromWithoutFee),
                outTokenAddress: this.getTokenAddress(toToken),
                amount: fromWithoutFee.tokenAmount.toString(),
                // @TODO check if needs to pass slippage in quote
                slippage: slippageTolerance * 100,
                gasPrice: gasPriceNonWei
            }
        });
        return quoteResponse;
    }
    static async fetchSwapData(fromWithoutFee, to, walletAddress, slippageTolerance) {
        const gasPriceNonWei = await this.getGasPriceNonWei(fromWithoutFee);
        const swapResponse = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v4/${open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain]}/swap`, {
            headers: { apikey: 'sndfje3u4b3fnNSDNFUSDNVSunw345842hrnfd3b4nt4' },
            params: {
                chain: open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain],
                inTokenAddress: this.getTokenAddress(fromWithoutFee),
                outTokenAddress: this.getTokenAddress(to),
                amount: fromWithoutFee.tokenAmount.toString(),
                gasPrice: gasPriceNonWei,
                slippage: slippageTolerance * 100,
                account: walletAddress,
                referrer: '0x429A3A1a2623DFb520f1D93F64F38c0738418F1f'
            }
        });
        return swapResponse;
    }
    static async fetchSuiSwapData(fromWithoutFee, to, walletAddress, slippageTolerance, senderAddress) {
        const gasPriceNonWei = await this.getGasPriceNonWei(fromWithoutFee);
        const swapResponse = await injector_1.Injector.httpClient.get(`${this.xApiUrl}/v4/${open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain]}/swap`, {
            headers: { apikey: 'sndfje3u4b3fnNSDNFUSDNVSunw345842hrnfd3b4nt4' },
            params: {
                chain: open_ocean_blockchain_1.openOceanBlockchainName[fromWithoutFee.blockchain],
                inTokenAddress: this.getTokenAddress(fromWithoutFee),
                outTokenAddress: this.getTokenAddress(to),
                amount: fromWithoutFee.tokenAmount.toString(),
                gasPrice: gasPriceNonWei,
                slippage: slippageTolerance * 100,
                account: walletAddress,
                sender: senderAddress,
                referrer: '0x429A3A1a2623DFb520f1D93F64F38c0738418F1f'
            }
        });
        return swapResponse;
    }
    static async getGasPriceNonWei(fromWithoutFee) {
        if (fromWithoutFee.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI) {
            return '5000000000';
        }
        if (fromWithoutFee.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ARBITRUM) {
            return arbitrum_gas_price_1.ARBITRUM_GAS_PRICE;
        }
        const gasPriceWei = await injector_1.Injector.web3PublicService
            .getWeb3Public(fromWithoutFee.blockchain)
            .getGasPrice();
        const gasPriceNonWei = web3_pure_1.Web3Pure.fromWei(gasPriceWei, native_tokens_1.nativeTokensList[fromWithoutFee.blockchain].decimals)
            .multipliedBy(10 ** 9)
            .toString();
        return gasPriceNonWei;
    }
    static getTokenAddress(token) {
        if (token.isNative) {
            if (token.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI) {
                return token.address;
            }
            if (token.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.METIS) {
                return '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000';
            }
            return this.nativeOpenOceanAddress;
        }
        return token.address;
    }
}
exports.OpenOceanApiService = OpenOceanApiService;
OpenOceanApiService.apiV4Url = 'https://open-api.openocean.finance/v4';
OpenOceanApiService.xApiUrl = 'https://x-api.rubic.exchange/oo/api';
OpenOceanApiService.nativeOpenOceanAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
//# sourceMappingURL=open-ocean-api-service.js.map