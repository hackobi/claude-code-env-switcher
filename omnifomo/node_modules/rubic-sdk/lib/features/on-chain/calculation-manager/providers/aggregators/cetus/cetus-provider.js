"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CetusProvider = void 0;
const cetus_sui_clmm_sdk_1 = require("@cetusprotocol/cetus-sui-clmm-sdk");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tokens_1 = require("../../../../../../common/tokens");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const cetus_trade_1 = require("./cetus-trade");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_on_chain_provider_abstract_1 = require("../../common/on-chain-aggregator/aggregator-on-chain-provider-abstract");
class CetusProvider extends aggregator_on_chain_provider_abstract_1.AggregatorOnChainProvider {
    constructor() {
        super(...arguments);
        this.tradeType = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.CETUS;
    }
    isSupportedBlockchain(blockchain) {
        return blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI;
    }
    async calculate(from, toToken, options) {
        try {
            const { fromWithoutFee } = await this.handleProxyContract(from, options);
            const route = await CetusProvider.swapSdk.RouterV2.getBestRouter(from.address, toToken.address, from.stringWeiAmount, true, options.slippageTolerance, '');
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: new bignumber_js_1.default(route.result.outputAmount)
            });
            const tradeStruct = {
                from,
                to,
                slippageTolerance: options.slippageTolerance,
                gasFeeInfo: null,
                useProxy: options.useProxy,
                withDeflation: options.withDeflation,
                aggregatorResult: route.result,
                fromWithoutFee: fromWithoutFee,
                path: [from, toToken]
            };
            return new cetus_trade_1.CetusTrade(tradeStruct, options.providerAddress);
        }
        catch (error) {
            return {
                type: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN,
                error
            };
        }
    }
}
exports.CetusProvider = CetusProvider;
CetusProvider.swapSdk = (0, cetus_sui_clmm_sdk_1.initCetusSDK)({ network: 'mainnet' });
//# sourceMappingURL=cetus-provider.js.map