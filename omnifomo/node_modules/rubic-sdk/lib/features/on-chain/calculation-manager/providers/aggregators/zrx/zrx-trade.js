"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZrxTrade = void 0;
const check_unsupported_receiver_address_1 = require("../../../../../common/utils/check-unsupported-receiver-address");
const zrx_api_service_1 = require("./zrx-api-service");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
class ZrxTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    get type() {
        return on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.ZRX;
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.affiliateAddress = tradeStruct.affiliateAddress;
        this.dexContractAddress = tradeStruct.routerAddress;
    }
    async getTransactionConfigAndAmount(options) {
        (0, check_unsupported_receiver_address_1.checkUnsupportedReceiverAddress)(options?.receiverAddress, options?.fromAddress || this.walletAddress);
        const quoteParams = {
            params: {
                sellToken: this.from.address,
                buyToken: this.to.address,
                sellAmount: this.fromWithoutFee.stringWeiAmount,
                slippagePercentage: this.slippageTolerance.toString(),
                ...(this.affiliateAddress && { affiliateAddress: this.affiliateAddress })
            }
        };
        const tradeData = await zrx_api_service_1.ZrxApiService.getTradeData(quoteParams, this.from.blockchain);
        const { gas, gasPrice } = this.getGasParams(options);
        const config = {
            to: tradeData.to,
            data: tradeData.data,
            value: tradeData.value,
            gas,
            gasPrice
        };
        return { tx: config, toAmount: tradeData.buyAmount };
    }
}
exports.ZrxTrade = ZrxTrade;
//# sourceMappingURL=zrx-trade.js.map