"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DedustApiService = void 0;
const core_1 = require("@ton/core");
const errors_1 = require("../../../../../../../common/errors");
const ton_web3_pure_1 = require("../../../../../../../core/blockchain/web3-pure/typed-web3-pure/ton-web3-pure/ton-web3-pure");
const injector_1 = require("../../../../../../../core/injector/injector");
class DedustApiService {
    static async findBestPools(from, to) {
        const [fromAddresses, toAddresses] = await Promise.all([
            ton_web3_pure_1.TonWeb3Pure.getAllFormatsOfAddress(from.address),
            ton_web3_pure_1.TonWeb3Pure.getAllFormatsOfAddress(to.address)
        ]);
        const fromRawAddress = from.isNative ? 'native' : `jetton:${fromAddresses.raw_form}`;
        const toRawAddress = to.isNative ? 'native' : `jetton:${toAddresses.raw_form}`;
        const resp = await injector_1.Injector.httpClient.post(`${this.apiUrl}/routing/plan`, {
            from: fromRawAddress,
            to: toRawAddress,
            amount: from.stringWeiAmount
        });
        if (resp.length > 1) {
            throw new errors_1.RubicSdkError('Multihop swaps are forbidden in dedust.');
        }
        const pools = resp[0];
        return pools.map(p => ({
            amountOut: p.amountOut,
            poolAddress: core_1.Address.parse(p.pool.address),
            srcTokenAddress: this.convertApiTokenAddressToPlain(p.assetIn),
            dstTokenAddress: this.convertApiTokenAddressToPlain(p.assetOut)
        }));
    }
    static convertApiTokenAddressToPlain(address) {
        if (address === 'native')
            return ton_web3_pure_1.TonWeb3Pure.nativeTokenAddress;
        return core_1.Address.parse(address.replace(/jetton:/i, '')).toString();
    }
}
exports.DedustApiService = DedustApiService;
DedustApiService.apiUrl = 'https://api.dedust.io/v2';
//# sourceMappingURL=dedust-api-service.js.map