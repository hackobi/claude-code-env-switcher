"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyDexTrade = void 0;
const decorators_1 = require("../../../../../../common/utils/decorators");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const evm_web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const injector_1 = require("../../../../../../core/injector/injector");
const xy_api_params_1 = require("../../../../../common/providers/xy/constants/xy-api-params");
const xy_utils_1 = require("../../../../../common/providers/xy/utils/xy-utils");
const on_chain_trade_type_1 = require("../../common/models/on-chain-trade-type");
const aggregator_evm_on_chain_trade_abstract_1 = require("../../common/on-chain-aggregator/aggregator-evm-on-chain-trade-abstract");
class XyDexTrade extends aggregator_evm_on_chain_trade_abstract_1.AggregatorEvmOnChainTrade {
    /** @internal */
    static async getGasLimit(tradeStruct) {
        const fromBlockchain = tradeStruct.from.blockchain;
        const walletAddress = injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(fromBlockchain).address;
        if (!walletAddress) {
            return null;
        }
        try {
            const transactionConfig = await new XyDexTrade(tradeStruct, evm_web3_pure_1.EvmWeb3Pure.EMPTY_ADDRESS).encode({ fromAddress: walletAddress });
            const web3Public = injector_1.Injector.web3PublicService.getWeb3Public(fromBlockchain);
            const gasLimit = (await web3Public.batchEstimatedGas(walletAddress, [transactionConfig]))[0];
            if (!gasLimit?.isFinite()) {
                return null;
            }
            return gasLimit;
        }
        catch (_err) {
            return null;
        }
    }
    constructor(tradeStruct, providerAddress) {
        super(tradeStruct, providerAddress);
        this.type = on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.XY_DEX;
        this.dexContractAddress = tradeStruct.contractAddress;
        this.provider = tradeStruct.provider;
    }
    async getTransactionConfigAndAmount(options) {
        const receiver = options.receiverAddress || this.walletAddress;
        const chainId = blockchain_id_1.blockchainId[this.from.blockchain];
        const srcQuoteTokenAddress = this.from.isNative ? xy_api_params_1.XY_NATIVE_ADDRESS : this.from.address;
        const dstQuoteTokenAddress = this.to.isNative ? xy_api_params_1.XY_NATIVE_ADDRESS : this.to.address;
        const quoteTradeParams = {
            srcChainId: chainId,
            srcQuoteTokenAddress,
            srcQuoteTokenAmount: this.fromWithoutFee.stringWeiAmount,
            dstChainId: chainId,
            dstQuoteTokenAddress,
            slippage: this.slippageTolerance * 100,
            receiver,
            srcSwapProvider: this.provider,
            affiliate: xy_api_params_1.XY_AFFILIATE_ADDRESS
        };
        const tradeData = await this.getResponseFromApiToTransactionRequest(quoteTradeParams);
        if (!tradeData.success) {
            (0, xy_utils_1.xyAnalyzeStatusCode)(tradeData.errorCode, tradeData.errorMsg);
        }
        return { tx: tradeData.tx, toAmount: tradeData.route.dstQuoteTokenAmount };
    }
    async getResponseFromApiToTransactionRequest(params) {
        return injector_1.Injector.httpClient.get(`${xy_api_params_1.XY_API_ENDPOINT}/buildTx`, {
            params: { ...params }
        });
    }
}
exports.XyDexTrade = XyDexTrade;
__decorate([
    (0, decorators_1.Cache)({
        maxAge: 15000
    })
], XyDexTrade.prototype, "getResponseFromApiToTransactionRequest", null);
//# sourceMappingURL=xy-dex-trade.js.map