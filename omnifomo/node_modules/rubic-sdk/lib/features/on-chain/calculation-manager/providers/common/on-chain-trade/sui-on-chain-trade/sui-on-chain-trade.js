"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiOnChainTrade = void 0;
const transactions_1 = require("@mysten/sui/transactions");
const errors_1 = require("../../../../../../../common/errors");
const errors_2 = require("../../../../../../../common/utils/errors");
const blockchain_name_1 = require("../../../../../../../core/blockchain/models/blockchain-name");
const injector_1 = require("../../../../../../../core/injector/injector");
const on_chain_trade_1 = require("../on-chain-trade");
class SuiOnChainTrade extends on_chain_trade_1.OnChainTrade {
    get spenderAddress() {
        throw new errors_1.RubicSdkError('No spender address!');
    }
    get web3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.SUI);
    }
    get web3Private() {
        return injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(blockchain_name_1.BLOCKCHAIN_NAME.SUI);
    }
    constructor(tradeStruct, providerAddress) {
        super(providerAddress);
        this.from = tradeStruct.from;
        this.to = tradeStruct.to;
        this.slippageTolerance = tradeStruct.slippageTolerance;
        this.path = tradeStruct.path;
        this.gasFeeInfo = tradeStruct.gasFeeInfo;
        this.useProxy = false;
        this.fromWithoutFee = tradeStruct.fromWithoutFee;
        this.feeInfo = {};
        this.withDeflation = tradeStruct.withDeflation;
    }
    async approve(_options, _checkNeedApprove = true, _amount = 'infinity') {
        throw new Error('Method is not supported');
    }
    async encodeApprove(_tokenAddress, _spenderAddress, _value, _options = {}) {
        throw new Error('Method is not supported');
    }
    async checkAllowanceAndApprove() {
        throw new Error('Method is not supported');
    }
    async swap(options = {}) {
        await this.checkWalletState(options?.testMode);
        const { onConfirm } = options;
        let transactionHash;
        const onTransactionHash = (hash) => {
            if (onConfirm) {
                onConfirm(hash);
            }
            transactionHash = hash;
        };
        const fromAddress = this.walletAddress;
        const receiverAddress = options.receiverAddress || this.walletAddress;
        const transactionConfig = await this.encode({
            fromAddress,
            receiverAddress,
            ...options
        });
        try {
            await this.web3Private.sendTransaction({
                transactionBlock: transactions_1.Transaction.from(transactionConfig.transaction),
                onTransactionHash
            });
            return transactionHash;
        }
        catch (err) {
            if (err instanceof errors_1.FailedToCheckForTransactionReceiptError) {
                return transactionHash;
            }
            throw (0, errors_2.parseError)(err);
        }
    }
    async encode(options) {
        await this.checkFromAddress(options.fromAddress, true);
        await this.checkReceiverAddress(options.receiverAddress);
        return this.encodeDirect(options);
    }
}
exports.SuiOnChainTrade = SuiOnChainTrade;
//# sourceMappingURL=sui-on-chain-trade.js.map