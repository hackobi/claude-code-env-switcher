"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateSendFeeLZ = estimateSendFeeLZ;
const utils_1 = require("ethers/lib/utils");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const injector_1 = require("../../../../../../core/injector/injector");
const algb_token_addresses_1 = require("../constants/algb-token-addresses");
const layerzero_bridge_address_1 = require("../constants/layerzero-bridge-address");
const layzerzero_chain_ids_1 = require("../constants/layzerzero-chain-ids");
const layerzero_oft_abi_1 = require("../models/layerzero-oft-abi");
async function estimateSendFeeLZ(from, to, receiverAddress) {
    const web3Public = injector_1.Injector.web3PublicService.getWeb3Public(from.blockchain);
    const walletAddress = injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(from.blockchain).address;
    const adapterParams = (0, utils_1.solidityPack)(['uint16', 'uint256'], [1, to.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ARBITRUM ? 2000000 : 200000]);
    const contractAddress = from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.POLYGON
        ? layerzero_bridge_address_1.layerZeroProxyOFT[blockchain_name_1.BLOCKCHAIN_NAME.POLYGON]
        : algb_token_addresses_1.ALGB_TOKEN[from.blockchain];
    const methodArguments = [
        layzerzero_chain_ids_1.layerZeroChainIds[to.blockchain],
        receiverAddress || walletAddress,
        from.stringWeiAmount,
        false,
        adapterParams
    ];
    const gasFee = await web3Public.callContractMethod(contractAddress, layerzero_oft_abi_1.layerZeroOFTABI, 'estimateSendFee', methodArguments);
    return gasFee[0];
}
//# sourceMappingURL=estimate-fee.js.map