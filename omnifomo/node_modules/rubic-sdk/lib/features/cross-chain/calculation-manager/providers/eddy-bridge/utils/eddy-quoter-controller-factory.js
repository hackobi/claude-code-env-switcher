"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EddyQuoterControllerFactory = void 0;
const tokens_1 = require("../../../../../../common/tokens");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const eddy_finance_provider_1 = require("../../../../../on-chain/calculation-manager/providers/dexes/zetachain/eddy-finance/eddy-finance-provider");
const eddy_bridge_routing_directions_1 = require("./eddy-bridge-routing-directions");
const find_transit_token_address_1 = require("./find-transit-token-address");
class EddyQuoterControllerFactory {
    constructor() { }
    static createController(from, toToken, ratioToAmount, gasFeeInSrcTokenUnits, slippageTolerance) {
        const calculationType = (0, eddy_bridge_routing_directions_1.getEddyCalculationType)(from, toToken);
        const calculationFn = EddyQuoterControllerFactory.calculators[calculationType];
        const calculationOptions = {
            slippageTolerance,
            gasCalculation: 'disabled',
            useProxy: false
        };
        return {
            calculateToAmount: async () => {
                const toAmount = await calculationFn(from, toToken, calculationOptions, ratioToAmount);
                return toAmount.minus(gasFeeInSrcTokenUnits);
            }
        };
    }
    static async calculateDirectBridge(from, _toToken, _options, ratioToAmount) {
        return from.tokenAmount.multipliedBy(ratioToAmount);
    }
    static async calculateSwapFromZetachain(from, toToken, options, ratioToAmount) {
        const fromZrc20Token = new tokens_1.PriceTokenAmount({
            ...from.asStruct,
            tokenAmount: from.tokenAmount.multipliedBy(ratioToAmount)
        });
        const toZrc20Token = await tokens_1.PriceToken.createToken({
            address: (0, find_transit_token_address_1.findCompatibleZrc20TokenAddress)(toToken),
            blockchain: blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN
        });
        const toAmount = await EddyQuoterControllerFactory.calculateOnChainToAmount(fromZrc20Token, toZrc20Token, options);
        return toAmount;
    }
    static async calculateSwapToZetachain(from, toToken, options, ratioToAmount) {
        const fromZrc20Token = await tokens_1.PriceTokenAmount.createToken({
            address: (0, find_transit_token_address_1.findCompatibleZrc20TokenAddress)(from),
            blockchain: blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN,
            tokenAmount: from.tokenAmount.multipliedBy(ratioToAmount)
        });
        const toAmount = await EddyQuoterControllerFactory.calculateOnChainToAmount(fromZrc20Token, toToken, options);
        return toAmount;
    }
    static async calculateSwapBetweenOtherChains(from, toToken, options, ratioToAmount) {
        const fromZrc20Token = await tokens_1.PriceTokenAmount.createToken({
            address: (0, find_transit_token_address_1.findCompatibleZrc20TokenAddress)(from),
            blockchain: blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN,
            tokenAmount: from.tokenAmount.multipliedBy(ratioToAmount)
        });
        const toZrc20Token = await tokens_1.PriceToken.createToken({
            address: (0, find_transit_token_address_1.findCompatibleZrc20TokenAddress)(toToken),
            blockchain: blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN
        });
        const toAmount = await EddyQuoterControllerFactory.calculateOnChainToAmount(fromZrc20Token, toZrc20Token, options);
        return toAmount;
    }
    static async calculateOnChainToAmount(fromZrc20Token, toZrc20Token, options) {
        const calcData = await new eddy_finance_provider_1.EddyFinanceProvider().calculate(fromZrc20Token, toZrc20Token, {
            ...options,
            gasCalculation: 'disabled',
            useProxy: false
        });
        return calcData.to.tokenAmount;
    }
}
exports.EddyQuoterControllerFactory = EddyQuoterControllerFactory;
EddyQuoterControllerFactory.calculators = {
    [eddy_bridge_routing_directions_1.EDDY_CALCULATION_TYPES.DIRECT_BRIDGE]: EddyQuoterControllerFactory.calculateDirectBridge,
    [eddy_bridge_routing_directions_1.EDDY_CALCULATION_TYPES.SWAP_FROM_ZETACHAIN]: EddyQuoterControllerFactory.calculateSwapFromZetachain,
    [eddy_bridge_routing_directions_1.EDDY_CALCULATION_TYPES.SWAP_TO_ZETACHAIN]: EddyQuoterControllerFactory.calculateSwapToZetachain,
    [eddy_bridge_routing_directions_1.EDDY_CALCULATION_TYPES.SWAP_BETWEEN_OTHER_CHAINS]: EddyQuoterControllerFactory.calculateSwapBetweenOtherChains
};
//# sourceMappingURL=eddy-quoter-controller-factory.js.map