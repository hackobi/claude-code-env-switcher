"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MesonCcrApiService = void 0;
const errors_1 = require("../../../../../../common/errors");
const tx_status_1 = require("../../../../../../core/blockchain/web3-public-service/web3-public/models/tx-status");
const injector_1 = require("../../../../../../core/injector/injector");
class MesonCcrApiService {
    static async fetchMesonFee(sourceAssetString, targetAssetString, amount) {
        try {
            const res = await injector_1.Injector.httpClient.post(`${this.apiUrl}/price`, {
                from: sourceAssetString,
                to: targetAssetString,
                amount
            });
            if ('converted' in res.result) {
                throw new errors_1.RubicSdkError('converted');
            }
            return res.result.totalFee;
        }
        catch (e) {
            const res = this.parseMesonError(e);
            if (!res?.fee) {
                throw e;
            }
            return res.fee;
        }
    }
    static async fetchChainsLimits() {
        const { result: chains } = await injector_1.Injector.httpClient.get(`${this.apiUrl}/limits`);
        return chains;
    }
    static async fetchInfoForTx(params) {
        try {
            const res = await injector_1.Injector.httpClient.post(`${this.apiUrl}/swap`, {
                from: params.sourceAssetString,
                to: params.targetAssetString,
                amount: params.amount,
                fromAddress: params.fromAddress,
                fromContract: params.useProxy,
                recipient: params.receiverAddress
            });
            if ('converted' in res.result) {
                throw new errors_1.RubicSdkError('converted');
            }
            return res.result;
        }
        catch (e) {
            const res = this.parseMesonError(e);
            return res;
        }
    }
    static async fetchTxStatus(srcTxHash) {
        try {
            const res = await injector_1.Injector.httpClient.get(`${this.apiUrl}/swap`, {
                params: {
                    hash: srcTxHash
                }
            });
            if (res.result.expired) {
                return {
                    hash: null,
                    status: tx_status_1.TX_STATUS.FAIL
                };
            }
            if (res.result.RELEASED) {
                return {
                    hash: res.result.RELEASED,
                    status: tx_status_1.TX_STATUS.SUCCESS,
                    extraInfo: {
                        mesonSwapId: res.result.swap.id
                    }
                };
            }
            return {
                hash: null,
                status: tx_status_1.TX_STATUS.PENDING
            };
        }
        catch {
            return {
                hash: null,
                status: tx_status_1.TX_STATUS.PENDING
            };
        }
    }
    static parseMesonError(err) {
        if (err.message?.includes('converted')) {
            throw new errors_1.NotSupportedTokensError();
        }
        const { error: { error: { data } } } = err;
        if (!data || 'converted' in data)
            throw new errors_1.NotSupportedTokensError();
        return data;
    }
}
exports.MesonCcrApiService = MesonCcrApiService;
MesonCcrApiService.apiUrl = 'https://relayer.meson.fi/api/v1';
//# sourceMappingURL=meson-cross-chain-api-service.js.map