"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleSwapCcrProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../common/errors");
const tokens_1 = require("../../../../../common/tokens");
const blockchain_1 = require("../../../../../common/utils/blockchain");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const cross_chain_provider_1 = require("../common/cross-chain-provider");
const cross_chain_transfer_trade_1 = require("../common/cross-chain-transfer-trade/cross-chain-transfer-trade");
const proxy_cross_chain_evm_trade_1 = require("../common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const simple_swap_ccr_api_blockchain_1 = require("./constants/simple-swap-ccr-api-blockchain");
const simple_swap_ccr_supported_chains_1 = require("./constants/simple-swap-ccr-supported-chains");
const simple_swap_native_tokens_1 = require("./constants/simple-swap-native-tokens");
const simple_swap_api_service_1 = require("./services/simple-swap-api-service");
const simple_swap_ccr_trade_1 = require("./simple-swap-ccr-trade");
class SimpleSwapCcrProvider extends cross_chain_provider_1.CrossChainProvider {
    constructor() {
        super(...arguments);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.SIMPLE_SWAP;
    }
    isSupportedBlockchain(fromBlockchain) {
        return Object.keys(simple_swap_ccr_api_blockchain_1.simpleSwapApiChain).includes(fromBlockchain);
    }
    isProxySupportedChain(fromBlockchain) {
        return simple_swap_ccr_supported_chains_1.simpleSwapCcrProxySupportedChains.some(supportedChain => supportedChain === fromBlockchain);
    }
    async calculate(from, toToken, options) {
        const useProxy = this.isProxySupportedChain(from.blockchain) &&
            (options?.useProxy?.[this.type] || false);
        try {
            const { fromCurrency, toCurrency } = await this.getSimpleSwapCurrencies(from, toToken);
            if (!fromCurrency || !toCurrency) {
                return {
                    trade: null,
                    error: new errors_1.NotSupportedTokensError(),
                    tradeType: this.type
                };
            }
            const toBlockchain = toToken.blockchain;
            const feeInfo = await this.getFeeInfo(from.blockchain, options.providerAddress, from, useProxy);
            const minMaxError = await this.checkMinMaxErrors(from, toBlockchain, fromCurrency.ticker, toCurrency.ticker);
            if (minMaxError) {
                const emptyTrade = this.getEmptyTrade(from, toToken, fromCurrency, toCurrency, feeInfo, options.providerAddress);
                return {
                    trade: emptyTrade,
                    error: minMaxError,
                    tradeType: this.type
                };
            }
            const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(from, feeInfo.rubicProxy?.platformFee?.percent);
            const toAmount = await simple_swap_api_service_1.SimpleSwapApiService.getEstimation({
                tickerFrom: fromCurrency.ticker,
                tickerTo: toCurrency.ticker,
                networkFrom: fromCurrency.network,
                networkTo: toCurrency.network,
                fixed: true,
                amount: fromWithoutFee.tokenAmount.toFixed()
            });
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: new bignumber_js_1.default(toAmount)
            });
            const routePath = await this.getRoutePath(from, to);
            const gasData = options.gasCalculation === 'enabled'
                ? await cross_chain_transfer_trade_1.CrossChainTransferTrade.getGasData(from)
                : null;
            const trade = new simple_swap_ccr_trade_1.SimpleSwapCcrTrade({
                from: from,
                to: to,
                gasData,
                feeInfo,
                priceImpact: from.calculatePriceImpactPercent(to),
                fromCurrency,
                toCurrency
            }, options.providerAddress, routePath, useProxy);
            return {
                trade,
                tradeType: this.type
            };
        }
        catch (error) {
            return {
                trade: null,
                tradeType: this.type,
                error
            };
        }
    }
    async getRoutePath(from, to) {
        return [
            {
                type: 'cross-chain',
                provider: cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.SIMPLE_SWAP,
                path: [from, to]
            }
        ];
    }
    getEmptyTrade(from, toToken, fromCurrency, toCurrency, feeInfo, providerAddress) {
        const to = new tokens_1.PriceTokenAmount({
            ...toToken.asStruct,
            tokenAmount: new bignumber_js_1.default(0)
        });
        return new simple_swap_ccr_trade_1.SimpleSwapCcrTrade({
            from: from,
            to: to,
            fromCurrency,
            toCurrency,
            feeInfo,
            priceImpact: null,
            gasData: null
        }, providerAddress, [], false);
    }
    async getSimpleSwapCurrencies(fromToken, toToken) {
        const { result: currencies } = await simple_swap_api_service_1.SimpleSwapApiService.getAllCurrencies();
        return {
            fromCurrency: this.getCurrency(currencies, fromToken),
            toCurrency: this.getCurrency(currencies, toToken)
        };
    }
    getCurrency(currencies, token) {
        const apiChain = simple_swap_ccr_api_blockchain_1.simpleSwapApiChain[token.blockchain];
        return currencies.find(currency => currency.network === apiChain &&
            ((currency.contractAddress &&
                (0, blockchain_1.compareAddresses)(currency.contractAddress, token.address)) ||
                (token.isNative && this.isNativeCurrency(currency, token))));
    }
    isNativeCurrency(currency, token) {
        const nativeTokenTicker = simple_swap_native_tokens_1.simpleSwapNativeTokenTickers[token.blockchain];
        return (!currency.contractAddress &&
            !!nativeTokenTicker &&
            currency.ticker === nativeTokenTicker);
    }
    async checkMinMaxErrors(fromToken, toBlockchain, fromCurrency, toCurrency) {
        const fromBlockchain = fromToken.blockchain;
        const { min, max } = await simple_swap_api_service_1.SimpleSwapApiService.getRanges({
            fixed: false,
            tickerFrom: fromCurrency,
            tickerTo: toCurrency,
            networkFrom: simple_swap_ccr_api_blockchain_1.simpleSwapApiChain[fromBlockchain],
            networkTo: simple_swap_ccr_api_blockchain_1.simpleSwapApiChain[toBlockchain]
        });
        const minAmount = new bignumber_js_1.default(min);
        if (fromToken.tokenAmount.lt(minAmount)) {
            return new errors_1.MinAmountError(minAmount, fromToken.symbol);
        }
        if (max) {
            const maxAmount = new bignumber_js_1.default(max);
            if (fromToken.tokenAmount.gt(maxAmount)) {
                return new errors_1.MaxAmountError(maxAmount, fromToken.symbol);
            }
        }
        return null;
    }
    async getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy) {
        return proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy);
    }
}
exports.SimpleSwapCcrProvider = SimpleSwapCcrProvider;
//# sourceMappingURL=simple-swap-ccr-provider.js.map