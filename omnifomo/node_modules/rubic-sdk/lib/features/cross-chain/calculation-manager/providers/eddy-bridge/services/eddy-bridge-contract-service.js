"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EddyBridgeContractService = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tokens_1 = require("../../../../../../common/tokens");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../core/injector/injector");
const eddy_bridge_contract_addresses_1 = require("../constants/eddy-bridge-contract-addresses");
const edyy_bridge_abi_1 = require("../constants/edyy-bridge-abi");
const zrc_20_token_abi_1 = require("../constants/zrc-20-token-abi");
const find_transit_token_address_1 = require("../utils/find-transit-token-address");
class EddyBridgeContractService {
    static async getPlatformFee() {
        try {
            const web3Public = injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN);
            const res = await web3Public.callContractMethod(eddy_bridge_contract_addresses_1.EDDY_OMNI_CONTRACT_IN_ZETACHAIN, edyy_bridge_abi_1.EDDY_BRIDGE_ABI, 'platformFee', []);
            // eddy currently takes 1% from bridged amount (platformFee = 10, ratioToAmount in than case = 0.99)
            return res / 1000;
        }
        catch (err) {
            return 0;
        }
    }
    /**
     * Eddy takes gasFee in source chain native currency
     * @param toToken target chain token
     */
    static async getGasFeeInDestChain(fromToken, toToken) {
        try {
            if (fromToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN) {
                return new bignumber_js_1.default(0);
            }
            const web3Public = injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN);
            const res = await web3Public.callContractMethod((0, find_transit_token_address_1.findCompatibleZrc20TokenAddress)(toToken), zrc_20_token_abi_1.ZRC_20_ABI, 'withdrawGasFee', []);
            const { zrc20GasFeeTokenAddress, zrc20WeiAmount } = res;
            const zrc20TokenWithPrice = await tokens_1.PriceToken.createToken({
                address: zrc20GasFeeTokenAddress,
                blockchain: blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN
            });
            const gasFeeUsdt = web3_pure_1.Web3Pure.fromWei(zrc20WeiAmount || 0, zrc20TokenWithPrice.decimals).multipliedBy(zrc20TokenWithPrice.price);
            const gasFeeInSrcTokenEquivalent = gasFeeUsdt.dividedBy(fromToken.price);
            return gasFeeInSrcTokenEquivalent;
        }
        catch (err) {
            throw err;
        }
    }
    /**
     * @returns eddy static slippage
     */
    static async getEddySlipage() {
        try {
            const web3Public = injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN);
            const res = await web3Public.callContractMethod(eddy_bridge_contract_addresses_1.EDDY_OMNI_CONTRACT_IN_ZETACHAIN, edyy_bridge_abi_1.EDDY_BRIDGE_ABI, 'slippage', []);
            // if res equals to 10 then 10 / 1000 = 1%
            return res / 1000;
        }
        catch (err) {
            return 0.02;
        }
    }
}
exports.EddyBridgeContractService = EddyBridgeContractService;
//# sourceMappingURL=eddy-bridge-contract-service.js.map