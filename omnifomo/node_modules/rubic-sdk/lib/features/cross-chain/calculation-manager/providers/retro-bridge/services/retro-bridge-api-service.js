"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetroBridgeApiService = void 0;
const tx_status_1 = require("../../../../../../core/blockchain/web3-public-service/web3-public/models/tx-status");
const injector_1 = require("../../../../../../core/injector/injector");
const retro_bridge_tx_status_1 = require("../models/retro-bridge-tx-status");
class RetroBridgeApiService {
    static async getTokenLimits(fromBlockchain, toBlockchain, fromToken, toToken) {
        const { data } = await injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/bridge/limits`, {
            params: {
                source_chain: fromBlockchain,
                destination_chain: toBlockchain,
                asset_from: fromToken,
                asset_to: toToken
            }
        });
        return data;
    }
    static async getQuote(params) {
        const { data } = await injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/bridge/quote`, {
            params: {
                ...params
            }
        });
        return data;
    }
    static async getMessageToAuthWallet() {
        const { data } = await injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/wallet_auth/message`);
        return data.message.value;
    }
    static async sendSignedMessage(walletAddress, signature, networkType) {
        try {
            await injector_1.Injector.httpClient.post(`${this.RETRO_BRIDGE_API_ENDPOINT}/wallet_auth/message`, {
                wallet_address: walletAddress,
                network_type: networkType,
                signature
            }, {
                withCredentials: true
            });
        }
        catch (err) {
            console.error(err);
        }
    }
    static async checkWallet(walletAddress, networkType) {
        const { message } = await injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/wallet_auth/wallet/${walletAddress}`, {
            headers: {
                'network-type': networkType
            },
            withCredentials: true
        });
        return message;
    }
    static async createTransaction(params, networkType) {
        const { data } = await injector_1.Injector.httpClient.post(`${this.RETRO_BRIDGE_API_ENDPOINT}/bridge/execute`, params, {
            headers: {
                'network-type': networkType,
                'api-key': this.API_KEY
            },
            withCredentials: true
        });
        return data;
    }
    static async getTxStatus(transactionId) {
        const { data } = await injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/bridge/${transactionId}/info`);
        const txStatus = data.status.toLowerCase();
        if (txStatus === retro_bridge_tx_status_1.RETRO_BRIDGE_TX_STATUS.COMPLETED) {
            return {
                hash: data.destination_tx_hash,
                status: tx_status_1.TX_STATUS.SUCCESS
            };
        }
        if (txStatus === retro_bridge_tx_status_1.RETRO_BRIDGE_TX_STATUS.SEND_FAILED ||
            txStatus === retro_bridge_tx_status_1.RETRO_BRIDGE_TX_STATUS.REJECTED) {
            return {
                hash: data.source_tx_hash,
                status: tx_status_1.TX_STATUS.FAIL
            };
        }
        return {
            hash: null,
            status: tx_status_1.TX_STATUS.PENDING
        };
    }
    static getTokenList(srcChain, dstChain) {
        return injector_1.Injector.httpClient.get(`${this.RETRO_BRIDGE_API_ENDPOINT}/assets/?source_chain=${srcChain}&destination_chain=${dstChain}`, {
            headers: {
                'api-key': this.API_KEY
            }
        });
    }
}
exports.RetroBridgeApiService = RetroBridgeApiService;
RetroBridgeApiService.RETRO_BRIDGE_API_ENDPOINT = 'https://backend.retrobridge.io/api';
RetroBridgeApiService.API_KEY = 'rubic';
//# sourceMappingURL=retro-bridge-api-service.js.map