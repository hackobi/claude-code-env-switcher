"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniZenCcrProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../common/errors");
const tokens_1 = require("../../../../../common/tokens");
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const blockchain_id_1 = require("../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const web3_pure_1 = require("../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../core/injector/injector");
const fake_wallet_address_1 = require("../../../../common/constants/fake-wallet-address");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const on_chain_trade_type_1 = require("../../../../on-chain/calculation-manager/providers/common/models/on-chain-trade-type");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const cross_chain_provider_1 = require("../common/cross-chain-provider");
const proxy_cross_chain_evm_trade_1 = require("../common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const unizen_ccr_supported_chains_1 = require("./constants/unizen-ccr-supported-chains");
const unizen_contract_addresses_1 = require("./constants/unizen-contract-addresses");
const unizen_trade_providers_1 = require("./constants/unizen-trade-providers");
const unizen_ccr_utils_service_1 = require("./services/unizen-ccr-utils-service");
const unizen_ccr_trade_1 = require("./unizen-ccr-trade");
class UniZenCcrProvider extends cross_chain_provider_1.CrossChainProvider {
    constructor() {
        super(...arguments);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.UNIZEN;
    }
    isSupportedBlockchain(blockchain) {
        return unizen_ccr_supported_chains_1.uniZenCcrSupportedChains.some(supportedBlockchain => supportedBlockchain === blockchain);
    }
    async calculate(from, toToken, options) {
        const useProxy = options?.useProxy?.[this.type] ?? true;
        const fromBlockchain = from.blockchain;
        const toBlockchain = toToken.blockchain;
        try {
            const feeInfo = await this.getFeeInfo(fromBlockchain, options.providerAddress, from, useProxy);
            const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(from, feeInfo.rubicProxy?.platformFee?.percent);
            const walletAddress = injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(fromBlockchain).address;
            const fromAddress = walletAddress || fake_wallet_address_1.FAKE_WALLET_ADDRESS;
            const srcChainId = blockchain_id_1.blockchainId[fromBlockchain];
            const quoteSendParams = {
                fromTokenAddress: from.address,
                toTokenAddress: toToken.address,
                amount: fromWithoutFee.stringWeiAmount,
                slippage: options.slippageTolerance,
                sender: fromAddress,
                destinationChainId: blockchain_id_1.blockchainId[toBlockchain]
            };
            const quoteInfo = await unizen_ccr_utils_service_1.UniZenCcrUtilsService.getBestQuote(quoteSendParams, srcChainId);
            const nativeToken = native_tokens_1.nativeTokensList[fromBlockchain];
            const cryptoFeeToken = await tokens_1.PriceTokenAmount.createFromToken({
                ...nativeToken,
                weiAmount: new bignumber_js_1.default(quoteInfo.nativeFee ?? 0)
            });
            const contractVersion = quoteInfo.contractVersion.toLowerCase();
            const contractAddress = unizen_contract_addresses_1.uniZenContractAddresses[contractVersion]?.[fromBlockchain];
            if (!contractAddress) {
                throw new errors_1.RubicSdkError(`There is no contract of ${quoteInfo.contractVersion} version`);
            }
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: new bignumber_js_1.default(quoteInfo.transactionData.params.actualQuote)
            });
            const toTokenAmountMin = web3_pure_1.Web3Pure.fromWei(quoteInfo.transactionData.params.minQuote, to.decimals);
            const routePath = await this.getRoutePath(from, to, quoteInfo.tradeProtocol, quoteInfo.srcTrade, quoteInfo.dstTrade);
            const trade = new unizen_ccr_trade_1.UniZenCcrTrade({
                from,
                feeInfo: {
                    ...feeInfo,
                    ...(quoteInfo.nativeFee && {
                        provider: {
                            cryptoFee: {
                                amount: web3_pure_1.Web3Pure.fromWei(quoteInfo.nativeFee, nativeToken.decimals),
                                token: cryptoFeeToken
                            }
                        }
                    })
                },
                to,
                slippage: options.slippageTolerance,
                priceImpact: from.calculatePriceImpactPercent(to),
                gasData: await this.getGasData(from),
                contractAddress,
                toTokenAmountMin
            }, options.providerAddress, routePath, useProxy);
            return {
                trade,
                tradeType: this.type
            };
        }
        catch (error) {
            return {
                error,
                trade: null,
                tradeType: this.type
            };
        }
    }
    async getRoutePath(from, to, tradeProtocol, srcTrade, dstTrade) {
        const isSrcTrade = !!srcTrade.tokenTo;
        const isDstTrade = !!dstTrade.tokenFrom;
        const path = [];
        const fromTransitToken = isSrcTrade
            ? await tokens_1.TokenAmount.createToken({
                address: srcTrade.tokenTo.contractAddress,
                weiAmount: new bignumber_js_1.default(srcTrade.toTokenAmount),
                blockchain: from.blockchain
            })
            : from;
        const toTransitToken = isDstTrade
            ? await tokens_1.TokenAmount.createToken({
                address: dstTrade.tokenFrom.contractAddress,
                weiAmount: new bignumber_js_1.default(dstTrade.fromTokenAmount),
                blockchain: to.blockchain
            })
            : to;
        if (isSrcTrade) {
            const protocol = srcTrade.protocol[0]?.name;
            const subProvider = unizen_trade_providers_1.uniZenCcrTradeDexes[protocol] || on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.UNIZEN;
            path.push({
                type: 'on-chain',
                path: [from, fromTransitToken],
                provider: subProvider
            });
        }
        const uniZenBridge = unizen_trade_providers_1.uniZenCcrTradeProviders[tradeProtocol] || cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.UNIZEN;
        path.push({
            type: 'cross-chain',
            path: [fromTransitToken, toTransitToken],
            provider: uniZenBridge
        });
        if (isDstTrade) {
            const protocol = dstTrade.protocol[0]?.name;
            const subProvider = unizen_trade_providers_1.uniZenCcrTradeDexes[protocol] || on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.UNIZEN;
            path.push({
                type: 'on-chain',
                path: [toTransitToken, to],
                provider: subProvider
            });
        }
        return path;
    }
    async getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy) {
        return proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy);
    }
}
exports.UniZenCcrProvider = UniZenCcrProvider;
//# sourceMappingURL=unizen-ccr-provider.js.map