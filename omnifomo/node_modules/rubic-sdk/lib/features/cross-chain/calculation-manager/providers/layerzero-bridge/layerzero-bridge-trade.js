"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayerZeroBridgeTrade = void 0;
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const evm_web3_pure_1 = require("../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const evm_cross_chain_trade_1 = require("../common/evm-cross-chain-trade/evm-cross-chain-trade");
const bridge_type_1 = require("../common/models/bridge-type");
const algb_token_addresses_1 = require("./constants/algb-token-addresses");
const layerzero_bridge_address_1 = require("./constants/layerzero-bridge-address");
const layzerzero_chain_ids_1 = require("./constants/layzerzero-chain-ids");
const layerzero_oft_abi_1 = require("./models/layerzero-oft-abi");
const estimate_fee_1 = require("./utils/estimate-fee");
class LayerZeroBridgeTrade extends evm_cross_chain_trade_1.EvmCrossChainTrade {
    get fromContractAddress() {
        return layerzero_bridge_address_1.layerZeroProxyOFT[this.from.blockchain];
    }
    get methodName() {
        return 'sendFrom';
    }
    constructor(crossChainTrade, providerAddress, routePath, useProxy) {
        super(providerAddress, routePath, useProxy);
        this.onChainSubtype = { from: undefined, to: undefined };
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.LAYERZERO;
        this.isAggregator = false;
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.LAYERZERO;
        this.feeInfo = {};
        this.onChainTrade = null;
        this.from = crossChainTrade.from;
        this.to = crossChainTrade.to;
        this.gasData = crossChainTrade.gasData;
        this.toTokenAmountMin = crossChainTrade.to.tokenAmount;
    }
    async swapDirect(options = {}) {
        await this.checkTradeErrors();
        await this.checkAllowanceAndApprove(options);
        const { onConfirm, gasPriceOptions } = options;
        let transactionHash;
        const onTransactionHash = (hash) => {
            if (onConfirm) {
                onConfirm(hash);
            }
            transactionHash = hash;
        };
        // eslint-disable-next-line no-useless-catch
        try {
            const { data, value, to } = await this.setTransactionConfig(false, options?.useCacheData || false, options.receiverAddress);
            const tx = await this.web3Private.trySendTransaction(to, {
                data,
                value,
                gasPriceOptions
            });
            onTransactionHash(tx.transactionHash);
            return transactionHash;
        }
        catch (err) {
            throw err;
        }
    }
    async getContractParams(options) {
        const account = this.web3Private.address;
        const fee = await (0, estimate_fee_1.estimateSendFeeLZ)(this.from, this.to, options.receiverAddress);
        const methodArguments = [
            account,
            layzerzero_chain_ids_1.layerZeroChainIds[this.to.blockchain],
            options.receiverAddress || account,
            this.from.stringWeiAmount,
            options.receiverAddress || account,
            '0x0000000000000000000000000000000000000000',
            '0x'
        ];
        return {
            contractAddress: this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.POLYGON
                ? layerzero_bridge_address_1.layerZeroProxyOFT[blockchain_name_1.BLOCKCHAIN_NAME.POLYGON]
                : algb_token_addresses_1.ALGB_TOKEN[this.from.blockchain],
            contractAbi: layerzero_oft_abi_1.layerZeroOFTABI,
            methodName: this.methodName,
            methodArguments,
            value: fee || '0x'
        };
    }
    async getTransactionConfigAndAmount(receiverAddress) {
        const params = await this.getContractParams({ receiverAddress });
        const config = evm_web3_pure_1.EvmWeb3Pure.encodeMethodCall(params.contractAddress, params.contractAbi, params.methodName, params.methodArguments, params.value);
        return { config, amount: this.to.stringWeiAmount };
    }
    getTradeAmountRatio(fromUsd) {
        return fromUsd.dividedBy(this.to.tokenAmount);
    }
    getTradeInfo() {
        return {
            estimatedGas: this.estimatedGas,
            feeInfo: this.feeInfo,
            priceImpact: null,
            slippage: 0,
            routePath: this.routePath
        };
    }
}
exports.LayerZeroBridgeTrade = LayerZeroBridgeTrade;
//# sourceMappingURL=layerzero-bridge-trade.js.map