"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterCrossChainProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../common/errors");
const tokens_1 = require("../../../../../common/tokens");
const web3_pure_1 = require("../../../../../core/blockchain/web3-pure/web3-pure");
const router_api_service_1 = require("../../../../common/providers/router/services/router-api-service");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const router_cross_chain_factory_1 = require("./router-cross-chain-factory");
const router_cross_chain_util_service_1 = require("./utils/router-cross-chain-util-service");
const on_chain_trade_type_1 = require("../../../../on-chain/calculation-manager/providers/common/models/on-chain-trade-type");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const cross_chain_provider_1 = require("../common/cross-chain-provider");
const proxy_cross_chain_evm_trade_1 = require("../common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const router_cross_chain_supported_chains_1 = require("./constants/router-cross-chain-supported-chains");
class RouterCrossChainProvider extends cross_chain_provider_1.CrossChainProvider {
    constructor() {
        super(...arguments);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.ROUTER;
    }
    isSupportedBlockchain(fromBlockchain) {
        return router_cross_chain_supported_chains_1.routerCrossChainSupportedChains.some(chain => chain === fromBlockchain);
    }
    async calculate(from, toToken, options) {
        const fromBlockchain = from.blockchain;
        const toBlockchain = toToken.blockchain;
        if (!this.areSupportedBlockchains(from.blockchain, toToken.blockchain)) {
            return {
                trade: null,
                error: new errors_1.NotSupportedTokensError(),
                tradeType: this.type
            };
        }
        const useProxy = options?.useProxy?.[this.type] ?? true;
        try {
            // if (toBlockchain === BLOCKCHAIN_NAME.SOLANA && options.receiverAddress) {
            //     await RouterCrossChainUtilService.checkAtaAddress(
            //         options.receiverAddress,
            //         toToken.address
            //     );
            // }
            const srcChainId = router_cross_chain_util_service_1.RouterCrossChainUtilService.getBlockchainId(fromBlockchain);
            const dstChainId = router_cross_chain_util_service_1.RouterCrossChainUtilService.getBlockchainId(toBlockchain);
            const feeInfo = await this.getFeeInfo(from.blockchain, options.providerAddress, from, useProxy);
            const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(from, feeInfo?.rubicProxy?.platformFee?.percent);
            const [fromTokenAddress, toTokenAddress] = await router_cross_chain_util_service_1.RouterCrossChainUtilService.getTokensAddress(from, toToken);
            const routerQuoteConfig = await router_api_service_1.RouterApiService.getQuote({
                amount: fromWithoutFee.stringWeiAmount,
                fromTokenAddress,
                fromTokenChainId: srcChainId,
                toTokenAddress,
                toTokenChainId: dstChainId,
                slippageTolerance: options.slippageTolerance * 100
            });
            const dstTokenAmount = new bignumber_js_1.default(routerQuoteConfig.destination.tokenAmount);
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: web3_pure_1.Web3Pure.fromWei(dstTokenAmount, routerQuoteConfig.destination.asset.decimals)
            });
            const routePath = await this.getRoutePath(from, to, routerQuoteConfig);
            return {
                trade: router_cross_chain_factory_1.RouterCrossChainFactory.createTrade(fromBlockchain, {
                    crossChainTrade: {
                        from,
                        to,
                        feeInfo,
                        gasData: await this.getGasData(from),
                        priceImpact: from.calculatePriceImpactPercent(to),
                        routerQuoteConfig,
                        slippage: options.slippageTolerance
                    },
                    providerAddress: options.providerAddress,
                    routePath,
                    useProxy
                }),
                tradeType: this.type
            };
        }
        catch (err) {
            return {
                trade: null,
                error: err,
                tradeType: this.type
            };
        }
    }
    async getRoutePath(fromToken, toToken, routerQuoteConfig) {
        const routerSrcAsset = routerQuoteConfig.source;
        const routerDstAsset = routerQuoteConfig.destination;
        if (routerSrcAsset.path.length === 0 && routerDstAsset.path.length === 0) {
            return [
                {
                    type: 'cross-chain',
                    provider: this.type,
                    path: [fromToken, toToken]
                }
            ];
        }
        const transitFromAddress = fromToken.address.toLowerCase() !==
            routerSrcAsset.stableReserveAsset.address.toLowerCase()
            ? routerSrcAsset.stableReserveAsset.address
            : null;
        const transitToAddress = toToken.address.toLowerCase() !==
            routerDstAsset.stableReserveAsset.address.toLowerCase()
            ? routerDstAsset.stableReserveAsset.address
            : null;
        const fromTransitToken = transitFromAddress
            ? await tokens_1.TokenAmount.createToken({
                blockchain: fromToken.blockchain,
                address: transitFromAddress,
                weiAmount: new bignumber_js_1.default(routerSrcAsset.stableReserveAmount)
            })
            : fromToken;
        const toTransitToken = transitToAddress
            ? await tokens_1.TokenAmount.createToken({
                blockchain: toToken.blockchain,
                address: transitToAddress,
                weiAmount: new bignumber_js_1.default(routerDstAsset.stableReserveAmount)
            })
            : toToken;
        const routePath = [];
        if (transitFromAddress) {
            routePath.push({
                type: 'on-chain',
                provider: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.ROUTER_SWAP,
                path: [fromToken, fromTransitToken]
            });
        }
        routePath.push({
            type: 'cross-chain',
            provider: cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.ROUTER,
            path: [fromTransitToken, toTransitToken]
        });
        if (transitToAddress) {
            routePath.push({
                type: 'on-chain',
                provider: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.ROUTER_SWAP,
                path: [toTransitToken, toToken]
            });
        }
        return routePath;
    }
    async getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy) {
        return proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy);
    }
}
exports.RouterCrossChainProvider = RouterCrossChainProvider;
//# sourceMappingURL=router-cross-chain-provider.js.map