"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaikoBridgeTrade = void 0;
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const blockchain_id_1 = require("../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const evm_web3_pure_1 = require("../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const evm_cross_chain_trade_1 = require("../common/evm-cross-chain-trade/evm-cross-chain-trade");
const bridge_type_1 = require("../common/models/bridge-type");
const taiko_gateway_abi_1 = require("./constants/taiko-gateway-abi");
const taiko_bridge_contract_address_1 = require("./constants/taiko-bridge-contract-address");
class TaikoBridgeTrade extends evm_cross_chain_trade_1.EvmCrossChainTrade {
    get fromBlockchain() {
        return this.from.blockchain;
    }
    get fromContractAddress() {
        return this.from.isNative
            ? taiko_bridge_contract_address_1.taikoBridgeContractAddress[this.fromBlockchain].nativeProvider
            : taiko_bridge_contract_address_1.taikoBridgeContractAddress[this.fromBlockchain].erc20Provider;
    }
    get methodName() {
        return this.onChainTrade
            ? 'swapAndStartBridgeTokensViaGenericCrossChain'
            : 'startBridgeTokensViaGenericCrossChain';
    }
    constructor(crossChainTrade, providerAddress, routePath, useProxy) {
        super(providerAddress, routePath, useProxy);
        this.onChainSubtype = { from: undefined, to: undefined };
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.TAIKO_BRIDGE;
        this.isAggregator = false;
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.TAIKO_BRIDGE;
        this.feeInfo = {};
        this.onChainTrade = null;
        this.from = crossChainTrade.from;
        this.to = crossChainTrade.to;
        this.gasData = crossChainTrade.gasData;
        this.toTokenAmountMin = crossChainTrade.to.tokenAmount;
    }
    async getContractParams() {
        throw new Error('Method is not supported');
    }
    getTradeAmountRatio(fromUsd) {
        return fromUsd.dividedBy(this.to.tokenAmount);
    }
    getTradeInfo() {
        return {
            estimatedGas: this.estimatedGas,
            feeInfo: this.feeInfo,
            priceImpact: null,
            slippage: 0,
            routePath: this.routePath
        };
    }
    async getTransactionConfigAndAmount(_receiverAddress) {
        let methodArguments;
        let fee;
        const account = this.web3Private.address;
        if (this.fromBlockchain === blockchain_name_1.BLOCKCHAIN_NAME.HOLESKY) {
            if (this.from.isNative) {
                methodArguments = [
                    {
                        id: 0,
                        from: account,
                        srcChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.HOLESKY],
                        destChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.TAIKO],
                        owner: account,
                        to: account,
                        refundTo: account,
                        value: this.from.stringWeiAmount,
                        fee: '9000000',
                        gasLimit: '140000',
                        data: '0x',
                        memo: ''
                    }
                ];
                fee = '9000000';
            }
            else {
                methodArguments = [
                    {
                        destChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.TAIKO],
                        to: account,
                        token: this.from.address,
                        amount: this.from.stringWeiAmount,
                        gasLimit: '140000',
                        fee: '11459820715200000',
                        refundTo: account,
                        memo: ''
                    }
                ];
                fee = '11459820715200000';
            }
        }
        else {
            if (this.from.isNative) {
                methodArguments = [
                    {
                        id: 0,
                        from: account,
                        srcChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.TAIKO],
                        destChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.HOLESKY],
                        owner: account,
                        to: account,
                        refundTo: account,
                        value: this.from.stringWeiAmount,
                        fee: '34774829357400000',
                        gasLimit: '140000',
                        data: '0x',
                        memo: ''
                    }
                ];
                fee = '34774829357400000';
            }
            else {
                methodArguments = [
                    {
                        destChainId: blockchain_id_1.blockchainId[blockchain_name_1.BLOCKCHAIN_NAME.HOLESKY],
                        to: account,
                        token: this.from.address,
                        amount: this.from.stringWeiAmount,
                        gasLimit: '140000',
                        fee: '88242155100000',
                        refundTo: account,
                        memo: ''
                    }
                ];
                fee = '88242155100000';
            }
        }
        const config = evm_web3_pure_1.EvmWeb3Pure.encodeMethodCall(this.from.isNative
            ? taiko_bridge_contract_address_1.taikoBridgeContractAddress[this.fromBlockchain].nativeProvider
            : taiko_bridge_contract_address_1.taikoBridgeContractAddress[this.fromBlockchain].erc20Provider, this.from.isNative ? taiko_gateway_abi_1.taikoNativeBridgeABI : taiko_gateway_abi_1.taikoERC20BridgeABI, this.from.isNative ? 'sendMessage' : 'sendToken', methodArguments, this.from.isNative ? this.from.weiAmount.plus(fee).toFixed() : fee);
        return { config, amount: this.to.stringWeiAmount };
    }
}
exports.TaikoBridgeTrade = TaikoBridgeTrade;
//# sourceMappingURL=taiko-bridge-trade.js.map