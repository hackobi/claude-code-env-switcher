"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeleSwapCcrProvider = void 0;
const errors_1 = require("../../../../../common/errors");
const tokens_1 = require("../../../../../common/tokens");
const blockchain_1 = require("../../../../../common/utils/blockchain");
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const blockchains_info_1 = require("../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const injector_1 = require("../../../../../core/injector/injector");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const cross_chain_provider_1 = require("../common/cross-chain-provider");
const proxy_cross_chain_evm_trade_1 = require("../common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const teleswap_ccr_supported_chains_1 = require("./constants/teleswap-ccr-supported-chains");
const teleswap_utils_service_1 = require("./services/teleswap-utils-service");
const teleswap_ccr_factory_1 = require("./teleswap-ccr-factory");
const ONE_PERCENT_FEE_ADDR = '0xC095e57dDfa5924BC56bEAcf1D515F154ac44e94';
const ZERO_PERCENT_FEE_ADDR = '0x51c276f1392E87D4De6203BdD80c83f5F62724d4';
class TeleSwapCcrProvider extends cross_chain_provider_1.CrossChainProvider {
    constructor() {
        super(...arguments);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.TELE_SWAP;
    }
    isSupportedBlockchain(blockchain) {
        return teleswap_ccr_supported_chains_1.teleSwapCcrSupportedChains.some(supportedBlockchain => supportedBlockchain === blockchain);
    }
    async calculate(from, toToken, options) {
        try {
            const isSameChainTypes = blockchains_info_1.BlockchainsInfo.getChainType(from.blockchain) ===
                blockchains_info_1.BlockchainsInfo.getChainType(toToken.blockchain);
            if ((from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN && toToken.isWrapped) ||
                isSameChainTypes) {
                throw new errors_1.NotSupportedTokensError();
            }
            const useProxy = options?.useProxy?.[this.type] ?? true;
            const percentFeeAddress = (0, blockchain_1.compareAddresses)(options.providerAddress, ZERO_PERCENT_FEE_ADDR)
                ? ZERO_PERCENT_FEE_ADDR
                : ONE_PERCENT_FEE_ADDR;
            const feeInfo = await this.getFeeInfo(from.blockchain, percentFeeAddress, from, useProxy);
            const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(from, feeInfo.rubicProxy?.platformFee?.percent);
            const teleSwapSdk = injector_1.Injector.teleSwapSdkInstance;
            const toWeiAmount = await teleswap_utils_service_1.TeleSwapUtilsService.calculateOutputWeiAmount(fromWithoutFee, toToken, teleSwapSdk);
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                weiAmount: toWeiAmount
            });
            const routePath = await this.getRoutePath(from, to);
            const trade = teleswap_ccr_factory_1.TeleSwapCcrFactory.createTrade(from.blockchain, {
                crossChainTrade: {
                    from,
                    to,
                    teleSwapSdk,
                    feeInfo,
                    gasData: null,
                    priceImpact: from.calculatePriceImpactPercent(to),
                    slippage: options.slippageTolerance
                },
                providerAddress: percentFeeAddress,
                useProxy,
                routePath
            });
            return {
                trade,
                tradeType: this.type
            };
        }
        catch (err) {
            return {
                trade: null,
                tradeType: this.type,
                error: err
            };
        }
    }
    async getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy) {
        return proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy);
    }
    async getRoutePath(from, to) {
        return [
            {
                type: 'cross-chain',
                provider: cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.TELE_SWAP,
                path: [from, to]
            }
        ];
    }
}
exports.TeleSwapCcrProvider = TeleSwapCcrProvider;
//# sourceMappingURL=teleswap-ccr-provider.js.map