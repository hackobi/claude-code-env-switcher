"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbiosisTronCcrTrade = void 0;
const symbiosis_api_service_1 = require("../../../../../common/providers/symbiosis/services/symbiosis-api-service");
const cross_chain_trade_type_1 = require("../../../models/cross-chain-trade-type");
const bridge_type_1 = require("../../common/models/bridge-type");
const tron_cross_chain_trade_1 = require("../../common/tron-cross-chain-trade/tron-cross-chain-trade");
const symbiosis_utils_1 = require("../symbiosis-utils");
/**
 * Calculated Symbiosis cross-chain trade.
 */
class SymbiosisTronCcrTrade extends tron_cross_chain_trade_1.TronCrossChainTrade {
    get fromBlockchain() {
        return this.from.blockchain;
    }
    get fromContractAddress() {
        return this.contractAddresses.providerGateway;
    }
    get methodName() {
        throw new Error('Not implemented');
    }
    constructor(crossChainTrade, providerAddress, routePath, useProxy) {
        super(providerAddress, routePath, useProxy);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.SYMBIOSIS;
        this.isAggregator = false;
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.SYMBIOSIS;
        this.from = crossChainTrade.from;
        this.to = crossChainTrade.to;
        this.swappingParams = crossChainTrade.swapParams;
        this.gasData = crossChainTrade.gasData;
        this.priceImpact = crossChainTrade.priceImpact;
        this.toTokenAmountMin = this.to.tokenAmount.multipliedBy(1 - crossChainTrade.slippage);
        this.feeInfo = crossChainTrade.feeInfo;
        this.slippage = crossChainTrade.slippage;
        this.transitAmount = crossChainTrade.transitAmount;
        this.onChainSubtype = symbiosis_utils_1.SymbiosisUtils.getSubtype(crossChainTrade.tradeType, crossChainTrade.to.blockchain);
        this.contractAddresses = crossChainTrade.contractAddresses;
        this.promotions = crossChainTrade?.promotions || [];
    }
    getTradeAmountRatio(fromUsd) {
        return fromUsd.dividedBy(this.to.tokenAmount);
    }
    getTradeInfo() {
        return {
            estimatedGas: null,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact ?? null,
            slippage: this.slippage * 100,
            routePath: this.routePath
        };
    }
    async getTransactionConfigAndAmount(receiverAddress) {
        const walletAddress = this.walletAddress;
        const params = {
            ...this.swappingParams,
            from: walletAddress,
            to: receiverAddress || walletAddress,
            revertableAddress: symbiosis_utils_1.SymbiosisUtils.getRevertableAddress(receiverAddress, walletAddress, this.to.blockchain)
        };
        const tradeData = await symbiosis_api_service_1.SymbiosisApiService.getCrossChainSwapTx(params);
        const tx = tradeData.tx;
        const amount = tradeData.tokenAmountOut.amount;
        const config = {
            signature: tx.functionSelector,
            arguments: [],
            to: tx.to,
            rawParameter: tx.data,
            callValue: tx.value,
            feeLimit: tx.feeLimit
        };
        return { amount, config };
    }
}
exports.SymbiosisTronCcrTrade = SymbiosisTronCcrTrade;
//# sourceMappingURL=symbiosis-ccr-tron-trade.js.map