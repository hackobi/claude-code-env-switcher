"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterCrossChainUtilService = void 0;
const native_tokens_1 = require("../../../../../../common/tokens/constants/native-tokens");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const injector_1 = require("../../../../../../core/injector/injector");
class RouterCrossChainUtilService {
    static get tronWeb3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.TRON);
    }
    static get solanaWeb3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.SOLANA);
    }
    static async checkAndConvertAddress(blockchain, address, _tokenAddress) {
        if (blockchain === blockchain_name_1.BLOCKCHAIN_NAME.TRON) {
            const tronHexAddress = await this.tronWeb3Public.convertTronAddressToHex(address);
            return `0x${tronHexAddress.slice(2)}`;
        }
        // if (blockchain === BLOCKCHAIN_NAME.SOLANA && tokenAddress) {
        //     const ataAddress = await this.solanaWeb3Public.getAtaAddress(address, tokenAddress);
        //     return ataAddress!;
        // }
        return address;
    }
    static async getTokensAddress(fromToken, toToken) {
        let fromNativeAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
        let toNativeAddress = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
        if (fromToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI) {
            fromNativeAddress = native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.SUI].address;
        }
        if (toToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI) {
            toNativeAddress = native_tokens_1.nativeTokensList[blockchain_name_1.BLOCKCHAIN_NAME.SUI].address;
        }
        const srcTokenAddress = fromToken.address;
        const dstTokenAddress = await RouterCrossChainUtilService.checkAndConvertAddress(toToken.blockchain, toToken.address);
        return [
            fromToken.isNative ? fromNativeAddress : srcTokenAddress,
            toToken.isNative ? toNativeAddress : dstTokenAddress
        ];
    }
    static getBlockchainId(blockchain) {
        if (blockchain === blockchain_name_1.BLOCKCHAIN_NAME.TRON) {
            return '728126428';
        }
        if (blockchain === blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN) {
            return 'bitcoin';
        }
        if (blockchain === blockchain_name_1.BLOCKCHAIN_NAME.SUI) {
            return 'sui';
        }
        // if (blockchain === BLOCKCHAIN_NAME.SOLANA) {
        //     return 'solana';
        // }
        return blockchain_id_1.blockchainId[blockchain].toString();
    }
}
exports.RouterCrossChainUtilService = RouterCrossChainUtilService;
//# sourceMappingURL=router-cross-chain-util-service.js.map