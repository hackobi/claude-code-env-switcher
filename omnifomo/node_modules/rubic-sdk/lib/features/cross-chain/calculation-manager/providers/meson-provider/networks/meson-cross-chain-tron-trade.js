"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MesonCrossChainTronTrade = void 0;
const ethers_1 = require("ethers");
const tron_web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/typed-web3-pure/tron-web3-pure/tron-web3-pure");
const get_from_without_fee_1 = require("../../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../../models/cross-chain-trade-type");
const rubic_proxy_contract_address_1 = require("../../common/constants/rubic-proxy-contract-address");
const bridge_type_1 = require("../../common/models/bridge-type");
const tron_cross_chain_trade_1 = require("../../common/tron-cross-chain-trade/tron-cross-chain-trade");
const meson_abi_1 = require("../constants/meson-abi");
const meson_contract_addresses_1 = require("../constants/meson-contract-addresses");
const meson_cross_chain_api_service_1 = require("../services/meson-cross-chain-api-service");
class MesonCrossChainTronTrade extends tron_cross_chain_trade_1.TronCrossChainTrade {
    get fromBlockchain() {
        return this.from.blockchain;
    }
    get fromContractAddress() {
        return meson_contract_addresses_1.mesonContractAddresses[this.fromBlockchain];
    }
    get methodName() {
        throw new Error('Not implemented');
    }
    constructor(params) {
        super(params.providerAddress, params.routePath, params.useProxy);
        /**ABSTRACT PROPS */
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.MESON;
        this.isAggregator = false;
        this.onChainSubtype = { from: undefined, to: undefined };
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.MESON;
        this.to = params.crossChainTrade.to;
        this.from = params.crossChainTrade.from;
        this.feeInfo = params.crossChainTrade.feeInfo;
        this.gasData = params.crossChainTrade.gasData;
        this.priceImpact = params.crossChainTrade.priceImpact;
        this.toTokenAmountMin = this.to.tokenAmount;
        this.sourceAssetString = params.crossChainTrade.sourceAssetString;
        this.targetAssetString = params.crossChainTrade.targetAssetString;
    }
    async getTransactionConfigAndAmount(receiverAddress) {
        const rubicMultiProxyAddress = rubic_proxy_contract_address_1.rubicProxyContractAddress[this.fromBlockchain].router;
        const fromAddress = this.isProxyTrade ? rubicMultiProxyAddress : this.walletAddress;
        const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(this.from, this.feeInfo.rubicProxy?.platformFee?.percent);
        const { encoded, initiator } = await meson_cross_chain_api_service_1.MesonCcrApiService.fetchInfoForTx({
            sourceAssetString: this.sourceAssetString,
            targetAssetString: this.targetAssetString,
            amount: fromWithoutFee.tokenAmount.toFixed(),
            fromAddress,
            receiverAddress: receiverAddress || this.walletAddress,
            useProxy: this.isProxyTrade
        });
        const postingValue = ethers_1.ethers.utils.solidityPack(['address', 'uint40'], [initiator, 1]);
        const methodName = 'postSwapFromContract';
        const methodArgs = [
            { type: 'uint256', value: encoded },
            { type: 'uint200', value: postingValue },
            { type: 'address', value: encoded }
        ];
        const value = this.from.isNative ? fromWithoutFee.stringWeiAmount : '0';
        const config = tron_web3_pure_1.TronWeb3Pure.encodeMethodCall(meson_contract_addresses_1.mesonContractAddresses[this.fromBlockchain], meson_abi_1.MESON_ABI, methodName, methodArgs, Number(value));
        return { config, amount: this.to.stringWeiAmount };
    }
    getTradeInfo() {
        return {
            estimatedGas: null,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact || null,
            slippage: 0,
            routePath: this.routePath
        };
    }
}
exports.MesonCrossChainTronTrade = MesonCrossChainTronTrade;
//# sourceMappingURL=meson-cross-chain-tron-trade.js.map