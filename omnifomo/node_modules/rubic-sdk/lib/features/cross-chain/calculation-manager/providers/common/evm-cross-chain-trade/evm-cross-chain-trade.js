"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmCrossChainTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const options_1 = require("../../../../../../common/utils/options");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const blockchains_info_1 = require("../../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const blockchain_id_1 = require("../../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const evm_web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/evm-web3-pure");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../core/injector/injector");
const cross_chain_trade_1 = require("../cross-chain-trade");
class EvmCrossChainTrade extends cross_chain_trade_1.CrossChainTrade {
    get fromWeb3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(this.from.blockchain);
    }
    get web3Private() {
        return injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(this.from.blockchain);
    }
    get gasLimitRatio() {
        if (this.to.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN ||
            this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ZETACHAIN) {
            return 1.5;
        }
        return 1.05;
    }
    /**
     * Gets gas fee in source blockchain.
     */
    get estimatedGas() {
        if (!this.gasData) {
            return null;
        }
        if (this.gasData.baseFee && this.gasData.maxPriorityFeePerGas) {
            return web3_pure_1.Web3Pure.fromWei(this.gasData.baseFee).plus(web3_pure_1.Web3Pure.fromWei(this.gasData.maxPriorityFeePerGas));
        }
        if (this.gasData.gasPrice) {
            return web3_pure_1.Web3Pure.fromWei(this.gasData.gasPrice).multipliedBy(this.gasData.gasLimit ?? 0);
        }
        return null;
    }
    async approve(options, checkNeedApprove = true, amount = 'infinity') {
        if (checkNeedApprove) {
            const needApprove = await this.needApprove();
            if (!needApprove) {
                throw new errors_1.UnnecessaryApproveError();
            }
        }
        this.checkWalletConnected();
        await this.checkBlockchainCorrect();
        const approveAmount = this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.GNOSIS ||
            this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.CRONOS
            ? this.from.weiAmount
            : amount;
        const fromTokenAddress = this.from.isNative && this.from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.METIS
            ? '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000'
            : this.from.address;
        return this.web3Private.approveTokens(fromTokenAddress, this.fromContractAddress, approveAmount, options);
    }
    async checkAllowanceAndApprove(options) {
        const needApprove = await this.needApprove();
        if (!needApprove) {
            return;
        }
        const approveOptions = {
            onTransactionHash: options?.onApprove,
            gas: options?.approveGasLimit,
            gasPriceOptions: options?.gasPriceOptions
        };
        await this.approve(approveOptions, false);
    }
    async swapDirect(options = {}) {
        await this.checkTradeErrors();
        await this.checkAllowanceAndApprove(options);
        const { onConfirm, gasPriceOptions } = options;
        let transactionHash;
        const onTransactionHash = (hash) => {
            if (onConfirm) {
                onConfirm(hash);
            }
            transactionHash = hash;
        };
        try {
            const config = await this.setTransactionConfig(false, options.useCacheData || false, options?.receiverAddress);
            if ('data' in config) {
                const { data, value, to } = config;
                await this.web3Private.trySendTransaction(to, {
                    data,
                    value,
                    onTransactionHash,
                    gasPriceOptions,
                    gasLimitRatio: this.gasLimitRatio
                });
                return transactionHash;
            }
            throw new Error('Invalid transaction config');
        }
        catch (err) {
            throw err;
        }
    }
    async getData(fromAddress, options = {}) {
        this.apiFromAddress = fromAddress;
        if (!options?.testMode) {
            await this.checkTradeErrors();
        }
        await this.checkReceiverAddress(options.receiverAddress, !blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(this.to.blockchain));
        const { data, value, to } = await this.encode({ ...options, fromAddress });
        try {
            if (!options?.testMode) {
                const gasfullOptions = await this.web3Private.simulateTransaction(to, {
                    data,
                    value
                }, this.from.blockchain);
                return gasfullOptions;
            }
            return { data, value, to };
        }
        catch (err) {
            throw err;
        }
    }
    /**
     *
     * @returns txHash(srcTxHash) | never
     */
    async swap(options = {}) {
        if (!options?.testMode) {
            await this.checkTradeErrors();
        }
        await this.checkReceiverAddress(options.receiverAddress, !blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(this.to.blockchain));
        const method = options?.testMode ? 'sendTransaction' : 'trySendTransaction';
        const fromAddress = this.walletAddress;
        const { data, value, to } = await this.encode({ ...options, fromAddress });
        const { onConfirm, gasPriceOptions } = options;
        let transactionHash;
        const onTransactionHash = (hash) => {
            if (onConfirm) {
                onConfirm(hash);
            }
            transactionHash = hash;
        };
        try {
            await this.web3Private[method](to, {
                data,
                value,
                onTransactionHash,
                gasPriceOptions,
                gasLimitRatio: this.gasLimitRatio,
                ...(options?.useEip155 && {
                    chainId: `0x${blockchain_id_1.blockchainId[this.from.blockchain].toString(16)}`
                })
            });
            return transactionHash;
        }
        catch (err) {
            if (err instanceof errors_1.FailedToCheckForTransactionReceiptError) {
                return transactionHash;
            }
            throw err;
        }
    }
    async encode(options) {
        await this.checkFromAddress(options.fromAddress, true);
        await this.checkReceiverAddress(options.receiverAddress, !blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(this.to.blockchain));
        if (this.isProxyTrade) {
            return this.encodeProxy(options);
        }
        return this.setTransactionConfig(options?.skipAmountCheck || false, options?.useCacheData || false, options?.receiverAddress || this.walletAddress, options?.refundAddress);
    }
    async encodeApprove(tokenAddress, spenderAddress, value, options = {}) {
        return this.web3Private.encodeApprove(tokenAddress, spenderAddress, value, options);
    }
    getUsdPrice(providerFeeToken) {
        let feeSum = new bignumber_js_1.default(0);
        const providerFee = this.feeInfo.provider?.cryptoFee;
        if (providerFee) {
            feeSum = feeSum.plus(providerFee.amount.multipliedBy(providerFeeToken || providerFee.token.price));
        }
        return this.to.price.multipliedBy(this.to.tokenAmount).minus(feeSum);
    }
    async encodeProxy(options) {
        const { contractAddress, contractAbi, methodName, methodArguments, value } = await this.getContractParams({
            fromAddress: options.fromAddress,
            receiverAddress: options.receiverAddress || options.fromAddress,
            useCacheData: options?.useCacheData || false
        });
        const gasLimit = options.gasLimit || this.gasData?.gasLimit?.toFixed(0) || '0';
        return evm_web3_pure_1.EvmWeb3Pure.encodeMethodCall(contractAddress, contractAbi, methodName, methodArguments, value, {
            gas: gasLimit,
            ...(0, options_1.getGasOptions)(options)
        });
    }
}
exports.EvmCrossChainTrade = EvmCrossChainTrade;
//# sourceMappingURL=evm-cross-chain-trade.js.map