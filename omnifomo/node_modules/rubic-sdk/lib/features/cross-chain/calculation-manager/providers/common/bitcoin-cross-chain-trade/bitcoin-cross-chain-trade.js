"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinCrossChainTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../../common/errors");
const errors_2 = require("../../../../../../common/utils/errors");
const blockchain_name_1 = require("../../../../../../core/blockchain/models/blockchain-name");
const injector_1 = require("../../../../../../core/injector/injector");
const cross_chain_trade_1 = require("../cross-chain-trade");
class BitcoinCrossChainTrade extends cross_chain_trade_1.CrossChainTrade {
    get fromWeb3Public() {
        return injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN);
    }
    get web3Private() {
        return injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN);
    }
    /**
     * Gets gas fee in source blockchain.
     */
    get estimatedGas() {
        return null;
    }
    async approve(_options, _checkNeedApprove = true, _amount = 'infinity') {
        throw new Error('Method is not supported');
    }
    async checkAllowanceAndApprove() { }
    /**
     *
     * @returns txHash(srcTxHash) | never
     */
    async swap(options = {}) {
        this.checkWalletConnected();
        let transactionHash;
        try {
            const { data, to, value } = await this.setTransactionConfig(false, options?.useCacheData || false, options?.receiverAddress);
            const { onConfirm } = options;
            const onTransactionHash = (hash) => {
                if (onConfirm) {
                    onConfirm(hash);
                }
                transactionHash = hash;
            };
            await this.web3Private.transfer(to, value, data, { onTransactionHash });
            return transactionHash;
        }
        catch (err) {
            if (err.message?.includes('User rejected the request') || err.code === 4001) {
                throw new errors_1.UserRejectError();
            }
            if (err?.error?.errorId === 'ERROR_LOW_GIVE_AMOUNT') {
                throw new errors_1.TooLowAmountError();
            }
            if (err instanceof errors_1.FailedToCheckForTransactionReceiptError) {
                return transactionHash;
            }
            throw (0, errors_2.parseError)(err);
        }
    }
    async encode() {
        throw new Error("Method is not supported');");
    }
    async encodeApprove(_tokenAddress, _spenderAddress, _value, _options = {}) {
        throw new Error('Method is not supported');
    }
    getContractParams() {
        throw new Error('Method is not supported');
    }
    getUsdPrice(providerFeeToken) {
        let feeSum = new bignumber_js_1.default(0);
        const providerFee = this.feeInfo.provider?.cryptoFee;
        if (providerFee) {
            feeSum = feeSum.plus(providerFee.amount.multipliedBy(providerFeeToken || providerFee.token.price));
        }
        return this.to.price.multipliedBy(this.to.tokenAmount).minus(feeSum);
    }
}
exports.BitcoinCrossChainTrade = BitcoinCrossChainTrade;
//# sourceMappingURL=bitcoin-cross-chain-trade.js.map