"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterBitcoinCrossChainTrade = void 0;
const errors_1 = require("../../../../../../common/errors");
const router_api_service_1 = require("../../../../../common/providers/router/services/router-api-service");
const bitcoin_cross_chain_trade_1 = require("../../common/bitcoin-cross-chain-trade/bitcoin-cross-chain-trade");
const router_cross_chain_util_service_1 = require("../utils/router-cross-chain-util-service");
const cross_chain_trade_type_1 = require("../../../models/cross-chain-trade-type");
const rubic_proxy_contract_address_1 = require("../../common/constants/rubic-proxy-contract-address");
const bridge_type_1 = require("../../common/models/bridge-type");
class RouterBitcoinCrossChainTrade extends bitcoin_cross_chain_trade_1.BitcoinCrossChainTrade {
    get fromBlockchain() {
        return this.from.blockchain;
    }
    get fromContractAddress() {
        return this.isProxyTrade
            ? rubic_proxy_contract_address_1.rubicProxyContractAddress[this.fromBlockchain].gateway
            : this.routerQuoteConfig.allowanceTo;
    }
    get methodName() {
        return 'startBridgeTokensViaGenericCrossChain';
    }
    constructor(params) {
        const { providerAddress, routePath, useProxy, crossChainTrade } = params;
        super(providerAddress, routePath, useProxy);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.ROUTER;
        this.onChainSubtype = { from: undefined, to: undefined };
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.ROUTER;
        this.isAggregator = false;
        this.memo = '';
        this.from = crossChainTrade.from;
        this.to = crossChainTrade.to;
        this.feeInfo = crossChainTrade.feeInfo;
        this.gasData = crossChainTrade.gasData;
        this.priceImpact = crossChainTrade.priceImpact;
        this.routerQuoteConfig = crossChainTrade.routerQuoteConfig;
        this.slippage = crossChainTrade.slippage;
        this.toTokenAmountMin = this.to.tokenAmount.multipliedBy(1 - this.slippage);
    }
    async getTransactionConfigAndAmount(receiverAddress) {
        const toBlockchain = this.to.blockchain;
        const toAddress = await router_cross_chain_util_service_1.RouterCrossChainUtilService.checkAndConvertAddress(toBlockchain, receiverAddress || this.walletAddress, this.to.address);
        const { txn, destination } = await router_api_service_1.RouterApiService.getSwapTx({
            ...this.routerQuoteConfig,
            senderAddress: this.walletAddress,
            receiverAddress: toAddress,
            refundAddress: this.walletAddress,
            isTransfer: true
        });
        if (!txn) {
            throw new errors_1.RubicSdkError();
        }
        const config = {
            // data: txn.data,
            value: this.from.stringWeiAmount,
            to: txn.to
        };
        return { config, amount: destination.tokenAmount };
    }
    getTradeInfo() {
        return {
            estimatedGas: this.estimatedGas,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact,
            slippage: this.slippage * 100,
            routePath: this.routePath
        };
    }
}
exports.RouterBitcoinCrossChainTrade = RouterBitcoinCrossChainTrade;
//# sourceMappingURL=router-bitcoin-cross-chain-trade.js.map