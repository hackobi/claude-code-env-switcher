"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangellyCcrTrade = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../../../../../common/errors");
const blockchains_info_1 = require("../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const rubic_proxy_contract_address_1 = require("../common/constants/rubic-proxy-contract-address");
const cross_chain_transfer_trade_1 = require("../common/cross-chain-transfer-trade/cross-chain-transfer-trade");
const bridge_type_1 = require("../common/models/bridge-type");
const changelly_api_service_1 = require("./services/changelly-api-service");
class ChangellyCcrTrade extends cross_chain_transfer_trade_1.CrossChainTransferTrade {
    /**
     * used in rubic-app to send as changelly_id to backend
     */
    get changellyId() {
        return this.paymentInfo ? this.paymentInfo.id : '';
    }
    get fromContractAddress() {
        if (this.isProxyTrade) {
            return rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway;
        }
        throw new errors_1.RubicSdkError('No contract address for changelly provider');
    }
    constructor(ccrTrade) {
        super({
            ...ccrTrade
        });
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.CHANGELLY;
        this.onChainSubtype = { from: undefined, to: undefined };
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.CHANGELLY;
        this.changellyTokens = ccrTrade.changellyTokens;
        this.rateId = ccrTrade.rateId;
    }
    async getPaymentInfo(receiverAddress, refundAddress) {
        const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(this.from, this.feeInfo.rubicProxy?.platformFee?.percent);
        const isFromEvm = blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(this.from.blockchain);
        const fromWithoutFeeTokenAmount = fromWithoutFee.tokenAmount.toFixed();
        let currRateId = this.rateId;
        if (!isFromEvm) {
            const quote = await this.getFixedRateQuote(fromWithoutFeeTokenAmount);
            currRateId = quote.id;
        }
        const refund = refundAddress || this.walletAddress;
        const exchangeParams = {
            from: this.changellyTokens.fromToken.ticker,
            to: this.changellyTokens.toToken.ticker,
            amountFrom: fromWithoutFeeTokenAmount,
            address: receiverAddress,
            rateId: currRateId,
            refundAddress: refund
        };
        const response = await changelly_api_service_1.ChangellyApiService.createExchange(exchangeParams);
        if (!response.result && response.error) {
            throw new errors_1.RubicSdkError('Current trade already unavailable');
        }
        const exchange = response.result;
        const toAmount = new bignumber_js_1.default(exchange.amountExpectedTo).minus(exchange.networkFee);
        this.actualTokenAmount = toAmount;
        return {
            toAmount: toAmount.toFixed(),
            id: exchange.id,
            depositAddress: exchange.payinAddress,
            ...(exchange.payinExtraId && {
                depositExtraId: exchange.payinExtraId,
                depositExtraIdName: this.changellyTokens.fromToken.extraIdName
            })
        };
    }
    async getFixedRateQuote(fromWithoutFeeTokenAmount) {
        const fixRateEstimation = await changelly_api_service_1.ChangellyApiService.getFixedRateEstimation({
            from: this.changellyTokens.fromToken.ticker,
            to: this.changellyTokens.toToken.ticker,
            amountFrom: fromWithoutFeeTokenAmount
        });
        if (!fixRateEstimation.result && fixRateEstimation.error) {
            if (fixRateEstimation.error.message.includes('Invalid amount for')) {
                throw new errors_1.RubicSdkError('Calculated rate already unavailable.');
            }
            throw new errors_1.RubicSdkError(fixRateEstimation.error.message);
        }
        const quote = fixRateEstimation.result[0];
        return quote;
    }
    getTradeInfo() {
        return {
            estimatedGas: null,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact ?? null,
            slippage: this.onChainTrade?.slippageTolerance
                ? this.onChainTrade.slippageTolerance * 100
                : 0,
            routePath: this.routePath
        };
    }
}
exports.ChangellyCcrTrade = ChangellyCcrTrade;
//# sourceMappingURL=changelly-ccr-trade.js.map