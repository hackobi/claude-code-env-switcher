"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SymbiosisUtils = void 0;
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const blockchains_info_1 = require("../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const blockchain_id_1 = require("../../../../../core/blockchain/utils/blockchains-info/constants/blockchain-id");
const injector_1 = require("../../../../../core/injector/injector");
const on_chain_trade_type_1 = require("../../../../on-chain/calculation-manager/providers/common/models/on-chain-trade-type");
class SymbiosisUtils {
    static getChainId(entity) {
        const blockchain = typeof entity === 'object' ? entity.blockchain : entity;
        if (blockchains_info_1.BlockchainsInfo.isTonBlockchainName(blockchain)) {
            return 85918;
        }
        if (blockchains_info_1.BlockchainsInfo.isTronBlockchainName(blockchain)) {
            return 728126428;
        }
        if (blockchains_info_1.BlockchainsInfo.isBitcoinBlockchainName(blockchain)) {
            return 3652501241;
        }
        return blockchain_id_1.blockchainId[blockchain];
    }
    static getRevertableAddress(receiverAddress, walletAddress, toBlockchain) {
        if (toBlockchain === blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN || toBlockchain === blockchain_name_1.BLOCKCHAIN_NAME.TON) {
            return walletAddress;
        }
        return receiverAddress || walletAddress;
    }
    static getSubtype(tradeType, toBlockchain) {
        const mapping = {
            dex: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.SYMBIOSIS_SWAP,
            '1inch': on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.ONE_INCH,
            'open-ocean': on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.OPEN_OCEAN,
            wrap: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.WRAPPED,
            izumi: on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.IZUMI,
            default: undefined
        };
        return {
            from: mapping?.[tradeType?.in || 'default'],
            to: toBlockchain === blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN
                ? on_chain_trade_type_1.ON_CHAIN_TRADE_TYPE.REN_BTC
                : mapping?.[tradeType?.out || 'default']
        };
    }
    static async getReceiver(from, to, wallet, receiver) {
        const isEvmDestination = blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(to.blockchain);
        let receiverAddress = isEvmDestination ? receiver || wallet : receiver;
        let toAddress = isEvmDestination ? to.address : from.address;
        if (to.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.TRON) {
            const adapter = injector_1.Injector.web3PublicService.getWeb3Public(blockchain_name_1.BLOCKCHAIN_NAME.TRON);
            const tronHexReceiverAddress = await adapter.convertTronAddressToHex(receiver);
            receiverAddress = `0x${tronHexReceiverAddress.slice(2)}`;
            const toTokenTronAddress = await adapter.convertTronAddressToHex(to.address);
            toAddress = `0x${toTokenTronAddress.slice(2)}`;
        }
        if (from.isNative && from.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.METIS) {
            toAddress = '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000';
        }
        return { receiverAddress: receiverAddress, toAddress };
    }
}
exports.SymbiosisUtils = SymbiosisUtils;
//# sourceMappingURL=symbiosis-utils.js.map