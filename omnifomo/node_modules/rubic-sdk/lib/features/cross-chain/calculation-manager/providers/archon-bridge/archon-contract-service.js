"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArchonContractService = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const blockchain_1 = require("../../../../../common/utils/blockchain");
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const injector_1 = require("../../../../../core/injector/injector");
const archon_bridge_abi_1 = require("./constants/archon-bridge-abi");
const archon_bridge_out_contract_address_1 = require("./constants/archon-bridge-out-contract-address");
const archon_wrap_bridge_abi_1 = require("./constants/archon-wrap-bridge-abi");
const layer_zero_ids_1 = require("./constants/layer-zero-ids");
const supported_tokens_1 = require("./constants/supported-tokens");
class ArchonContractService {
    static async fetchDepositFeeBps(fromToken, toToken) {
        const { web3, contract } = ArchonContractService.getWeb3AndAddress(fromToken, toToken);
        let fee;
        if (contract.type === 'originRouter') {
            fee = await web3.callContractMethod(contract.address, archon_bridge_abi_1.archonBridgeAbi, 'depositFeeBps', []);
        }
        else {
            fee = await web3.callContractMethod(contract.address, archon_wrap_bridge_abi_1.archonWrapBridgeAbi, 'withdrawalFeeBps', []);
        }
        return new bignumber_js_1.default(fee).dividedBy(10000).toNumber();
    }
    static async fetchLayerZeroFee(fromToken, toToken) {
        const { web3, contract } = ArchonContractService.getWeb3AndAddress(fromToken, toToken);
        if (contract.type === 'originRouter') {
            const fee = await web3.callContractMethod(contract.address, archon_bridge_abi_1.archonBridgeAbi, 'estimateBridgeFee', [false, '0x']);
            return fee.nativeFee;
        }
        const remoteChainId = layer_zero_ids_1.layerZeroIds[toToken.blockchain];
        const fee = await web3.callContractMethod(contract.address, archon_wrap_bridge_abi_1.archonWrapBridgeAbi, 'estimateBridgeFee', [remoteChainId, false, '0x']);
        return fee.nativeFee;
    }
    static getWeb3AndAddress(fromToken, toToken) {
        const web3 = injector_1.Injector.web3PublicService.getWeb3Public(fromToken.blockchain);
        const contract = { address: '', type: '' };
        if (fromToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.HORIZEN_EON) {
            const toBlockchain = toToken.blockchain;
            const contractOut = archon_bridge_out_contract_address_1.archonBridgeOutContractAddress[toBlockchain];
            contract.address = fromToken.isNative
                ? contractOut.originRouter
                : contractOut.wrapRouter;
            contract.type = fromToken.isNative ? 'originRouter' : 'wrapRouter';
        }
        else {
            const fromBlockchain = fromToken.blockchain;
            const contractIn = archon_bridge_out_contract_address_1.archonBridgeInContractAddress[fromBlockchain];
            const fromNetworkAddresses = toToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.ETHEREUM
                ? supported_tokens_1.eonEthTokensMapping
                : supported_tokens_1.eonAvalancheTokensMapping;
            const wzenNonEonAddress = fromNetworkAddresses[supported_tokens_1.supportedEonTokens.wzen][0];
            const isWzen = (0, blockchain_1.compareAddresses)(fromToken.address, wzenNonEonAddress);
            contract.address = isWzen ? contractIn.wrapRouter : contractIn.originRouter;
            contract.type = isWzen ? 'wrapRouter' : 'originRouter';
        }
        return { web3, contract };
    }
}
exports.ArchonContractService = ArchonContractService;
//# sourceMappingURL=archon-contract-service.js.map