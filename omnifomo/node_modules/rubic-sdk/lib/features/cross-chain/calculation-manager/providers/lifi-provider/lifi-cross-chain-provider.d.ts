import { PriceToken, PriceTokenAmount } from "../../../../../common/tokens";
import { BlockchainName } from "../../../../../core/blockchain/models/blockchain-name";
import { BitcoinEncodedConfig } from "../../../../../core/blockchain/web3-private-service/web3-private/bitcoin-web3-private/models/bitcoin-encoded-config";
import { EvmEncodeConfig } from "../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/models/evm-encode-config";
import { RequiredCrossChainOptions } from "../../models/cross-chain-options";
import { CrossChainProvider } from "../common/cross-chain-provider";
import { CalculationResult } from "../common/models/calculation-result";
import { FeeInfo } from "../common/models/fee-info";
import { RubicStep } from "../common/models/rubicStep";
import { LifiCrossChainSupportedBlockchain } from "./constants/lifi-cross-chain-supported-blockchain";
import { Route } from './models/lifi-route';
export declare class LifiCrossChainProvider extends CrossChainProvider {
    readonly type: "lifi";
    isSupportedBlockchain(blockchain: BlockchainName): blockchain is LifiCrossChainSupportedBlockchain;
    calculate(from: PriceTokenAmount<LifiCrossChainSupportedBlockchain>, toToken: PriceToken<LifiCrossChainSupportedBlockchain>, options: RequiredCrossChainOptions): Promise<CalculationResult<EvmEncodeConfig | {
        data: string;
    } | BitcoinEncodedConfig>>;
    private checkMinError;
    protected getFeeInfo(fromBlockchain: LifiCrossChainSupportedBlockchain, providerAddress: string, percentFeeToken: PriceTokenAmount, useProxy: boolean): Promise<FeeInfo>;
    private parseTradeTypes;
    private mapDisabledProviders;
    protected getRoutePath(from: PriceTokenAmount, to: PriceTokenAmount, route: Route): Promise<RubicStep[]>;
    private getLifiGasData;
    private getMinAmountUSD;
}
