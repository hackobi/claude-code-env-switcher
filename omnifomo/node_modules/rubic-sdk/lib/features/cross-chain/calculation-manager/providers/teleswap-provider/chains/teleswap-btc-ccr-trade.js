"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeleSwapBtcCcrTrade = void 0;
const errors_1 = require("../../../../../../common/errors");
const errors_2 = require("../../../../../../common/utils/errors");
const web3_pure_1 = require("../../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../../core/injector/injector");
const cross_chain_trade_type_1 = require("../../../models/cross-chain-trade-type");
const bitcoin_cross_chain_trade_1 = require("../../common/bitcoin-cross-chain-trade/bitcoin-cross-chain-trade");
const bridge_type_1 = require("../../common/models/bridge-type");
const teleswap_network_tickers_1 = require("../constants/teleswap-network-tickers");
const teleswap_utils_service_1 = require("../services/teleswap-utils-service");
class TeleSwapBtcCcrTrade extends bitcoin_cross_chain_trade_1.BitcoinCrossChainTrade {
    get fromContractAddress() {
        throw new Error('Not implemented');
    }
    get methodName() {
        throw new Error('Not implemented');
    }
    get toBlockchain() {
        return this.to.blockchain;
    }
    constructor(params) {
        super(params.providerAddress, params.routePath, params.useProxy);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.TELE_SWAP;
        this.isAggregator = false;
        this.onChainSubtype = { from: undefined, to: undefined };
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.TELE_SWAP;
        this.memo = '';
        this.from = params.crossChainTrade.from;
        this.to = params.crossChainTrade.to;
        this.gasData = params.crossChainTrade.gasData;
        this.priceImpact = params.crossChainTrade.priceImpact;
        this.toTokenAmountMin = this.to.tokenAmount.multipliedBy(1 - params.crossChainTrade.slippage);
        this.feeInfo = params.crossChainTrade.feeInfo;
        this.slippage = params.crossChainTrade.slippage;
        this.teleSwapSdk = params.crossChainTrade.teleSwapSdk;
    }
    getTradeAmountRatio(fromUsd) {
        return fromUsd.dividedBy(this.to.tokenAmount);
    }
    getTradeInfo() {
        return {
            estimatedGas: null,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact ?? null,
            slippage: this.slippage * 100,
            routePath: this.routePath
        };
    }
    /**
     *
     * @returns txHash(srcTxHash) | never
     */
    async swap(options = {}) {
        this.checkWalletConnected();
        let transactionHash;
        try {
            const txData = await this.setTransactionConfig(false, options?.useCacheData || false, options?.receiverAddress);
            const { onConfirm } = options;
            const onTransactionHash = (hash) => {
                if (onConfirm) {
                    onConfirm(hash);
                }
                transactionHash = hash;
            };
            await this.web3Private.sendPsbtTransaction(txData.data, this.walletAddress, txData.inputIndexes, { onTransactionHash });
            return transactionHash;
        }
        catch (err) {
            if (err.message?.includes('User rejected the request') || err.code === 4001) {
                throw new errors_1.UserRejectError();
            }
            if (err?.error?.errorId === 'ERROR_LOW_GIVE_AMOUNT') {
                throw new errors_1.TooLowAmountError();
            }
            if (err instanceof errors_1.FailedToCheckForTransactionReceiptError) {
                return transactionHash;
            }
            throw (0, errors_2.parseError)(err);
        }
    }
    async getTransactionConfigAndAmount(receiverAddress) {
        const btcWeb3Public = injector_1.Injector.web3PublicService.getWeb3Public(this.from.blockchain);
        const publicKey = await btcWeb3Public.getPublicKey(this.walletAddress);
        if (!publicKey) {
            throw new errors_1.RubicSdkError('Cannot get public key from user address info');
        }
        const signerInfo = {
            // SegWit standart: starts with 'bc1q'
            addressType: 'p2wpkh',
            publicKey,
            address: this.walletAddress
        };
        try {
            const toTokenAddress = teleswap_utils_service_1.TeleSwapUtilsService.getTokenAddress(this.to);
            const swapParams = await this.teleSwapSdk.wrapAndSwapUnsigned(receiverAddress, this.from.tokenAmount.toFixed(), signerInfo, teleswap_network_tickers_1.teleSwapNetworkTickers[this.toBlockchain], toTokenAddress, web3_pure_1.Web3Pure.toWei(this.toTokenAmountMin, this.to.decimals));
            const inputIndexes = swapParams.inputs.map((_, index) => index);
            return {
                config: {
                    to: '0x',
                    value: '0x',
                    inputIndexes,
                    data: swapParams.unsignedTransaction
                },
                amount: this.to.stringWeiAmount
            };
        }
        catch (err) {
            if (err.message?.includes('not enough balance')) {
                throw new errors_1.InsufficientFundsGasPriceValueError();
            }
            throw new errors_1.RubicSdkError(err);
        }
    }
}
exports.TeleSwapBtcCcrTrade = TeleSwapBtcCcrTrade;
//# sourceMappingURL=teleswap-btc-ccr-trade.js.map