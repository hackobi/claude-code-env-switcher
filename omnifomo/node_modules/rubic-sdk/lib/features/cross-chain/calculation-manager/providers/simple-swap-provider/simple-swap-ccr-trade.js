"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleSwapCcrTrade = void 0;
const errors_1 = require("../../../../../common/errors");
const blockchains_info_1 = require("../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const injector_1 = require("../../../../../core/injector/injector");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const rubic_proxy_contract_address_1 = require("../common/constants/rubic-proxy-contract-address");
const cross_chain_transfer_trade_1 = require("../common/cross-chain-transfer-trade/cross-chain-transfer-trade");
const bridge_type_1 = require("../common/models/bridge-type");
const simple_swap_api_service_1 = require("./services/simple-swap-api-service");
class SimpleSwapCcrTrade extends cross_chain_transfer_trade_1.CrossChainTransferTrade {
    get simpleSwapId() {
        return this.paymentInfo ? this.paymentInfo.id : '';
    }
    get fromContractAddress() {
        if (this.isProxyTrade) {
            return rubic_proxy_contract_address_1.rubicProxyContractAddress[this.from.blockchain].gateway;
        }
        throw new errors_1.RubicSdkError('No contract address for simple swap provider');
    }
    constructor(crossChainTrade, providerAddress, routePath, useProxy) {
        super({
            ...crossChainTrade,
            providerAddress,
            useProxy,
            routePath,
            onChainTrade: null,
            toTokenAmountMin: crossChainTrade.to.tokenAmount
        });
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.SIMPLE_SWAP;
        this.onChainSubtype = { from: undefined, to: undefined };
        this.bridgeType = bridge_type_1.BRIDGE_TYPE.SIMPLE_SWAP;
        this.fromCurrency = crossChainTrade.fromCurrency;
        this.toCurrency = crossChainTrade.toCurrency;
    }
    async getPaymentInfo(receiverAddress) {
        const walletAddress = blockchains_info_1.BlockchainsInfo.isEvmBlockchainName(this.from.blockchain) &&
            injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(this.from.blockchain).address;
        const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(this.from, this.feeInfo.rubicProxy?.platformFee?.percent);
        const exchangeParams = {
            amount: fromWithoutFee.tokenAmount.toFixed(),
            tickerFrom: this.fromCurrency.ticker,
            tickerTo: this.toCurrency.ticker,
            networkFrom: this.fromCurrency.network,
            networkTo: this.toCurrency.network,
            fixed: true,
            addressTo: receiverAddress,
            rateId: null,
            customFee: null,
            extraIdTo: '',
            userRefundAddress: walletAddress || '',
            userRefundExtraId: ''
        };
        const { result: exchnage } = await simple_swap_api_service_1.SimpleSwapApiService.createExchange(exchangeParams);
        const extraInfo = exchnage.extraIdFrom && this.fromCurrency.hasExtraId
            ? {
                depositExtraId: exchnage.extraIdFrom,
                depositExtraIdName: this.fromCurrency.extraId
            }
            : undefined;
        return {
            id: exchnage.id,
            toAmount: exchnage.amountTo,
            depositAddress: exchnage.addressFrom,
            ...(extraInfo && { ...extraInfo })
        };
    }
    getTradeInfo() {
        return {
            estimatedGas: this.estimatedGas,
            feeInfo: this.feeInfo,
            priceImpact: this.priceImpact ?? null,
            slippage: this.onChainTrade?.slippageTolerance
                ? this.onChainTrade.slippageTolerance * 100
                : 0,
            routePath: this.routePath
        };
    }
}
exports.SimpleSwapCcrTrade = SimpleSwapCcrTrade;
//# sourceMappingURL=simple-swap-ccr-trade.js.map