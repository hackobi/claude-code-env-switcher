import { PriceToken, PriceTokenAmount } from "../../../../../common/tokens";
import { BlockchainName } from "../../../../../core/blockchain/models/blockchain-name";
import { Web3PublicSupportedBlockchain } from "../../../../../core/blockchain/web3-public-service/models/web3-public-storage";
import { EvmEncodeConfig } from "../../../../../core/blockchain/web3-pure/typed-web3-pure/evm-web3-pure/models/evm-encode-config";
import { RequiredCrossChainOptions } from '../../models/cross-chain-options';
import { CrossChainProvider } from '../common/cross-chain-provider';
import { CalculationResult } from '../common/models/calculation-result';
import { FeeInfo } from '../common/models/fee-info';
import { RubicStep } from '../common/models/rubicStep';
export declare class SimpleSwapCcrProvider extends CrossChainProvider {
    readonly type: "simple_swap";
    isSupportedBlockchain(fromBlockchain: BlockchainName): boolean;
    private isProxySupportedChain;
    calculate(from: PriceTokenAmount, toToken: PriceToken, options: RequiredCrossChainOptions): Promise<CalculationResult<EvmEncodeConfig>>;
    protected getRoutePath(from: PriceTokenAmount, to: PriceTokenAmount): Promise<RubicStep[]>;
    private getEmptyTrade;
    private getSimpleSwapCurrencies;
    private getCurrency;
    private isNativeCurrency;
    private checkMinMaxErrors;
    protected getFeeInfo(fromBlockchain: Web3PublicSupportedBlockchain, providerAddress: string, percentFeeToken: PriceTokenAmount, useProxy: boolean): Promise<FeeInfo>;
}
