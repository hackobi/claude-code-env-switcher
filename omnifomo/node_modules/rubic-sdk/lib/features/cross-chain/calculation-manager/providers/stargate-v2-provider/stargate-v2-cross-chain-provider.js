"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StargateV2CrossChainProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers_1 = require("ethers");
const errors_1 = require("../../../../../common/errors");
const tokens_1 = require("../../../../../common/tokens");
const native_tokens_1 = require("../../../../../common/tokens/constants/native-tokens");
const errors_2 = require("../../../../../common/utils/errors");
const web3_pure_1 = require("../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../core/injector/injector");
const fake_wallet_address_1 = require("../../../../common/constants/fake-wallet-address");
const get_from_without_fee_1 = require("../../../../common/utils/get-from-without-fee");
const cross_chain_trade_type_1 = require("../../models/cross-chain-trade-type");
const cross_chain_provider_1 = require("../common/cross-chain-provider");
const proxy_cross_chain_evm_trade_1 = require("../common/proxy-cross-chain-evm-facade/proxy-cross-chain-evm-trade");
const stargate_v2_blockchain_supported_pools_1 = require("./constants/stargate-v2-blockchain-supported-pools");
const stargate_v2_chain_id_1 = require("./constants/stargate-v2-chain-id");
const stargate_v2_contract_address_1 = require("./constants/stargate-v2-contract-address");
const stargate_v2_cross_chain_supported_blockchains_1 = require("./constants/stargate-v2-cross-chain-supported-blockchains");
const stargate_v2_pool_abi_1 = require("./constants/stargate-v2-pool-abi");
const stargate_v2_pool_id_1 = require("./constants/stargate-v2-pool-id");
const stargate_v2_token_address_1 = require("./constants/stargate-v2-token-address");
const stargate_v2_cross_chain_trade_1 = require("./stargate-v2-cross-chain-trade");
class StargateV2CrossChainProvider extends cross_chain_provider_1.CrossChainProvider {
    constructor() {
        super(...arguments);
        this.type = cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.STARGATE_V2;
    }
    isSupportedBlockchain(fromBlockchain) {
        return stargate_v2_cross_chain_supported_blockchains_1.stargateV2SupportedBlockchains.some(supportedBlockchain => supportedBlockchain === fromBlockchain);
    }
    async calculate(from, toToken, options) {
        try {
            const isSupportedPools = this.checkSupportedPools(from, toToken);
            if (!isSupportedPools) {
                return {
                    trade: null,
                    error: new errors_1.NotSupportedTokensError(),
                    tradeType: this.type
                };
            }
            const toBlockchain = toToken.blockchain;
            const useProxy = options?.useProxy?.[this.type] ?? true;
            const fromTokenAddress = from.address.toLowerCase();
            const dstChainId = stargate_v2_chain_id_1.stargateV2ChainIds[toBlockchain];
            const feeInfo = await this.getFeeInfo(from.blockchain, options.providerAddress, from, useProxy);
            const receiverAddress = options?.receiverAddress ||
                this.getWalletAddress(from.blockchain) ||
                fake_wallet_address_1.FAKE_WALLET_ADDRESS;
            const fromWithoutFee = (0, get_from_without_fee_1.getFromWithoutFee)(from, feeInfo.rubicProxy?.platformFee?.percent);
            const maxAmountError = await this.checkMaxAmount(from.blockchain, fromTokenAddress, fromWithoutFee.weiAmount);
            if (maxAmountError) {
                return {
                    trade: null,
                    error: maxAmountError,
                    tradeType: this.type
                };
            }
            const amountLD = fromWithoutFee.stringWeiAmount;
            const sendParams = {
                dstEid: dstChainId,
                to: ethers_1.ethers.utils.hexZeroPad(receiverAddress, 32),
                amountLD: amountLD,
                minAmountLD: amountLD,
                extraOptions: '0x',
                composeMsg: '0x',
                oftCmd: '0x'
            };
            const { amountReceivedLD } = await this.getReceiveAmount(sendParams, from.blockchain, fromTokenAddress);
            const amountReceived = amountReceivedLD[1];
            const slippageAmount = new bignumber_js_1.default(amountReceived).multipliedBy(options.slippageTolerance);
            const minReceivedAmount = new bignumber_js_1.default(amountReceived).minus(slippageAmount);
            sendParams.amountLD = amountReceived;
            sendParams.minAmountLD = minReceivedAmount.toFixed(0);
            const messagingFee = await this.getNativeFee(sendParams, from.blockchain, fromTokenAddress);
            const nativeToken = native_tokens_1.nativeTokensList[from.blockchain];
            const cryptoFeeToken = await tokens_1.PriceTokenAmount.createFromToken({
                ...nativeToken,
                weiAmount: new bignumber_js_1.default(messagingFee.nativeFee)
            });
            const to = new tokens_1.PriceTokenAmount({
                ...toToken.asStruct,
                tokenAmount: web3_pure_1.Web3Pure.fromWei(amountReceived, fromWithoutFee.decimals)
            });
            const routePath = await this.getRoutePath(from, to);
            return {
                trade: new stargate_v2_cross_chain_trade_1.StargateV2CrossChainTrade({
                    from,
                    to,
                    feeInfo: {
                        ...feeInfo,
                        provider: {
                            cryptoFee: {
                                amount: web3_pure_1.Web3Pure.fromWei(messagingFee.nativeFee, nativeToken.decimals),
                                token: cryptoFeeToken
                            }
                        }
                    },
                    slippageTolerance: options.slippageTolerance,
                    gasData: await this.getGasData(from),
                    sendParams,
                    messagingFee,
                    priceImpact: from.calculatePriceImpactPercent(to),
                    toTokenAmountMin: web3_pure_1.Web3Pure.fromWei(minReceivedAmount, fromWithoutFee.decimals)
                }, options.providerAddress, routePath, useProxy),
                tradeType: this.type
            };
        }
        catch (err) {
            return {
                trade: null,
                error: (0, errors_2.parseError)(err),
                tradeType: this.type
            };
        }
    }
    async checkMaxAmount(fromBlockchain, tokenAddress, amountToSend) {
        if (stargate_v2_contract_address_1.chainsWithoutPoolBalanceMethodOnContract.some(chain => chain === fromBlockchain)) {
            return null;
        }
        const tokenSymbol = stargate_v2_token_address_1.stargateV2TokenAddress[fromBlockchain][tokenAddress];
        const contractAddress = stargate_v2_contract_address_1.stargateV2ContractAddress[fromBlockchain][tokenSymbol];
        const maxAmount = await injector_1.Injector.web3PublicService
            .getWeb3Public(fromBlockchain)
            .callContractMethod(contractAddress, stargate_v2_pool_abi_1.stargateV2PoolBalanceAbi, 'poolBalance')
            .catch(() => '0');
        const maxAmounSend = new bignumber_js_1.default(maxAmount);
        if (amountToSend.gt(maxAmounSend)) {
            return new errors_1.MaxAmountError(maxAmounSend, tokenSymbol);
        }
        return null;
    }
    async getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy) {
        return proxy_cross_chain_evm_trade_1.ProxyCrossChainEvmTrade.getFeeInfo(fromBlockchain, providerAddress, percentFeeToken, useProxy);
    }
    checkSupportedPools(from, to) {
        const fromBlockchain = from.blockchain;
        const toBlockchain = to.blockchain;
        const srcTokenPool = (0, stargate_v2_pool_id_1.getTokenPoolByAddress)(fromBlockchain, from.address.toLowerCase());
        const dstTokenPool = (0, stargate_v2_pool_id_1.getTokenPoolByAddress)(toBlockchain, to.address.toLowerCase());
        if (!srcTokenPool || !dstTokenPool) {
            return false;
        }
        const srcSupportedPools = stargate_v2_blockchain_supported_pools_1.stargateV2BlockchainSupportedPools[from.blockchain];
        const dstSupportedPools = stargate_v2_blockchain_supported_pools_1.stargateV2BlockchainSupportedPools[to.blockchain];
        return (srcSupportedPools.includes(srcTokenPool) &&
            dstSupportedPools.includes(dstTokenPool) &&
            srcTokenPool === dstTokenPool);
    }
    async getReceiveAmount(sendParam, fromBlockchain, tokenAddress) {
        const tokenSymbol = stargate_v2_token_address_1.stargateV2TokenAddress[fromBlockchain][tokenAddress];
        const contractAddress = stargate_v2_contract_address_1.stargateV2ContractAddress[fromBlockchain][tokenSymbol];
        try {
            const { 2: amountReceivedLD } = await injector_1.Injector.web3PublicService
                .getWeb3Public(fromBlockchain)
                .callContractMethod(contractAddress, stargate_v2_pool_abi_1.stargateV2PoolAbi, 'quoteOFT', [sendParam]);
            return {
                amountReceivedLD
            };
        }
        catch (err) {
            throw new errors_1.RubicSdkError(err?.message);
        }
    }
    async getRoutePath(from, to) {
        return [
            {
                type: 'cross-chain',
                provider: cross_chain_trade_type_1.CROSS_CHAIN_TRADE_TYPE.STARGATE_V2,
                path: [from, to]
            }
        ];
    }
    async getNativeFee(sendParam, fromBlockchain, tokenAddress) {
        const tokenSymbol = stargate_v2_token_address_1.stargateV2TokenAddress[fromBlockchain][tokenAddress];
        const contractAddress = stargate_v2_contract_address_1.stargateV2ContractAddress[fromBlockchain][tokenSymbol];
        try {
            const { 0: nativeFee, 1: lzTokenFee } = await injector_1.Injector.web3PublicService
                .getWeb3Public(fromBlockchain)
                .callContractMethod(contractAddress, stargate_v2_pool_abi_1.stargateV2SendQuoteAbi, 'quoteSend', [sendParam, false]);
            return {
                nativeFee,
                lzTokenFee
            };
        }
        catch (err) {
            throw new errors_1.RubicSdkError(err?.message);
        }
    }
}
exports.StargateV2CrossChainProvider = StargateV2CrossChainProvider;
//# sourceMappingURL=stargate-v2-cross-chain-provider.js.map