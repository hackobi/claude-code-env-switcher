"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangoCommonParser = void 0;
const blockchain_name_1 = require("../../../../../core/blockchain/models/blockchain-name");
const chain_type_1 = require("../../../../../core/blockchain/models/chain-type");
const blockchains_info_1 = require("../../../../../core/blockchain/utils/blockchains-info/blockchains-info");
const web3_pure_1 = require("../../../../../core/blockchain/web3-pure/web3-pure");
const injector_1 = require("../../../../../core/injector/injector");
const fake_wallet_address_1 = require("../../../constants/fake-wallet-address");
const bridge_type_1 = require("../../../../cross-chain/calculation-manager/providers/common/models/bridge-type");
const rango_api_trade_types_1 = require("../models/rango-api-trade-types");
const rango_utils_1 = require("../utils/rango-utils");
class RangoCommonParser {
    /**
     * @description Transform parameters to required view for rango-api
     */
    static async getBestRouteQueryParams(from, toToken, options) {
        const fromParam = await rango_utils_1.RangoUtils.getFromToQueryParam(from);
        const toParam = await rango_utils_1.RangoUtils.getFromToQueryParam(toToken);
        const disabledProviders = this.getRangoDisabledProviders(from, options.swapperGroups || []);
        const amountParam = web3_pure_1.Web3Pure.toWei(from.tokenAmount, from.decimals);
        const swapperGroups = disabledProviders?.join(',');
        const fromBlockchainType = blockchains_info_1.BlockchainsInfo.getChainType(from.blockchain);
        return {
            from: fromParam,
            to: toParam,
            amount: amountParam,
            ...(options.slippageTolerance && { slippage: options.slippageTolerance * 100 }),
            ...(options.swapperGroups?.length && { swapperGroups }),
            swappersGroupsExclude: options?.swappersGroupsExclude ?? true,
            contractCall: fromBlockchainType === chain_type_1.CHAIN_TYPE.EVM
        };
    }
    static async getSwapQueryParams(fromToken, toToken, options) {
        const amount = web3_pure_1.Web3Pure.toWei(fromToken.tokenAmount, fromToken.decimals);
        const from = await rango_utils_1.RangoUtils.getFromToQueryParam(fromToken);
        const to = await rango_utils_1.RangoUtils.getFromToQueryParam(toToken);
        const walletAddress = injector_1.Injector.web3PrivateService.getWeb3PrivateByBlockchain(fromToken.blockchain).address;
        const disabledProviders = this.getRangoDisabledProviders(fromToken, options.swapperGroups || []);
        const fromAddress = options.fromAddress || walletAddress;
        const toAddress = options?.receiverAddress || walletAddress || fake_wallet_address_1.FAKE_WALLET_ADDRESS;
        const slippage = options.slippageTolerance * 100;
        const swapperGroups = disabledProviders?.join(',');
        const fromBlockchainType = blockchains_info_1.BlockchainsInfo.getChainType(fromToken.blockchain);
        return {
            amount,
            from,
            to,
            fromAddress,
            slippage,
            toAddress,
            ...(options.swapperGroups?.length && { swapperGroups }),
            swappersGroupsExclude: options?.swappersGroupsExclude ?? true,
            contractCall: fromBlockchainType === chain_type_1.CHAIN_TYPE.EVM
        };
    }
    static getTxStatusQueryParams(srcTxHash, requestId) {
        return { requestId, txId: srcTxHash };
    }
    static getRangoDisabledProviders(fromToken, disabledProviders) {
        if (!disabledProviders?.length) {
            return [];
        }
        if (fromToken.blockchain === blockchain_name_1.BLOCKCHAIN_NAME.BITCOIN) {
            const mayaProtocol = rango_api_trade_types_1.RUBIC_TO_RANGO_PROVIDERS[bridge_type_1.BRIDGE_TYPE.MAYA_PROTOCOL];
            return disabledProviders.filter(provider => provider !== mayaProtocol);
        }
        return disabledProviders;
    }
}
exports.RangoCommonParser = RangoCommonParser;
//# sourceMappingURL=rango-parser.js.map