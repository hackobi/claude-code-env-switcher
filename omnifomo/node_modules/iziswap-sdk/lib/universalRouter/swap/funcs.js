"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSwapExactOutputCall = exports.getSwapExactInputCall = exports.getUniversalSwapRouterContract = void 0;
const base_1 = require("../../base");
const base_2 = require("../../base");
const abi_json_1 = __importDefault(require("./abi.json"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("../utils");
const getUniversalSwapRouterContract = (address, web3) => {
    return (0, base_2.getEVMContract)(abi_json_1.default, address, web3);
};
exports.getUniversalSwapRouterContract = getUniversalSwapRouterContract;
/**
 * @param universalSwapRouter, universal swap router contract, can be obtained through getUniversalSwapRouterContract(...)
 * @param account, address of user
 * @param chain, object of BaseChain, describe which chain we are using
 * @param params, some settings of this swap, including swapchain, input amount, min required output amount
 * @param gasPrice, gas price of this swap transaction
 * @return calling, calling of this swap transaction
 * @return options, options of this swap transaction, used in sending transaction
 */
const getSwapExactInputCall = (universalSwapRouter, account, chain, params, gasPrice) => {
    var _a;
    const swapPathHexString = (0, utils_1.getUniversalHexPath)(params.feeTier.slice(), params.isV2.slice(), params.tokenChain.slice());
    const minAcquired = params.minOutputAmount;
    const swapParams = {
        recipient: account,
        amount: params.inputAmount,
        path: swapPathHexString,
        minAcquired,
        deadline: (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff',
        outFee: (0, utils_1.outFeeTier2OutFeeContractNumber)(params.outChargeFeeTier)
    };
    const tokenOut = params.tokenChain[params.tokenChain.length - 1];
    const tokenIn = params.tokenChain[0];
    const ifBuyETH = (0, base_1.isGasToken)(tokenOut, chain.id);
    const costETH = (0, base_1.isGasToken)(tokenIn, chain.id) ? new bignumber_js_1.default(swapParams.amount).toFixed(0) : '0';
    const contract = universalSwapRouter;
    const options = (0, base_2.buildSendingParams)(chain, {
        from: account,
        maxFeePerGas: gasPrice,
        value: costETH
    }, gasPrice);
    if (ifBuyETH) {
        swapParams.recipient = '0x0000000000000000000000000000000000000000';
        const multicall = [];
        multicall.push(contract.methods.swapAmount(swapParams).encodeABI());
        multicall.push(contract.methods.unwrapWETH9('0', account).encodeABI());
        const calling = contract.methods.multicall(multicall);
        return { calling, options };
    }
    else {
        if (costETH !== '0') {
            const multicall = [];
            multicall.push(contract.methods.swapAmount(swapParams).encodeABI());
            multicall.push(contract.methods.refundETH().encodeABI());
            const calling = contract.methods.multicall(multicall);
            return { calling, options };
        }
        else {
            const calling = contract.methods.swapAmount(swapParams);
            return { calling, options };
        }
    }
};
exports.getSwapExactInputCall = getSwapExactInputCall;
/**
 * @param universalSwapRouter, universal swap router contract, can be obtained through getUniversalSwapRouterContract(...)
 * @param account, address of user
 * @param chain, object of BaseChain, describe which chain we are using
 * @param params, some settings of this swap, including swapchain, input amount, min required output amount
 * @param gasPrice, gas price of this swap transaction
 * @return calling, calling of this swap transaction
 * @return options, options of this swap transaction, used in sending transaction
 */
const getSwapExactOutputCall = (universalSwapRouter, account, chain, params, gasPrice) => {
    var _a;
    const swapPathHexString = (0, utils_1.getUniversalHexPath)(params.feeTier.slice().reverse(), params.isV2.slice().reverse(), params.tokenChain.slice().reverse());
    const maxPayed = params.maxInputAmount;
    const swapParams = {
        recipient: account,
        desire: params.outputAmount,
        path: swapPathHexString,
        maxPayed,
        deadline: (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff',
        outFee: (0, utils_1.outFeeTier2OutFeeContractNumber)(params.outChargeFeeTier)
    };
    const tokenOut = params.tokenChain[params.tokenChain.length - 1];
    const tokenIn = params.tokenChain[0];
    const contract = universalSwapRouter;
    const ifBuyETH = (0, base_1.isGasToken)(tokenOut, chain.id);
    if (ifBuyETH) {
        swapParams.recipient = '0x0000000000000000000000000000000000000000';
    }
    const costETH = (0, base_1.isGasToken)(tokenIn, chain.id) ? swapParams.maxPayed : '0';
    const multicall = [];
    multicall.push(contract.methods.swapDesire(swapParams));
    if (ifBuyETH) {
        multicall.push(contract.methods.unwrapWETH9('0', account));
    }
    if (new bignumber_js_1.default(costETH).gt('0')) {
        multicall.push(contract.methods.refundETH());
    }
    const calling = (multicall.length > 1) ? contract.methods.multicall(multicall.map((c) => c.encodeABI())) : multicall[0];
    const options = (0, base_2.buildSendingParams)(chain, {
        from: account,
        maxFeePerGas: gasPrice,
        value: costETH
    }, gasPrice);
    return { calling, options };
};
exports.getSwapExactOutputCall = getSwapExactOutputCall;
