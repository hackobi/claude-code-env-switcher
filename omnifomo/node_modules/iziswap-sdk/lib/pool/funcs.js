"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLimitOrders = exports.getLiquidities = exports.getRawDeltaLiquidities = exports.getPoolState = exports.getPointDelta = exports.getPoolAddress = exports.getCreatePoolCall = exports.getFactoryContract = exports.getPoolContract = void 0;
const utils_1 = require("../base/utils");
const poolAbi_json_1 = __importDefault(require("./poolAbi.json"));
const factoryAbi_json_1 = __importDefault(require("./factoryAbi.json"));
const base_1 = require("../base");
const jsbi_1 = __importDefault(require("jsbi"));
const error_1 = require("./error");
const getPoolContract = (address, web3) => {
    return (0, utils_1.getEVMContract)(poolAbi_json_1.default, address, web3);
};
exports.getPoolContract = getPoolContract;
const getFactoryContract = (address, web3) => {
    return (0, utils_1.getEVMContract)(factoryAbi_json_1.default, address, web3);
};
exports.getFactoryContract = getFactoryContract;
const getCreatePoolCall = (factoryContract, tokenX, tokenY, feeContractNumber, initPointXByY, account, chain, gasPrice) => {
    let createPoolCalling = undefined;
    let options = undefined;
    if (tokenX.toLowerCase() > tokenY.toLowerCase()) {
        return { createPoolCalling, options };
    }
    options = (0, base_1.buildSendingParams)(chain, {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    }, gasPrice);
    createPoolCalling = factoryContract.methods.newPool(tokenX, tokenY, feeContractNumber, initPointXByY);
    return { createPoolCalling, options };
};
exports.getCreatePoolCall = getCreatePoolCall;
const getPoolAddress = (factoryContract, tokenAAddress, tokenBAddress, feeContractNumber) => __awaiter(void 0, void 0, void 0, function* () {
    const poolAddress = yield factoryContract.methods.pool(tokenAAddress, tokenBAddress, feeContractNumber).call();
    return poolAddress;
});
exports.getPoolAddress = getPoolAddress;
const getPointDelta = (pool) => __awaiter(void 0, void 0, void 0, function* () {
    const pointDelta = Number(yield pool.methods.pointDelta().call());
    return pointDelta;
});
exports.getPointDelta = getPointDelta;
const getPoolState = (pool) => __awaiter(void 0, void 0, void 0, function* () {
    const { sqrtPrice_96, currentPoint, observationCurrentIndex, observationQueueLen, observationNextQueueLen, liquidity, liquidityX } = (yield pool.methods.state().call());
    return {
        sqrtPrice_96: sqrtPrice_96.toString(),
        currentPoint: Number(currentPoint),
        observationCurrentIndex: Number(observationCurrentIndex),
        observationQueueLen: Number(observationQueueLen),
        observationNextQueueLen: Number(observationNextQueueLen),
        liquidity: liquidity.toString(),
        liquidityX: liquidityX.toString()
    };
});
exports.getPoolState = getPoolState;
const getRawDeltaLiquidities = (pool, leftPoint, rightPoint, pointDelta) => __awaiter(void 0, void 0, void 0, function* () {
    const leftPointRoundDown = (0, base_1.pointDeltaRoundingDown)(leftPoint, pointDelta);
    const rightPointRoundUp = (0, base_1.pointDeltaRoundingUp)(rightPoint, pointDelta);
    const rawDeltaLiquidities = yield pool.methods.liquiditySnapshot(leftPointRoundDown, rightPointRoundUp).call();
    const deltaLiquidities = [];
    const point = [];
    for (const i in rawDeltaLiquidities) {
        const idx = Number(i);
        const liquidityStr = rawDeltaLiquidities[idx].toString();
        if (liquidityStr !== '0') {
            deltaLiquidities.push(jsbi_1.default.BigInt(liquidityStr));
            point.push(leftPointRoundDown + Number(idx * pointDelta));
        }
    }
    return { deltaLiquidities, point };
});
exports.getRawDeltaLiquidities = getRawDeltaLiquidities;
const getLiquidities = (pool, leftPoint, rightPoint, targetPoint, pointDelta, targetLiquidity, batchSize) => __awaiter(void 0, void 0, void 0, function* () {
    (0, error_1.poolInvariant)(leftPoint <= targetPoint, error_1.PoolErrCode.LEFTPT_GREATER_THAN_CURRENTPT_ERROR);
    (0, error_1.poolInvariant)(rightPoint >= targetPoint, error_1.PoolErrCode.RIGHTPT_LESS_THAN_CURRENTPT_ERROR);
    const leftPointRoundDown = (0, base_1.pointDeltaRoundingDown)(leftPoint, pointDelta);
    const rightPointRoundUp = (0, base_1.pointDeltaRoundingUp)(rightPoint, pointDelta) + pointDelta;
    const realRightRoundUp = rightPointRoundUp - pointDelta;
    const batchSizeRoundingDown = Math.max((0, base_1.pointDeltaRoundingDown)(batchSize, pointDelta), pointDelta);
    const ZERO = jsbi_1.default.BigInt(0);
    let preSum = ZERO;
    const allLiquidities = [preSum];
    const allPoint = [leftPointRoundDown];
    for (let i = leftPointRoundDown; i < rightPointRoundUp; i += batchSizeRoundingDown) {
        const start = i;
        const end = Math.min(start + batchSizeRoundingDown, rightPointRoundUp);
        const { deltaLiquidities, point } = yield (0, exports.getRawDeltaLiquidities)(pool, start, end, pointDelta);
        for (let idx = 0; idx < deltaLiquidities.length; idx++) {
            if (point[idx] > leftPointRoundDown) {
                preSum = jsbi_1.default.add(preSum, deltaLiquidities[idx]);
                allLiquidities.push(preSum);
                allPoint.push(point[idx]);
            }
        }
    }
    if (allPoint[allPoint.length] < realRightRoundUp) {
        allPoint.push(realRightRoundUp);
        allLiquidities.push(preSum);
    }
    const currentLiquidity = jsbi_1.default.BigInt(targetLiquidity);
    let currentDeltaLiquidity = jsbi_1.default.BigInt(0);
    for (let i = 0; i < allPoint.length; i++) {
        if (allPoint[i] <= targetPoint && (i + 1 === allPoint.length || allPoint[i + 1] > targetPoint)) {
            currentDeltaLiquidity = jsbi_1.default.subtract(currentLiquidity, allLiquidities[i]);
        }
    }
    for (let i = 0; i < allPoint.length; i++) {
        allLiquidities[i] = jsbi_1.default.add(allLiquidities[i], currentDeltaLiquidity);
    }
    return { liquidities: allLiquidities, point: allPoint };
});
exports.getLiquidities = getLiquidities;
const getLimitOrders = (pool, leftPoint, rightPoint, pointDelta, batchSize) => __awaiter(void 0, void 0, void 0, function* () {
    const leftPointRoundDown = (0, base_1.pointDeltaRoundingDown)(leftPoint, pointDelta);
    const rightPointRoundUp = (0, base_1.pointDeltaRoundingUp)(rightPoint, pointDelta) + pointDelta;
    const realRightRoundUp = rightPointRoundUp - pointDelta;
    const batchSizeRoundingDown = Math.max((0, base_1.pointDeltaRoundingDown)(batchSize, pointDelta), pointDelta);
    const sellingX = [];
    const sellingY = [];
    const sellingXPoint = [];
    const sellingYPoint = [];
    for (let i = leftPointRoundDown; i < rightPointRoundUp; i += batchSizeRoundingDown) {
        const start = i;
        const end = Math.min(start + batchSizeRoundingDown, rightPointRoundUp);
        const rawData = yield pool.methods.limitOrderSnapshot(start, end).call();
        for (let j = 0; j < rawData.length; j++) {
            const sellingXStr = rawData[j].sellingX.toString();
            const sellingYStr = rawData[j].sellingY.toString();
            if (sellingYStr !== '0' || i === leftPointRoundDown && j === 0) {
                sellingY.push(jsbi_1.default.BigInt(sellingYStr));
                sellingYPoint.push(start + j * pointDelta);
            }
            if (sellingXStr !== '0') {
                sellingX.push(jsbi_1.default.BigInt(sellingXStr));
                sellingXPoint.push(start + j * pointDelta);
            }
        }
    }
    if (sellingXPoint[sellingXPoint.length - 1] < realRightRoundUp) {
        sellingX.push(jsbi_1.default.BigInt(0));
        sellingXPoint.push(realRightRoundUp);
    }
    return {
        sellingX,
        sellingXPoint,
        sellingY,
        sellingYPoint
    };
});
exports.getLimitOrders = getLimitOrders;
