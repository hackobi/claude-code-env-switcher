"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeactiveSlot = exports.fetchLimitOrderOfAccount = exports.getPoolAddress = exports.getLimitOrderManagerContract = void 0;
const base_1 = require("../base");
const base_2 = require("../base");
const liquidityManager_1 = require("../liquidityManager");
const abi_json_1 = __importDefault(require("./abi.json"));
const bignumber_js_1 = require("bignumber.js");
const price_1 = require("../base/price");
const getLimitOrderManagerContract = (address, web3) => {
    return (0, base_2.getEVMContract)(abi_json_1.default, address, web3);
};
exports.getLimitOrderManagerContract = getLimitOrderManagerContract;
const getPoolAddress = (limitOrderManager, tokenA, tokenB, fee) => __awaiter(void 0, void 0, void 0, function* () {
    const poolAddress = yield limitOrderManager.methods.pool((0, base_1.getSwapTokenAddress)(tokenA), (0, base_1.getSwapTokenAddress)(tokenB), fee).call();
    return poolAddress;
});
exports.getPoolAddress = getPoolAddress;
const fetchLimitOrderOfAccount = (chain, web3, limitOrderManager, account, tokenList) => __awaiter(void 0, void 0, void 0, function* () {
    // 1. get active limit order id
    const limitOrderMulticallData = [];
    limitOrderMulticallData.push(limitOrderManager.methods.getActiveOrders(account).encodeABI());
    limitOrderMulticallData.push(limitOrderManager.methods.getDeactiveOrders(account).encodeABI());
    const limitOrderListResult = yield limitOrderManager.methods.multicall(limitOrderMulticallData).call();
    const getActiveOrderResult = (0, base_2.decodeMethodResult)(web3, abi_json_1.default, 'getActiveOrders', limitOrderListResult[0]);
    const getDeactiveOrderResult = (0, base_2.decodeMethodResult)(web3, abi_json_1.default, 'getDeactiveOrders', limitOrderListResult[1]);
    const activeOrderIdx = getActiveOrderResult.activeIdx;
    const activeLimitOrder = getActiveOrderResult.activeLimitOrder;
    const deactiveLimitOrder = getDeactiveOrderResult.deactiveLimitOrder;
    const allOrders = [...activeLimitOrder, ...deactiveLimitOrder];
    if (allOrders.length <= 0) {
        return { activeOrders: [], deactiveOrders: [] };
    }
    const orderTotal = allOrders.length;
    const activeOrderTotal = activeOrderIdx.length;
    // const deactiveOrderTotal = deactiveLimitOrder.length;
    // 2. get limit order detail
    const poolMetaMulticallData = allOrders.map(order => limitOrderManager.methods.poolMetas(order.poolId).encodeABI());
    const poolAddrMulticallData = allOrders.map(order => limitOrderManager.methods.poolAddrs(order.poolId).encodeABI());
    const poolResult = yield limitOrderManager.methods.multicall([...poolMetaMulticallData, ...poolAddrMulticallData]).call();
    const poolMetaList = poolResult.slice(0, orderTotal).map(p => web3.eth.abi.decodeParameters(liquidityManager_1.poolMetas, p));
    const poolAddressList = poolResult.slice(orderTotal, orderTotal * 2).map(p => String(web3.eth.abi.decodeParameter('address', p)));
    const updateOrderMulticallData = activeOrderIdx.map((idx) => limitOrderManager.methods.updateOrder(idx).encodeABI());
    const updateOrderResult = yield limitOrderManager.methods.multicall(updateOrderMulticallData).call({ from: account });
    const activeOrders = [];
    const deactiveOrders = [];
    for (let i = 0; i < orderTotal; i++) {
        const orderPoolMeta = poolMetaList[i];
        let tokenX = Object.assign({}, tokenList.find((e) => (0, base_1.getSwapTokenAddress)(e).toLowerCase() === orderPoolMeta.tokenX.toLowerCase()));
        let tokenY = Object.assign({}, tokenList.find((e) => (0, base_1.getSwapTokenAddress)(e).toLowerCase() === orderPoolMeta.tokenY.toLowerCase()));
        if (!tokenX.symbol) {
            tokenX = yield (0, base_1.fetchToken)(orderPoolMeta.tokenX, chain, web3);
        }
        if (!tokenY.symbol) {
            tokenY = yield (0, base_1.fetchToken)(orderPoolMeta.tokenY, chain, web3);
        }
        if (i < activeOrderTotal) {
            const earn = activeLimitOrder[i].earn;
            const updateEarn = (0, base_2.decodeMethodResult)(web3, abi_json_1.default, 'updateOrder', updateOrderResult[i]);
            const pending = new bignumber_js_1.BigNumber(updateEarn.earn).minus(earn).toFixed(0);
            const sellingRemain = activeLimitOrder[i].sellingRemain;
            const accSellingDec = activeLimitOrder[i].accSellingDec;
            const sellingDec = activeLimitOrder[i].sellingDec;
            const amount = activeLimitOrder[i].amount;
            const filled = new bignumber_js_1.BigNumber(amount).minus(sellingRemain).minus(accSellingDec).toFixed(0);
            const point = Number(activeLimitOrder[i].pt);
            const priceXByY = (0, price_1.point2PriceUndecimal)(tokenX, tokenY, point);
            const priceXByYDecimal = (0, price_1.priceUndecimal2PriceDecimal)(tokenX, tokenY, priceXByY);
            const idx = activeOrderIdx[i];
            const lastAccEarn = activeLimitOrder[i].lastAccEarn;
            const poolId = activeLimitOrder[i].poolId;
            const poolAddress = poolAddressList[i];
            const limitOrder = {
                idx,
                lastAccEarn,
                amount,
                filled,
                sellingRemain,
                accSellingDec,
                sellingDec,
                earn,
                pending,
                poolId,
                poolAddress,
                tokenX,
                tokenY,
                createTime: Number(activeLimitOrder[i].timestamp),
                point,
                priceXByY,
                priceXByYDecimal,
                sellXEarnY: activeLimitOrder[i].sellXEarnY,
                active: true
            };
            activeOrders.push(limitOrder);
        }
        else {
            const ii = i - activeOrderTotal;
            const earn = deactiveLimitOrder[ii].earn;
            const pending = '0';
            const sellingRemain = deactiveLimitOrder[ii].sellingRemain;
            const accSellingDec = deactiveLimitOrder[ii].accSellingDec;
            const sellingDec = deactiveLimitOrder[ii].sellingDec;
            const amount = deactiveLimitOrder[ii].amount;
            const filled = new bignumber_js_1.BigNumber(amount).minus(sellingRemain).minus(accSellingDec).toFixed(0);
            const point = Number(deactiveLimitOrder[ii].pt);
            const priceXByY = (0, price_1.point2PriceUndecimal)(tokenX, tokenY, point);
            const priceXByYDecimal = (0, price_1.priceUndecimal2PriceDecimal)(tokenX, tokenY, priceXByY);
            const idx = '-1';
            const lastAccEarn = deactiveLimitOrder[ii].lastAccEarn;
            const poolId = deactiveLimitOrder[ii].poolId;
            const poolAddress = poolAddressList[ii];
            const limitOrder = {
                idx,
                lastAccEarn,
                amount,
                filled,
                sellingRemain,
                accSellingDec,
                sellingDec,
                earn,
                pending,
                poolId,
                poolAddress,
                tokenX,
                tokenY,
                createTime: Number(deactiveLimitOrder[ii].timestamp),
                point,
                priceXByY,
                priceXByYDecimal,
                sellXEarnY: deactiveLimitOrder[ii].sellXEarnY,
                active: false
            };
            deactiveOrders.push(limitOrder);
        }
    }
    return { activeOrders, deactiveOrders };
});
exports.fetchLimitOrderOfAccount = fetchLimitOrderOfAccount;
const getDeactiveSlot = (limitOrderManager, account) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield limitOrderManager.methods.getDeactiveSlot(account).call()).toString();
});
exports.getDeactiveSlot = getDeactiveSlot;
