"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderProtocolFacade = void 0;
const limit_order_protocol_const_1 = require("./limit-order-protocol.const");
const limit_order_protocol_model_1 = require("./model/limit-order-protocol.model");
const bignumber_1 = require("@ethersproject/bignumber");
const limit_order_utils_1 = require("./utils/limit-order.utils");
const abi_1 = require("./utils/abi");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const abstract_facade_1 = require("./utils/abstract-facade");
class LimitOrderProtocolFacade extends abstract_facade_1.AbstractSmartcontractFacade {
    constructor() {
        super(...arguments);
        this.ABI = limit_order_protocol_const_1.LIMIT_ORDER_PROTOCOL_ABI;
    }
    fillLimitOrder(params) {
        const { order, interaction = limit_order_protocol_const_1.ZX, signature, makingAmount, takingAmount, thresholdAmount, skipPermit = false, } = params;
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.fillOrder, [
            order,
            signature,
            interaction,
            makingAmount,
            takingAmount,
            // skipPermitAndThresholdAmount
            limit_order_utils_1.packSkipPermitAndThresholdAmount(thresholdAmount, skipPermit),
        ]);
    }
    /**
     * @param params.interaction pre-interaction in fact.
     * @param params.skipPermit skip maker's permit evaluation if it was evaluated before.
     * Useful if multiple orders was created with same nonce.
     *
     * Tip: you can just check if allowance exsists and then set it to `true`.
     */
    fillOrderToWithPermit(params) {
        const { order, signature, makingAmount, takingAmount, interaction = limit_order_protocol_const_1.ZX, thresholdAmount, skipPermit = false, targetAddress, permit, } = params;
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.fillOrderToWithPermit, [
            order,
            signature,
            interaction,
            makingAmount,
            takingAmount,
            // skipPermitAndThresholdAmount
            limit_order_utils_1.packSkipPermitAndThresholdAmount(thresholdAmount, skipPermit),
            targetAddress,
            permit
        ]);
    }
    fillRFQOrder(order, signature, makingAmount, takingAmount) {
        let flagsAndAmount = '0';
        if (makingAmount) {
            flagsAndAmount = limit_order_utils_1.getMakingAmountForRFQ(makingAmount);
        }
        else if (takingAmount) {
            flagsAndAmount = takingAmount;
        }
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.fillOrderRFQ, [order, signature, flagsAndAmount]);
    }
    cancelLimitOrder(order) {
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.cancelOrder, [
            order,
        ]);
    }
    cancelRFQOrder(orderInfo) {
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.cancelOrderRFQ, [orderInfo]);
    }
    nonce(makerAddress) {
        const callData = this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.nonce, [makerAddress]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .then((nonce) => BigInt(nonce));
    }
    advanceNonce(count) {
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.advanceNonce, [count]);
    }
    increaseNonce() {
        return this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.increaseNonce);
    }
    checkPredicate(order) {
        const callData = this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.checkPredicate, [order]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .catch((error) => {
            console.error(error);
            return false;
        })
            .then((result) => {
            try {
                return bignumber_1.BigNumber.from(result).toNumber() === 1;
            }
            catch (e) {
                console.error(e);
                return false;
            }
        });
    }
    remaining(orderHash) {
        const callData = this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.remaining, [orderHash]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .then((result) => {
            const response = this.parseRemainingResponse(result);
            if (response !== null) {
                return response;
            }
            return Promise.reject(result);
        });
    }
    simulate(targetAddress, data) {
        const callData = this.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.simulate, [targetAddress, data]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .then(() => {
            throw new Error('call was successful but revert was expected');
        })
            .catch((result) => {
            const parsedResult = this.parseSimulateTransferError(result);
            if (parsedResult) {
                return parsedResult;
            }
            throw { success: false, rawResult: result };
        });
    }
    // https://github.com/1inch/limit-order-protocol/blob/v3-prerelease/test/helpers/eip712.js#L22
    domainSeparator() {
        const hex = '0x' + eth_sig_util_1.TypedDataUtils.hashStruct('EIP712Domain', {
            name: limit_order_protocol_const_1.PROTOCOL_NAME,
            version: limit_order_protocol_const_1.PROTOCOL_VERSION,
            chainId: this.chainId,
            verifyingContract: this.contractAddress,
        }, { EIP712Domain: limit_order_protocol_const_1.EIP712_DOMAIN }, limit_order_protocol_const_1.TypedDataVersion).toString('hex');
        return Promise.resolve(hex);
    }
    parseRemainingResponse(response) {
        if (response.length === 66) {
            return bignumber_1.BigNumber.from(response);
        }
        return null;
    }
    parseSimulateTransferError(error) {
        const simulationResultsAbi = abi_1.getABIFor(limit_order_protocol_const_1.LIMIT_ORDER_PROTOCOL_ABI, 'SimulationResults');
        const revertionData = limit_order_utils_1.extractWeb3OriginalErrorData(error);
        if (simulationResultsAbi && revertionData) {
            const parsed = this.providerConnector.decodeABICallParameters(simulationResultsAbi.inputs, revertionData);
            const parsedResult = parsed.res;
            const success = parsed.success
                && this.isSimulationResultResponseSuccessfull(parsedResult);
            return {
                success,
                rawResult: parsed.res,
            };
        }
        return null;
    }
    isSimulationResultResponseSuccessfull(res) {
        if (!res || !res.length)
            return true;
        return this.providerConnector.decodeABIParameter('bool', res);
    }
}
exports.LimitOrderProtocolFacade = LimitOrderProtocolFacade;
//# sourceMappingURL=limit-order-protocol.facade.js.map