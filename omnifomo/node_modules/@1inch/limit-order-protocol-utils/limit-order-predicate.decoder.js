"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderPredicateDecoder = exports.PredicateFn = exports.PredicateBytes = exports.DecodableCall = void 0;
const limit_order_protocol_const_1 = require("./limit-order-protocol.const");
const series_nonce_manager_const_1 = require("./series-nonce-manager.const");
const abi_1 = require("@ethersproject/abi");
const limit_order_protocol_const_2 = require("./limit-order-protocol.const");
const helpers_1 = require("./utils/helpers");
const limit_order_predicate_decoders_1 = require("./utils/decoders/limit-order-predicate-decoders");
const series_nonce_manager_decoders_1 = require("./utils/decoders/series-nonce-manager-decoders");
const limit_order_utils_1 = require("./utils/limit-order.utils");
class DecodableCall {
    constructor(calldata, target) {
        this.calldata = calldata;
        this.target = target;
    }
}
exports.DecodableCall = DecodableCall;
class PredicateBytes {
    constructor(bytes, source) {
        this.bytes = bytes;
        this.type = "bytes";
        this.meta = {
            source,
        };
    }
}
exports.PredicateBytes = PredicateBytes;
class PredicateFn {
    constructor(name, args, source) {
        this.name = name;
        this.args = args;
        this.type = "function";
        this.meta = {
            source,
        };
    }
}
exports.PredicateFn = PredicateFn;
class LimitOrderPredicateDecoder {
    constructor(chainId, decodableContracts = {}) {
        this.chainId = chainId;
        this.findFirstDFS = (tree, matcher) => {
            if (matcher(tree))
                return tree;
            if (tree.args) {
                const args = helpers_1.isIterable(tree.args)
                    ? Array.from(tree.args)
                    : Object.values(tree.args);
                for (const arg of args) {
                    const result = this.findFirstDFS(arg, matcher);
                    if (result)
                        return result;
                }
            }
            return null;
        };
        // eslint-disable-next-line
        this.parseCalldata = (calldata, address) => {
            const sig = calldata.substring(0, 10);
            const decodableIface = this.decodableInterfaces[address];
            if (!decodableIface)
                return new PredicateBytes(calldata, address);
            let fn;
            try {
                fn = decodableIface.iface.getFunction(sig);
            }
            catch (e) {
                console.warn(`Tried to decode unknown function with signature ${sig} on ${address}.`);
                return new PredicateBytes(calldata, address);
            }
            const data = decodableIface.iface.decodeFunctionData(fn, calldata);
            const decoder = (decodableIface.decoders[fn.name]
                || decodableIface.decoders[sig]
                || decodableIface.decoders[sig.substring(2)]);
            if (!decoder)
                return new PredicateBytes(calldata, address);
            const decoded = decoder(fn, data, address);
            const result = Object.assign({}, decoded);
            const { args } = decoded;
            if (args) {
                if (helpers_1.isIterable(args)) {
                    result.args = Array.from(args).map(this.mapArgs);
                }
                else {
                    result.args = helpers_1.mapObject(args, this.mapArgs);
                }
            }
            return result;
        };
        this.parseDecodableCall = (call) => {
            return this.parseCalldata(limit_order_protocol_const_1.ZX + limit_order_utils_1.trim0x(call.calldata), call.target.toLowerCase());
        };
        this.mapArgs = (arg) => {
            if (arg instanceof DecodableCall) {
                return this.parseDecodableCall(arg);
            }
            return arg;
        };
        this.defaultAddress = limit_order_protocol_const_2.limirOrderProtocolAdresses[this.chainId].toLowerCase();
        this.decodableInterfaces = {
            [this.defaultAddress]: {
                iface: new abi_1.Interface(limit_order_protocol_const_1.LIMIT_ORDER_PROTOCOL_ABI),
                decoders: new limit_order_predicate_decoders_1.LimitOrderPredicateDecoders(),
            },
            [series_nonce_manager_const_1.seriesNonceManagerContractAddresses[this.chainId].toLowerCase()]: {
                iface: new abi_1.Interface(series_nonce_manager_const_1.SERIES_NONCE_MANAGER_ABI),
                decoders: new series_nonce_manager_decoders_1.SeriesNonceManagerDecoders(),
            },
        };
        // User defined decoders
        Object.assign(this.decodableInterfaces, this.decodableContractsToDecodableInterfaces(decodableContracts));
    }
    decode(calldata) {
        return this.parseCalldata(calldata, this.defaultAddress);
    }
    decodableContractsToDecodableInterfaces(decodableContracts) {
        return Object.assign({}, ...Object.entries(decodableContracts).map(([address, { abi, decoders }]) => {
            return [
                address.toLowerCase(),
                {
                    iface: new abi_1.Interface(abi),
                    decoders,
                }
            ];
        }));
    }
}
exports.LimitOrderPredicateDecoder = LimitOrderPredicateDecoder;
//# sourceMappingURL=limit-order-predicate.decoder.js.map