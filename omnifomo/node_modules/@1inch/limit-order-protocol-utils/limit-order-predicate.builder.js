"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderPredicateBuilder = void 0;
const limit_order_protocol_model_1 = require("./model/limit-order-protocol.model");
const limit_order_protocol_const_1 = require("./limit-order-protocol.const");
const abstract_facade_1 = require("./utils/abstract-facade");
const limit_order_builder_1 = require("./limit-order.builder");
/**
 * All methods is lambdas to preserve `this` context and allow DSL-like usage
 */
class LimitOrderPredicateBuilder {
    constructor(facade) {
        this.facade = facade;
        this.and = (...predicates) => {
            const { offsets, data } = limit_order_builder_1.LimitOrderBuilder.joinStaticCalls(predicates);
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.and, [
                offsets,
                data,
            ]);
        };
        this.or = (...predicates) => {
            const { offsets, data } = limit_order_builder_1.LimitOrderBuilder.joinStaticCalls(predicates);
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.or, [
                offsets,
                data,
            ]);
        };
        this.eq = (value, callData) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.eq, [
                value,
                callData,
            ]);
        };
        this.lt = (value, callData) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.lt, [
                value,
                callData,
            ]);
        };
        this.gt = (value, callData) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.gt, [
                value,
                callData,
            ]);
        };
        this.nonce = (makerAddress) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.nonce, [makerAddress]);
        };
        this.nonceEquals = (makerAddress, makerNonce) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.nonceEquals, [makerAddress, makerNonce]);
        };
        /**
         * @param timestamp seconds unit
         */
        this.timestampBelow = (timestamp) => {
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.timestampBelow, [limit_order_protocol_const_1.ZX + timestamp.toString(16)]);
        };
        /**
         * @param timestamp seconds unit
         */
        this.timestampBelowAndNonceEquals = (timestamp, nonce, address) => {
            const predicateValue = BigInt(address)
                + (BigInt(nonce) << BigInt(160))
                + (BigInt(timestamp) << BigInt(208));
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.timestampBelowAndNonceEquals, [limit_order_protocol_const_1.ZX + predicateValue.toString(16)]);
        };
        this.arbitraryStaticCall = (target, callData) => {
            const address = target instanceof abstract_facade_1.AbstractSmartcontractFacade
                ? target.contractAddress
                : target;
            if (address.toLowerCase() === this.facade.contractAddress.toLowerCase()) {
                console.warn('Unnecessary arbitraryStaticCall(). '
                    + 'Omit it when interacting with limit-order-protocol methods.');
                return callData;
            }
            return this.facade.getContractCallData(limit_order_protocol_model_1.LimitOrderProtocolMethods.arbitraryStaticCall, [
                address,
                callData,
            ]);
        };
    }
}
exports.LimitOrderPredicateBuilder = LimitOrderPredicateBuilder;
//# sourceMappingURL=limit-order-predicate.builder.js.map