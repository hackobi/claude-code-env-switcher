import { LimitOrder, LimitOrderProtocolMethods, LimitOrderHash, LimitOrderSignature, RFQOrderInfo, RFQOrder } from './model/limit-order-protocol.model';
import { BigNumber } from '@ethersproject/bignumber';
import { AbstractSmartcontractFacade } from './utils/abstract-facade';
export interface FillOrderParams {
    order: LimitOrder;
    signature: LimitOrderSignature;
    interaction?: string;
    makingAmount: string;
    takingAmount: string;
    thresholdAmount: string;
    skipPermit?: boolean;
}
export declare type FillLimitOrderWithPermitParams = FillOrderParams & {
    targetAddress: string;
    permit: string;
};
export interface ErrorResponse extends Error {
    data: string;
}
export declare class LimitOrderProtocolFacade extends AbstractSmartcontractFacade<LimitOrderProtocolMethods> {
    ABI: import(".").AbiItem[];
    fillLimitOrder(params: FillOrderParams): string;
    /**
     * @param params.interaction pre-interaction in fact.
     * @param params.skipPermit skip maker's permit evaluation if it was evaluated before.
     * Useful if multiple orders was created with same nonce.
     *
     * Tip: you can just check if allowance exsists and then set it to `true`.
     */
    fillOrderToWithPermit(params: FillLimitOrderWithPermitParams): string;
    fillRFQOrder(order: RFQOrder, signature: LimitOrderSignature, makingAmount?: string, takingAmount?: string): string;
    cancelLimitOrder(order: LimitOrder): string;
    cancelRFQOrder(orderInfo: RFQOrderInfo): string;
    nonce(makerAddress: string): Promise<bigint>;
    advanceNonce(count: number): string;
    increaseNonce(): string;
    checkPredicate(order: LimitOrder): Promise<boolean>;
    remaining(orderHash: LimitOrderHash): Promise<BigNumber>;
    simulate(targetAddress: string, data: unknown): Promise<{
        success: boolean;
        rawResult: string;
    }>;
    domainSeparator(): Promise<string>;
    parseRemainingResponse(response: string): BigNumber | null;
    parseSimulateTransferError(error: ErrorResponse | Error | string): {
        success: boolean;
        rawResult: string;
    } | null;
    private isSimulationResultResponseSuccessfull;
}
