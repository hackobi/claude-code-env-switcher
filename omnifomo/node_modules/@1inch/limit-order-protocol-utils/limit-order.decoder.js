"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderDecoder = void 0;
const limit_order_protocol_model_1 = require("./model/limit-order-protocol.model");
const limit_order_utils_1 = require("./utils/limit-order.utils");
class LimitOrderDecoder {
    static unpackInteractions(offsets, interactions) {
        const offsetsBN = BigInt(offsets);
        const parsedInteractions = {};
        Object.entries(limit_order_protocol_model_1.InteractionsFields).forEach(([name, position]) => {
            parsedInteractions[name] = limit_order_utils_1.parseInteractionForField(offsetsBN, interactions, position);
        });
        return parsedInteractions;
    }
    static unpackInteraction(order, name) {
        return limit_order_utils_1.parseInteractionForField(BigInt(order.offsets), order.interactions, limit_order_protocol_model_1.InteractionsFields[name]);
    }
    /**
     * @returns `true` if interaction value is empty of 0x
     */
    static hasInteraction(order, name) {
        const interaction = this.unpackInteraction(order, name);
        return limit_order_utils_1.trim0x(interaction) !== '';
    }
    static unpackStaticCalls(offsets, interactions) {
        const offsetsBI = BigInt(offsets);
        const data = limit_order_utils_1.trim0x(interactions);
        const result = [];
        let previous = BigInt(0);
        let current = BigInt(0);
        // See PredicateHelper.and in limit-order-protocol
        for (let i = BigInt(0); (current = (offsetsBI >> i) & limit_order_utils_1.UINT32_BITMASK); i += limit_order_utils_1.UINT32_BITS) {
            const calldata = data.slice(Number(previous) * 2, Number(current) * 2);
            result.push(calldata);
            previous = current;
        }
        return result;
    }
}
exports.LimitOrderDecoder = LimitOrderDecoder;
//# sourceMappingURL=limit-order.decoder.js.map