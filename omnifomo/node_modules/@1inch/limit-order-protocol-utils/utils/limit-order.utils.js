"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractWeb3OriginalErrorData = exports.packSkipPermitAndThresholdAmount = exports.unpackTimestampAndNoncePredicate = exports.ARBITRARY_STATIC_CALL_SELECTOR = exports.TIMESTAMP_AND_NOUNCE_SELECTOR = exports.getMakingAmountForRFQ = exports.parseInteractionForField = exports.getOffsets = exports.trim0x = exports.ADDRESS_MASK = exports.UINT48_BITMASK = exports.UINT40_BITMASK = exports.UINT16_BITMASK = exports.UINT32_BITMASK = exports.UINT32_BITS = void 0;
const limit_order_protocol_const_1 = require("../limit-order-protocol.const");
exports.UINT32_BITS = BigInt(32);
exports.UINT32_BITMASK = BigInt('0xFFFFFFFF');
exports.UINT16_BITMASK = BigInt('0xFFFF');
exports.UINT40_BITMASK = BigInt('0xFFFFFFFFFF');
exports.UINT48_BITMASK = BigInt('0xFFFFFFFFFFFF');
exports.ADDRESS_MASK = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');
function trim0x(hexString) {
    if (hexString.startsWith('0x')) {
        return hexString.substring(2);
    }
    return hexString;
}
exports.trim0x = trim0x;
function getOffsets(data) {
    const cumulativeSum = ((sum) => (value) => {
        sum += value;
        return sum;
    })(BigInt(0));
    return data
        .map((hex) => {
        if (hex.startsWith(limit_order_protocol_const_1.ZX))
            return BigInt(hex.length / 2 - 1);
        return BigInt(hex.length / 2);
    })
        .map(cumulativeSum)
        .reduce((bytesAccumularot, offset, index) => {
        return bytesAccumularot + (BigInt(offset) << ((exports.UINT32_BITS * BigInt(index))));
    }, BigInt(0))
        .toString();
}
exports.getOffsets = getOffsets;
function parseInteractionForField(offsets, interactions, field) {
    const { fromByte, toByte } = getOffsetForInteraction(offsets, field);
    return '0x' + trim0x(interactions).slice(fromByte * 2, toByte * 2);
}
exports.parseInteractionForField = parseInteractionForField;
function getOffsetForInteraction(offsets, field) {
    const fromByteBN = field === 0
        ? '0'
        : offsets >> BigInt((field - 1) * 32) & exports.UINT32_BITMASK;
    const toByteBN = offsets >> BigInt(field * 32) & exports.UINT32_BITMASK;
    return {
        fromByte: parseInt(fromByteBN.toString()),
        toByte: parseInt(toByteBN.toString())
    };
}
function getMakingAmountForRFQ(amount) {
    return setN(BigInt(amount), 255, true).toString();
}
exports.getMakingAmountForRFQ = getMakingAmountForRFQ;
function setN(value, bitNumber, flag) {
    const bit = flag ? 1 : 0;
    return value | (BigInt(bit) << BigInt(bitNumber));
}
exports.TIMESTAMP_AND_NOUNCE_SELECTOR = '2cc2878d'; // timestampBelowAndNonceEquals(uint256)
exports.ARBITRARY_STATIC_CALL_SELECTOR = '7638f1fe'; // timestampBelowAndNonceEquals(uint256)
const TIMESTAMP_AND_NOUNCE_ARGS_SIZE = 256 / 4;
const PREDICATE_REGEX = new RegExp(`^\\w*${exports.TIMESTAMP_AND_NOUNCE_SELECTOR}`, 'g');
/**
 *
 * @param calldata Any variant of calldata, such as
 * - complete predicate
 * - full method calldata
 * - arguments calldata
 * - argument value as hex or bigint
 * @param isSeriesNonceManager Omit if you dont know exacly.
 * Loose `arbitraryStaticCall` check will be performed
 * @returns
 */
// eslint-disable-next-line max-lines-per-function
function unpackTimestampAndNoncePredicate(calldata, isSeriesNonceManager = null) {
    const hex = trim0x(typeof calldata === 'string'
        ? calldata
        : BigInt(calldata).toString(16));
    const timeNonceSeriesAccount = hex.length <= TIMESTAMP_AND_NOUNCE_ARGS_SIZE
        ? hex
        : hex.replace(PREDICATE_REGEX, '').substring(0, TIMESTAMP_AND_NOUNCE_ARGS_SIZE);
    const timeNonceAccount = BigInt(limit_order_protocol_const_1.ZX + timeNonceSeriesAccount);
    const arbitraryStaticCallIndex = hex.indexOf(exports.ARBITRARY_STATIC_CALL_SELECTOR);
    if (isSeriesNonceManager
        || (isSeriesNonceManager !== null
            && arbitraryStaticCallIndex < hex.indexOf(exports.TIMESTAMP_AND_NOUNCE_SELECTOR))) {
        return {
            address: limit_order_protocol_const_1.ZX + (timeNonceAccount >> BigInt(0) & exports.ADDRESS_MASK).toString(16),
            series: timeNonceAccount >> BigInt(160) & exports.UINT16_BITMASK,
            nonce: timeNonceAccount >> BigInt(160 + 16) & exports.UINT40_BITMASK,
            timestamp: timeNonceAccount >> BigInt(160 + 16 + 40) & exports.UINT40_BITMASK,
        };
    }
    return {
        address: limit_order_protocol_const_1.ZX + (timeNonceAccount >> BigInt(0) & exports.ADDRESS_MASK).toString(16),
        nonce: timeNonceAccount >> BigInt(160) & exports.UINT48_BITMASK,
        timestamp: timeNonceAccount >> BigInt(208) & exports.UINT48_BITMASK,
    };
}
exports.unpackTimestampAndNoncePredicate = unpackTimestampAndNoncePredicate;
function setBit(num, bitPosition, bitValue) {
    if (bitValue) {
        return BigInt(num) | (BigInt(1) << BigInt(bitPosition));
    }
    else {
        return BigInt(num) & (~(BigInt(1) << BigInt(bitPosition)));
    }
}
function packSkipPermitAndThresholdAmount(thresholdAmount, skipPermit) {
    const thresholdBigInt = BigInt(thresholdAmount);
    const skipPermitAndThresholdAmount = setBit(thresholdBigInt, 255, skipPermit);
    return '0x' + skipPermitAndThresholdAmount.toString(16);
}
exports.packSkipPermitAndThresholdAmount = packSkipPermitAndThresholdAmount;
function extractWeb3OriginalErrorData(error) {
    if (error && typeof error !== 'string' && error.data) {
        return error.data;
    }
    const message = (error && typeof error !== 'string')
        ? error.message
        : error;
    const bracesIndexStart = message.indexOf('{');
    const bracesIndexEnd = message.lastIndexOf('}');
    if ((bracesIndexStart + 1) && (bracesIndexEnd + 1)) {
        try {
            const json = JSON.parse(message.substring(bracesIndexStart, bracesIndexEnd + 1));
            if (json.originalError) {
                return json.originalError.data;
            }
            else if (json.data) {
                return json.data;
            }
            return null;
        }
        catch (e) {
            return null;
        }
    }
    if (message.startsWith(limit_order_protocol_const_1.ZX)) {
        return message;
    }
    return null;
}
exports.extractWeb3OriginalErrorData = extractWeb3OriginalErrorData;
//# sourceMappingURL=limit-order.utils.js.map