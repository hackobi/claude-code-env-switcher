"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderPredicateDecoders = void 0;
const limit_order_decoder_1 = require("../../limit-order.decoder");
const limit_order_predicate_decoder_1 = require("../../limit-order-predicate.decoder");
const limit_order_utils_1 = require("../limit-order.utils");
class LimitOrderPredicateDecoders {
    constructor() {
        this.or = this.logicalDecoder;
        this.and = this.logicalDecoder;
        this.lt = this.comparingDecoder;
        this.gt = this.comparingDecoder;
        this.eq = this.comparingDecoder;
    }
    arbitraryStaticCall(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            target: new limit_order_predicate_decoder_1.PredicateBytes(data.target, contract),
            data: new limit_order_predicate_decoder_1.DecodableCall(data.data, data.target),
        }, contract);
    }
    timestampBelow(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            timestamp: new limit_order_predicate_decoder_1.PredicateBytes(data.time, contract),
        }, contract);
    }
    timestampBelowAndNonceEquals(fn, data, contract) {
        const { address, nonce, timestamp, } = limit_order_utils_1.unpackTimestampAndNoncePredicate(data.timeNonceAccount.toHexString(), false);
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            timestamp: new limit_order_predicate_decoder_1.PredicateBytes(timestamp.toString(), contract),
            address: new limit_order_predicate_decoder_1.PredicateBytes(address, contract),
            nonce: new limit_order_predicate_decoder_1.PredicateBytes(nonce.toString(), contract),
        }, contract);
    }
    nonceEquals(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            makerAddress: new limit_order_predicate_decoder_1.PredicateBytes(data.makerAddress, contract),
            nonce: new limit_order_predicate_decoder_1.PredicateBytes(data.makerNonce.toHexString(), contract),
        }, contract);
    }
    nonce(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            makerAddress: new limit_order_predicate_decoder_1.PredicateBytes(data[0], contract),
        }, contract);
    }
    logicalDecoder(fn, data, contract) {
        const args = limit_order_decoder_1.LimitOrderDecoder.unpackStaticCalls(data.offsets, data.data);
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, args.map(calldata => new limit_order_predicate_decoder_1.DecodableCall(calldata, contract)), contract);
    }
    comparingDecoder(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            value: new limit_order_predicate_decoder_1.PredicateBytes(data.value.toString(), contract),
            data: new limit_order_predicate_decoder_1.DecodableCall(data.data, contract),
        }, contract);
    }
}
exports.LimitOrderPredicateDecoders = LimitOrderPredicateDecoders;
//# sourceMappingURL=limit-order-predicate-decoders.js.map