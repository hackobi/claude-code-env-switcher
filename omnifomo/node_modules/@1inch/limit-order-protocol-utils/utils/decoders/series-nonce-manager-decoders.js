"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeriesNonceManagerDecoders = void 0;
const limit_order_predicate_decoder_1 = require("../../limit-order-predicate.decoder");
const limit_order_utils_1 = require("../limit-order.utils");
class SeriesNonceManagerDecoders {
    timestampBelowAndNonceEquals(fn, data, contract) {
        const { address, nonce, series, timestamp, } = limit_order_utils_1.unpackTimestampAndNoncePredicate(data.timeNonceSeriesAccount.toHexString(), true);
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            series: new limit_order_predicate_decoder_1.PredicateBytes(series.toString(), contract),
            timestamp: new limit_order_predicate_decoder_1.PredicateBytes(timestamp.toString(), contract),
            address: new limit_order_predicate_decoder_1.PredicateBytes(address, contract),
            nonce: new limit_order_predicate_decoder_1.PredicateBytes(nonce.toString(), contract),
        }, contract);
    }
    timestampBelow(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            timestamp: new limit_order_predicate_decoder_1.PredicateBytes(data.time.toHexString(), contract),
        }, contract);
    }
    nonceEquals(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            makerAddress: new limit_order_predicate_decoder_1.PredicateBytes(data.makerAddress, contract),
            nonce: new limit_order_predicate_decoder_1.PredicateBytes(data.makerNonce.toHexString(), contract),
        }, contract);
    }
    nonce(fn, data, contract) {
        return new limit_order_predicate_decoder_1.PredicateFn(fn.name, {
            makerAddress: new limit_order_predicate_decoder_1.PredicateBytes(data[0], contract),
        }, contract);
    }
}
exports.SeriesNonceManagerDecoders = SeriesNonceManagerDecoders;
//# sourceMappingURL=series-nonce-manager-decoders.js.map