import { ChainId, Interactions, LimitOrder, LimitOrderData, LimitOrderHash, LimitOrderInteractions, LimitOrderProtocolMethods, LimitOrderSignature, RFQOrder, RFQOrderData } from './model/limit-order-protocol.model';
import { EIP712TypedData } from './model/eip712.model';
import { ProviderConnector } from './connector/provider.connector';
export declare function generateOrderSalt(): string;
export declare function generateRFQOrderInfo(id: number, expiresInTimestamp: number, wrapEth: boolean): string;
export declare class LimitOrderBuilder {
    private readonly contractAddress;
    private readonly chainId;
    private readonly providerConnector;
    private readonly generateSalt;
    constructor(contractAddress: string, chainId: ChainId | number, providerConnector: ProviderConnector, generateSalt?: typeof generateOrderSalt);
    static packInteractions({ makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preInteraction, postInteraction, }: Partial<Interactions>): LimitOrderInteractions;
    static joinStaticCalls(data: string[]): {
        offsets: string;
        data: string;
    };
    buildOrderSignature(walletAddress: string, typedData: EIP712TypedData): Promise<LimitOrderSignature>;
    buildLimitOrderHash(orderTypedData: EIP712TypedData): LimitOrderHash;
    buildLimitOrderTypedData(order: LimitOrder, domainName?: string): EIP712TypedData;
    buildRFQOrderTypedData(order: RFQOrder, domainName?: string): EIP712TypedData;
    buildRFQOrder({ id, wrapEth, expiresInTimestamp, makerAssetAddress, takerAssetAddress, makerAddress, allowedSender, makingAmount, takingAmount, }: RFQOrderData): RFQOrder;
    /**
     * @param allowedSender formerly `takerAddress`
     * @returns
     */
    buildLimitOrder({ makerAssetAddress, takerAssetAddress, makerAddress, receiver, allowedSender, makingAmount, takingAmount, predicate, permit, getMakingAmount, getTakingAmount, preInteraction, postInteraction, salt, }: LimitOrderData): LimitOrder;
    getContractCallData(methodName: LimitOrderProtocolMethods, methodParams?: unknown[]): string;
    /**
     * Get nonce from contract (nonce method) and put it to predicate on order creating
     */
    getCustomAmountData(methodName: LimitOrderProtocolMethods, makingAmount: string, takingAmount: string, swapTakerAmount?: string): string;
}
