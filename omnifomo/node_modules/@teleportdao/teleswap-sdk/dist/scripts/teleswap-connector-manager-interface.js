"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonTeleswapConnectorManager = exports.EthTeleswapConnectorManager = void 0;
const web3_1 = __importDefault(require("web3"));
const contracts_helper_1 = require("@teleportdao/contracts-helper");
const teleswap_connector_manager_1 = require("../constants/teleswap-connector-manager");
const eth_utils_1 = require("../utils/eth-utils");
const teleswap_1 = require("../abis/teleswap");
const utils_1 = require("@src/types/utils");
const abiUtils = new web3_1.default().eth.abi;
class EthTeleswapConnectorManager extends contracts_helper_1.contracts.BaseContract {
    static DecodeMsgSent(functionName, data) {
        if (functionName in teleswap_connector_manager_1.messagesType) {
            let decodedMessage = (0, utils_1.convertBigIntToString)(abiUtils.decodeParameters(teleswap_connector_manager_1.messagesType[functionName], data));
            return (0, eth_utils_1.deleteEventNumbers)(decodedMessage);
        }
    }
}
exports.EthTeleswapConnectorManager = EthTeleswapConnectorManager;
class PolygonTeleswapConnectorManager extends contracts_helper_1.contracts.BaseContract {
    constructor(connectionConfig, contractAddress) {
        super(connectionConfig, contractAddress, teleswap_1.PolyConnectorABI);
    }
    static DecodeMsgReceived(functionName, data) {
        if (functionName in teleswap_connector_manager_1.messagesType) {
            let decodedData = (0, utils_1.convertBigIntToString)(abiUtils.decodeParameters(teleswap_connector_manager_1.messagesType[functionName], data));
            return (0, eth_utils_1.deleteEventNumbers)(decodedData);
        }
    }
    withdrawFundsToSourceChain(message, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethod('withdrawFundsToSourceChain', '0', [
                message,
                signature.v,
                signature.r,
                signature.s,
            ]);
        });
    }
    retrySwapAndUnwrap(message, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethod('retrySwapAndUnwrap', '0', [
                message,
                signature.v,
                signature.r,
                signature.s,
            ]);
        });
    }
    withdrawFundsToSourceChainAdmin(user, tokenAddress, chainId, uniqueCounter, relayerFeePercentage = '0') {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethod('withdrawFundsToSourceChainByOwnerOrAdmin', '0', [
                user,
                chainId.toString(),
                uniqueCounter.toString(),
                tokenAddress,
                relayerFeePercentage,
            ]);
        });
    }
}
exports.PolygonTeleswapConnectorManager = PolygonTeleswapConnectorManager;
//# sourceMappingURL=teleswap-connector-manager-interface.js.map