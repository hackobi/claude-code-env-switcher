"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractUnwrapFeeFromAllFee = exports.extractWrapFeeFromAllFee = exports.getMinUnwrapAmount = exports.getMinWrapAmount = exports.calculateUnwrapFee = exports.calculateWrapFee = exports.getWrapFeeParams = exports.getUnwrapFeeParams = exports.getFeeParams = exports.getThirdPartyFee = void 0;
const bignumber_js_1 = require("bignumber.js");
const contracts_helper_1 = require("@teleportdao/contracts-helper");
const configs_1 = require("@teleportdao/configs");
const helper_1 = require("../utils/helper");
const { BitcoinRelay, CcTransferRouter, CcExchangeRouter, CcBurnRouter, LockerContract } = contracts_helper_1.contracts;
function getThirdPartyFee(thirdPartyId, targetNetworkConnectionInfo) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const testnet = ((_a = targetNetworkConnectionInfo.networkName) === null || _a === void 0 ? void 0 : _a.includes("testnet")) || false;
        let networkName = (_b = targetNetworkConnectionInfo.networkName) === null || _b === void 0 ? void 0 : _b.replace("_testnet", "");
        let contractAddresses = testnet
            ? configs_1.teleswap.contracts[networkName].testnet
            : configs_1.teleswap.contracts[networkName].mainnet;
        let ccBurn = new CcBurnRouter(targetNetworkConnectionInfo, contractAddresses.ccBurnAddress);
        let ccExchange = new CcExchangeRouter(targetNetworkConnectionInfo, contractAddresses.ccExchangeAddress);
        const ccBurnThirdIdFee = yield ccBurn.thirdPartyFee(thirdPartyId);
        const ccExchangeThirdIdFee = yield ccExchange.thirdPartyFee(thirdPartyId);
        return {
            unwrapFee: +ccBurnThirdIdFee.toString() / 100,
            wrapFee: +ccExchangeThirdIdFee.toString() / 100,
        };
    });
}
exports.getThirdPartyFee = getThirdPartyFee;
function getFeeParams(targetNetworkConnectionInfo) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const testnet = ((_a = targetNetworkConnectionInfo.networkName) === null || _a === void 0 ? void 0 : _a.includes("testnet")) || false;
        let networkName = (_b = targetNetworkConnectionInfo.networkName) === null || _b === void 0 ? void 0 : _b.replace("_testnet", "");
        let contractAddresses = testnet
            ? configs_1.teleswap.contracts[networkName].testnet
            : configs_1.teleswap.contracts[networkName].mainnet;
        let { baseEth, connectionConfig } = (0, helper_1.getWeb3Eth)(targetNetworkConnectionInfo);
        let relay = new BitcoinRelay(connectionConfig, contractAddresses.relayAddress);
        let ccTransfer = new CcTransferRouter(connectionConfig, contractAddresses.ccTransferAddress);
        let ccExchange = new CcExchangeRouter(connectionConfig, contractAddresses.ccExchangeAddress);
        let locker = new LockerContract(connectionConfig, contractAddresses.lockerAddress);
        let ccBurn = new CcBurnRouter(connectionConfig, contractAddresses.ccBurnAddress);
        const lockerPercentageFee = +((yield locker.getLockerPercentageFee()).toString() || 0) / 100;
        let gasPrice = (yield baseEth.web3Eth.getGasPrice()).toString();
        let lastRelayBlockFeeWei = (yield relay.getLastBlockFee()).toString();
        const gasUsedWrap = 460000;
        const gasUsedWrapAndSwap = 560000;
        const protocolPercentageFeeCCTransfer = +((yield ccTransfer.getProtocolPercentageFee()).toString() || 0).toString() / 100;
        const protocolPercentageFeeCCExchange = +((yield ccExchange.getProtocolPercentageFee()).toString() || 0) / 100;
        const protocolPercentageFeeCCBurn = +((yield ccBurn.getProtocolPercentageFee()).toString() || 0) / 100;
        const burnBitcoinFeeSatoshi = +((yield ccBurn.getBitcoinFee()).toString() || 0).toString();
        return {
            gasPrice,
            lastRelayBlockFeeWei,
            lockerPercentageFee,
            protocolPercentageFeeCCTransfer,
            protocolPercentageFeeCCExchange,
            protocolPercentageFeeCCBurn,
            burnBitcoinFeeSatoshi,
            gasUsedWrap,
            gasUsedWrapAndSwap,
        };
    });
}
exports.getFeeParams = getFeeParams;
function getUnwrapFeeParams(targetNetworkConnectionInfo) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const testnet = ((_a = targetNetworkConnectionInfo.networkName) === null || _a === void 0 ? void 0 : _a.includes("testnet")) || false;
        let networkName = (_b = targetNetworkConnectionInfo.networkName) === null || _b === void 0 ? void 0 : _b.replace("_testnet", "");
        let contractAddresses = testnet
            ? configs_1.teleswap.contracts[networkName].testnet
            : configs_1.teleswap.contracts[networkName].mainnet;
        let { connectionConfig } = (0, helper_1.getWeb3Eth)(targetNetworkConnectionInfo);
        let locker = new LockerContract(connectionConfig, contractAddresses.lockerAddress);
        let ccBurn = new CcBurnRouter(connectionConfig, contractAddresses.ccBurnAddress);
        const lockerPercentageFee = +((yield locker.getLockerPercentageFee()).toString() || 0) / 100;
        const protocolPercentageFee = +((yield ccBurn.getProtocolPercentageFee()).toString() || 0) / 100;
        const burnBitcoinFeeSatoshi = +((yield ccBurn.getBitcoinFee()).toString() || 0).toString();
        return {
            lockerPercentageFee,
            protocolPercentageFee,
            burnBitcoinFeeSatoshi,
        };
    });
}
exports.getUnwrapFeeParams = getUnwrapFeeParams;
function getWrapFeeParams(type, targetNetworkConnectionInfo) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const testnet = ((_a = targetNetworkConnectionInfo.networkName) === null || _a === void 0 ? void 0 : _a.includes("testnet")) || false;
        let networkName = (_b = targetNetworkConnectionInfo.networkName) === null || _b === void 0 ? void 0 : _b.replace("_testnet", "");
        let contractAddresses = testnet
            ? configs_1.teleswap.contracts[networkName].testnet
            : configs_1.teleswap.contracts[networkName].mainnet;
        let { baseEth, connectionConfig } = (0, helper_1.getWeb3Eth)(targetNetworkConnectionInfo);
        let relay = new BitcoinRelay(connectionConfig, contractAddresses.relayAddress);
        let ccTransfer = new CcTransferRouter(connectionConfig, contractAddresses.ccTransferAddress);
        let ccExchange = new CcExchangeRouter(connectionConfig, contractAddresses.ccExchangeAddress);
        let locker = new LockerContract(connectionConfig, contractAddresses.lockerAddress);
        const lockerPercentageFee = +((yield locker.getLockerPercentageFee()).toString() || 0) / 100;
        let gasPrice = (yield baseEth.web3Eth.getGasPrice()).toString();
        let lastRelayBlockFeeWei = (yield relay.getLastBlockFee()).toString();
        const gasUsed = type === "Wrap" ? 460000 : 560000;
        const protocolPercentageFee = type === "Wrap"
            ? +((yield ccTransfer.getProtocolPercentageFee()).toString() || 0) / 100
            : +((yield ccExchange.getProtocolPercentageFee()).toString() || 0) / 100;
        return {
            lockerPercentageFee,
            protocolPercentageFee,
            gasPrice,
            gasUsed,
            lastRelayBlockFeeWei,
        };
    });
}
exports.getWrapFeeParams = getWrapFeeParams;
function calculateWrapFee(amountBTC, feeInfo, isInstant = false, isReceivedAmount = false, minimumNetworkFee = 0.00001, teleporterFeeRatio = 1.5) {
    const baseTeleporterFeeBTC = (0, bignumber_js_1.BigNumber)(feeInfo.gasPrice)
        .multipliedBy(feeInfo.gasUsed)
        .dividedBy(1e18)
        .multipliedBy(feeInfo.nativeTokenBTCRate)
        .toFixed(8);
    const relayFeeBTC = new bignumber_js_1.BigNumber(feeInfo.lastRelayBlockFeeWei)
        .dividedBy(1e18)
        .multipliedBy(feeInfo.nativeTokenBTCRate)
        .toFixed(8);
    const networkFeeBTC = bignumber_js_1.BigNumber.max(new bignumber_js_1.BigNumber(baseTeleporterFeeBTC).plus(relayFeeBTC).multipliedBy(teleporterFeeRatio), minimumNetworkFee).toFixed(8);
    let inputAmountBTC = isReceivedAmount
        ? new bignumber_js_1.BigNumber(amountBTC)
            .plus(networkFeeBTC)
            .dividedBy(100 - +feeInfo.protocolPercentageFee - +feeInfo.lockerPercentageFee)
            .multipliedBy(100)
            .toFixed(8)
        : amountBTC;
    const thirdPartyFeeBTC = new bignumber_js_1.BigNumber(feeInfo.thirdPartyPercentageFee || 0)
        .dividedBy(100)
        .multipliedBy(inputAmountBTC)
        .toFixed(8);
    const protocolFeeBTC = new bignumber_js_1.BigNumber(feeInfo.protocolPercentageFee)
        .dividedBy(100)
        .multipliedBy(inputAmountBTC)
        .toFixed(8);
    const lockerFeeBTC = new bignumber_js_1.BigNumber(feeInfo.lockerPercentageFee)
        .dividedBy(100)
        .multipliedBy(inputAmountBTC)
        .toFixed(8);
    const fillerFeeBTC = isInstant
        ? new bignumber_js_1.BigNumber(feeInfo.fillerPercentageFee || 0)
            .dividedBy(100)
            .multipliedBy(inputAmountBTC)
            .toFixed(8)
        : "0";
    const totalFeeBTC = new bignumber_js_1.BigNumber(networkFeeBTC)
        .plus(protocolFeeBTC)
        .plus(lockerFeeBTC)
        .plus(thirdPartyFeeBTC)
        .plus(fillerFeeBTC)
        .toFixed(8);
    const receivedAmountBTC = new bignumber_js_1.BigNumber(inputAmountBTC).minus(totalFeeBTC).toFixed(8);
    const fee = {
        networkFeeBTC,
        protocolFeeBTC,
        lockerFeeBTC,
        thirdPartyFeeBTC,
        fillerFeeBTC,
        totalFeeBTC,
    };
    let resp = {
        message: "",
        success: true,
        fee,
        amount: {
            inputAmountBTC,
            receivedAmountBTC,
        },
    };
    if (+receivedAmountBTC < +0) {
        return Object.assign(Object.assign({}, resp), { success: false, message: "received amount should be greater than 0" });
    }
    return resp;
}
exports.calculateWrapFee = calculateWrapFee;
function calculateUnwrapFee(amountBTC, feeInfo, isReceivedAmount = false) {
    const networkFeeBTC = new bignumber_js_1.BigNumber(feeInfo.burnBitcoinFeeSatoshi).dividedBy(1e8).toFixed(8);
    let inputAmountBTC = isReceivedAmount
        ? new bignumber_js_1.BigNumber(amountBTC)
            .plus(networkFeeBTC)
            .plus(+networkFeeBTC * (+feeInfo.lockerPercentageFee / 100))
            .dividedBy(100 -
            +feeInfo.protocolPercentageFee -
            +(feeInfo.thirdPartyPercentageFee || 0) -
            +feeInfo.lockerPercentageFee -
            (+feeInfo.lockerPercentageFee * +feeInfo.protocolPercentageFee) / 100 -
            (+feeInfo.lockerPercentageFee * +(feeInfo.thirdPartyPercentageFee || 0)) / 100)
            .multipliedBy(100)
            .toFixed(8)
        : amountBTC;
    const protocolFeeBTC = new bignumber_js_1.BigNumber(feeInfo.protocolPercentageFee)
        .dividedBy(100)
        .multipliedBy(inputAmountBTC)
        .toFixed(8);
    const thirdPartyFeeBTC = new bignumber_js_1.BigNumber(feeInfo.thirdPartyPercentageFee || 0)
        .dividedBy(100)
        .multipliedBy(inputAmountBTC)
        .toFixed(8);
    const remain1 = new bignumber_js_1.BigNumber(inputAmountBTC)
        .minus(protocolFeeBTC)
        .minus(thirdPartyFeeBTC)
        .minus(networkFeeBTC)
        .toString();
    const lockerFeeBTC = new bignumber_js_1.BigNumber(feeInfo.lockerPercentageFee)
        .dividedBy(100)
        .multipliedBy(remain1)
        .toFixed(8);
    const totalFeeBTC = new bignumber_js_1.BigNumber(networkFeeBTC)
        .plus(protocolFeeBTC)
        .plus(lockerFeeBTC)
        .plus(thirdPartyFeeBTC)
        .toFixed(8);
    const receivedAmountBTC = new bignumber_js_1.BigNumber(inputAmountBTC).minus(totalFeeBTC).toFixed(8);
    const fee = {
        networkFeeBTC,
        protocolFeeBTC,
        lockerFeeBTC,
        thirdPartyFeeBTC,
        totalFeeBTC,
    };
    let resp = {
        message: "",
        success: true,
        fee,
        amount: {
            inputAmountBTC,
            receivedAmountBTC,
        },
    };
    if (+receivedAmountBTC < +0) {
        return Object.assign(Object.assign({}, resp), { success: false, message: "received amount should be greater than 0" });
    }
    return resp;
}
exports.calculateUnwrapFee = calculateUnwrapFee;
function getMinWrapAmount(feeInfo, isInstant = false, minimumReceiveAmount = 0.00001, ratio = 1.5) {
    const response = calculateWrapFee(minimumReceiveAmount, feeInfo, isInstant, true);
    return (0, bignumber_js_1.BigNumber)(response.amount.inputAmountBTC).multipliedBy(ratio).toFixed(8);
}
exports.getMinWrapAmount = getMinWrapAmount;
function getMinUnwrapAmount(feeInfo, minimumReceiveAmount = 0.00001, ratio = 1.5) {
    const response = calculateUnwrapFee(Math.max(minimumReceiveAmount, +feeInfo.burnBitcoinFeeSatoshi / 1e8), feeInfo, true);
    return (0, bignumber_js_1.BigNumber)(response.amount.inputAmountBTC).multipliedBy(ratio).toFixed(8);
}
exports.getMinUnwrapAmount = getMinUnwrapAmount;
function extractWrapFeeFromAllFee(type, feeParams, thirdPartyPercentageFee = 0) {
    return {
        lockerPercentageFee: feeParams.lockerPercentageFee,
        protocolPercentageFee: type === "Wrap"
            ? feeParams.protocolPercentageFeeCCTransfer
            : feeParams.protocolPercentageFeeCCExchange,
        burnBitcoinFeeSatoshi: feeParams.burnBitcoinFeeSatoshi,
        thirdPartyPercentageFee,
        lastRelayBlockFeeWei: feeParams.lastRelayBlockFeeWei,
        gasPrice: feeParams.gasPrice,
        gasUsed: type === "Wrap" ? feeParams.gasUsedWrap : feeParams.gasUsedWrapAndSwap,
        fillerPercentageFee: feeParams.fillerPercentageFee || "0",
    };
}
exports.extractWrapFeeFromAllFee = extractWrapFeeFromAllFee;
function extractUnwrapFeeFromAllFee(feeParams, thirdPartyPercentageFee = 0) {
    return {
        lockerPercentageFee: feeParams.lockerPercentageFee,
        protocolPercentageFee: feeParams.protocolPercentageFeeCCBurn,
        burnBitcoinFeeSatoshi: feeParams.burnBitcoinFeeSatoshi,
        thirdPartyPercentageFee,
    };
}
exports.extractUnwrapFeeFromAllFee = extractUnwrapFeeFromAllFee;
//# sourceMappingURL=fee-utils.js.map