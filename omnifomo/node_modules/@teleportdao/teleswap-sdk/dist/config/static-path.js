"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUnwrapSwapPathV3 = exports.getSwapPathV3 = void 0;
const web3_utils_1 = require("web3-utils");
const configs_1 = require("@teleportdao/configs");
function getSwapPathV3(networkName, token1Address, token2Address) {
    const token1 = (0, web3_utils_1.toChecksumAddress)(token1Address);
    const token2 = (0, web3_utils_1.toChecksumAddress)(token2Address);
    if (networkName === "polygon") {
        const networkTokens = configs_1.tokens.polygon.mainnet;
        const middleToken = networkTokens.WBTCAddress;
        const nativeToken = networkTokens.WrappedNativeToken;
        const direct = [networkTokens.WETHAddress, networkTokens.USDC_EAddress];
        if (token2 === middleToken) {
            return [token1, middleToken];
        }
        if (direct.includes(token2)) {
            return [token1, middleToken, token2];
        }
        if (token2 === networkTokens.USDTAddress) {
            return [token1, middleToken, networkTokens.USDC_EAddress, token2];
        }
        if (token2 === networkTokens.USDCAddress) {
            return [token1, middleToken, networkTokens.USDC_EAddress, token2];
        }
        if (token2 === nativeToken) {
            return [token1, middleToken, networkTokens.USDC_EAddress, token2];
        }
        return [token1Address, middleToken, token2Address];
    }
    if (networkName === "bsc") {
        const networkTokens = configs_1.tokens.bsc.mainnet;
        const middleToken = networkTokens.BTCBAddress;
        const direct = [
            networkTokens.WETHAddress,
            networkTokens.WBNBAddress,
            networkTokens.USDTAddress,
        ];
        if (token2 === middleToken) {
            return [token1, middleToken];
        }
        if (direct.includes(token2)) {
            return [token1, middleToken, token2];
        }
        if (token2 === networkTokens.USDC_EAddress) {
            return [token1, middleToken, networkTokens.USDTAddress, token2];
        }
        if (token2 === networkTokens.TEST_TSTAddress) {
            return [token1, middleToken, networkTokens.WBNBAddress, token2];
        }
        return [token1Address, middleToken, token2Address];
    }
    if (networkName === "bob") {
        const networkTokens = configs_1.tokens.bob.mainnet;
        const middleToken = networkTokens.WrappedNativeToken;
        if (token2 === middleToken) {
            return [token1, middleToken];
        }
        if (token1 === networkTokens.USDC_EAddress) {
            return [token1, middleToken, networkTokens.WETHAddress, token2];
        }
        if (token1 === networkTokens.USDTAddress) {
            return [token1, middleToken, networkTokens.WETHAddress, token2];
        }
        return [token1, middleToken, token2];
    }
    if (networkName === "bsquared") {
        const networkTokens = configs_1.tokens.bsquared.mainnet;
        const middleToken = networkTokens.WrappedNativeToken;
        if (token2 === middleToken) {
            return [token1, middleToken];
        }
        return [token1, middleToken, token2];
    }
    throw new Error("network not supported");
}
exports.getSwapPathV3 = getSwapPathV3;
function getUnwrapSwapPathV3(networkName, token1Address, token2Address) {
    const token1 = (0, web3_utils_1.toChecksumAddress)(token1Address);
    const token2 = (0, web3_utils_1.toChecksumAddress)(token2Address);
    if (networkName === "polygon") {
        const networkTokens = configs_1.tokens.polygon.mainnet;
        const middleToken = networkTokens.WBTCAddress;
        const nativeToken = networkTokens.WrappedNativeToken;
        const direct = [networkTokens.WETHAddress, networkTokens.USDC_EAddress];
        if (token1 === middleToken) {
            return [middleToken, token2];
        }
        if (direct.includes(token1)) {
            return [token1, middleToken, token2];
        }
        if (token1 === networkTokens.USDTAddress) {
            return [token1, networkTokens.USDC_EAddress, middleToken, token2];
        }
        if (token1 === networkTokens.USDCAddress) {
            return [token1, networkTokens.USDC_EAddress, middleToken, token2];
        }
        if (token1 === nativeToken) {
            return [token1, networkTokens.USDC_EAddress, middleToken, token2];
        }
        return [token1, middleToken, token2];
    }
    if (networkName === "bsc") {
        const networkTokens = configs_1.tokens.bsc.mainnet;
        const middleToken = networkTokens.BTCBAddress;
        const direct = [
            networkTokens.WETHAddress,
            networkTokens.WBNBAddress,
            networkTokens.USDTAddress,
        ];
        if (token1 === middleToken) {
            return [token1, token2];
        }
        if (direct.includes(token1)) {
            return [token1, middleToken, token2];
        }
        if (token1 === networkTokens.USDC_EAddress) {
            return [token1, networkTokens.USDTAddress, middleToken, token2];
        }
        return [token1, middleToken, token2];
    }
    if (networkName === "bob") {
        const networkTokens = configs_1.tokens.bob.mainnet;
        const middleToken = networkTokens.WrappedNativeToken;
        if (token1 === middleToken) {
            return [token1, token2];
        }
        if (token1 === networkTokens.USDC_EAddress) {
            return [token1, networkTokens.WETHAddress, middleToken, token2];
        }
        if (token1 === networkTokens.USDTAddress) {
            return [token1, networkTokens.WETHAddress, middleToken, token2];
        }
        return [token1, middleToken, token2];
    }
    if (networkName === "bsquared") {
        const networkTokens = configs_1.tokens.bsquared.mainnet;
        const middleToken = networkTokens.WrappedNativeToken;
        if (token1 === middleToken) {
            return [token1, token2];
        }
        return [token1, middleToken, token2];
    }
    throw new Error("network not supported");
}
exports.getUnwrapSwapPathV3 = getUnwrapSwapPathV3;
//# sourceMappingURL=static-path.js.map