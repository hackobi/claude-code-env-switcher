"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeleswapSDK = void 0;
const web3_utils_1 = require("web3-utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const contracts_helper_1 = require("@teleportdao/contracts-helper");
const bitcoin_1 = require("@teleportdao/bitcoin");
const ordinal_wallet_1 = __importDefault(require("@teleportdao/bitcoin/dist/ordinal-wallet"));
const configs_1 = require("@teleportdao/configs");
const providers_1 = require("@teleportdao/providers");
const teleswap_scripts_1 = require("./teleswap-scripts");
const static_path_1 = require("./config/static-path");
const cross_chain_tokens_1 = require("./config/cross-chain-tokens");
const teleport_tokens_1 = require("./config/teleport-tokens");
const crosschain_helper_1 = require("./scripts/crosschain-helper");
function increaseNumber(amount, percentage = 20) {
    return new bignumber_js_1.default(amount).multipliedBy(1 + percentage / 100).toFixed(0);
}
class TeleswapSDK {
    constructor(isTestnet = false, sourceNetworkConnection, unisatToken) {
        this.networks = new Map();
        this.crossChainNetworks = new Map();
        this.thirdPartFee = {
            wrapFee: 0,
            unwrapFee: 0,
        };
        this.thirdPartyId = 0;
        this.baseNetworkNames = isTestnet ? ["polygon_testnet"] : configs_1.teleswap.baseNetworks;
        this.crossChainNetworkNames = isTestnet ? ["ethereum_testnet"] : configs_1.teleswap.crossChainNetworks;
        this.isTestnet = isTestnet;
        this.teleportdao = new providers_1.TeleportDao(this.isTestnet);
        this.sourceConnection = sourceNetworkConnection || {
            utxo: {
                provider: "TeleportDao",
            },
        };
        const sourceNetworkName = isTestnet ? "bitcoin_testnet" : "bitcoin";
        this.teleswapWallet = new bitcoin_1.TeleswapWallet(sourceNetworkName, this.sourceConnection);
        this.btcInterface = new bitcoin_1.BitcoinInterface(sourceNetworkName, this.sourceConnection);
        if (unisatToken) {
            this.brc20Wallet = new ordinal_wallet_1.default(sourceNetworkName, unisatToken, sourceNetworkConnection);
        }
        this.isEvmInitialize = false;
        this.isBitcoinInitialize = false;
    }
    setDefaultNetwork(targetNetworkConnection) {
        if (this.baseNetworkNames.includes(targetNetworkConnection.networkName)) {
            if (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.networkName) {
                this.defaultBaseNetwork = targetNetworkConnection.networkName;
            }
            if ((targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.web3) ||
                (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.web3Eth) ||
                (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.provider)) {
                this.addBaseNetwork(targetNetworkConnection);
            }
        }
        else if (this.crossChainNetworkNames.includes(targetNetworkConnection.networkName)) {
            if (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.networkName) {
                this.defaultCrossChainNetwork = targetNetworkConnection.networkName;
                this.defaultBaseNetwork = this.isTestnet ? "polygon_testnet" : "polygon";
            }
            if ((targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.web3) ||
                (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.web3Eth) ||
                (targetNetworkConnection === null || targetNetworkConnection === void 0 ? void 0 : targetNetworkConnection.provider)) {
                this.addCrossChainNetwork(targetNetworkConnection);
            }
        }
        else {
            throw new Error("network not supported");
        }
    }
    initNetworksConnection(networkConnectionInfos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet) {
                throw new Error("cant initialize testnet networks");
            }
            const networks = yield this.teleportdao.getNetworkRpc();
            for (let networkName of Object.keys(networks)) {
                const inputConnection = networkConnectionInfos.find((n) => n.networkName === networkName);
                const targetNetworkConnection = inputConnection || {
                    web3: {
                        url: networks[networkName],
                    },
                    networkName: networkName,
                };
                this.addNetwork(targetNetworkConnection);
            }
        });
    }
    addBaseNetwork(targetNetworkConnection) {
        var _a, _b, _c, _d;
        if (!this.baseNetworkNames.includes(targetNetworkConnection.networkName)) {
            throw new Error("network not supported");
        }
        const { connectionConfig, baseEth } = teleswap_scripts_1.TeleswapScripts.getWeb3Eth(targetNetworkConnection);
        const isTargetTestnet = targetNetworkConnection.networkName.includes("_testnet");
        const networkChainInfo = configs_1.chainInfo[targetNetworkConnection.networkName];
        const targetConnection = Object.assign({ networkName: targetNetworkConnection.networkName }, connectionConfig);
        const teleswapScript = new teleswap_scripts_1.TeleswapScripts(targetConnection, this.sourceConnection);
        const networkName = targetNetworkConnection.networkName.replace("_testnet", "");
        const teleswapContractAddresses = isTargetTestnet
            ? configs_1.teleswap.contracts[networkName].testnet
            : configs_1.teleswap.contracts[networkName].mainnet;
        let brc20ContractAddresses;
        if (networkName === "bsc") {
            brc20ContractAddresses = isTargetTestnet
                ? configs_1.brc20.contracts.bsc.testnet
                : configs_1.brc20.contracts.bsc.mainnet;
        }
        const tokenAddress = isTargetTestnet
            ? configs_1.teleswap.tokens[networkName].testnet
            : configs_1.teleswap.tokens[networkName].mainnet;
        const networkConnector = isTargetTestnet
            ? (_b = (_a = configs_1.teleswap.connectors[networkName]) === null || _a === void 0 ? void 0 : _a.testnet) === null || _b === void 0 ? void 0 : _b.connectorAddress
            : (_d = (_c = configs_1.teleswap.connectors[networkName]) === null || _c === void 0 ? void 0 : _c.mainnet) === null || _d === void 0 ? void 0 : _d.connectorAddress;
        const contractAddress = {
            uniswapV3Connector: teleswapContractAddresses.uniswapV3ConnectorAddress,
            uniswapV2Connector: teleswapContractAddresses.uniswapV2ConnectorAddress,
            uniswapV2FactoryV2Address: teleswapContractAddresses.uniswapV2FactoryAddress,
            uniswapV2RouterV2Address: teleswapContractAddresses.uniswapV2RouterAddress,
            networkConnector,
        };
        const network = {
            networkName,
            baseEth,
            networkChainInfo,
            teleswapScript,
            targetConnectionConfig: targetConnection,
            contracts: this.getContracts(targetConnection, Object.assign(Object.assign({}, teleswapContractAddresses), { brc20RouterAddress: brc20ContractAddresses === null || brc20ContractAddresses === void 0 ? void 0 : brc20ContractAddresses.brc20Router }), tokenAddress),
            tokenAddress,
            contractAddress,
        };
        this.networks.set(networkName, network);
    }
    addCrossChainNetwork(targetNetworkConnection) {
        if (!this.crossChainNetworkNames.includes(targetNetworkConnection.networkName)) {
            throw new Error("network not supported");
        }
        const { connectionConfig, baseEth } = teleswap_scripts_1.TeleswapScripts.getWeb3Eth(targetNetworkConnection);
        const isTargetTestnet = targetNetworkConnection.networkName.includes("_testnet");
        const networkChainInfo = configs_1.chainInfo[targetNetworkConnection.networkName];
        const targetConnection = Object.assign({ networkName: targetNetworkConnection.networkName }, connectionConfig);
        const teleswapScript = new teleswap_scripts_1.TeleswapScripts(targetConnection, this.sourceConnection);
        const networkName = targetNetworkConnection.networkName.replace("_testnet", "");
        const connectorAddresses = isTargetTestnet
            ? configs_1.teleswap.connectors[networkName].testnet
            : configs_1.teleswap.connectors[networkName].mainnet;
        const tokenAddress = {};
        const contractAddress = {};
        const network = {
            networkName,
            baseEth,
            networkChainInfo,
            teleswapScript,
            targetConnectionConfig: targetConnection,
            contracts: this.getCrossChainContracts(targetConnection, {
                teleswapEthConnector: connectorAddresses.connectorAddress,
            }, tokenAddress),
            contractAddress,
            tokenAddress,
        };
        this.crossChainNetworks.set(networkName, network);
    }
    addNetwork(targetNetworkConnection) {
        if (this.baseNetworkNames.includes(targetNetworkConnection.networkName)) {
            this.addBaseNetwork(targetNetworkConnection);
        }
        else if (this.crossChainNetworkNames.includes(targetNetworkConnection.networkName)) {
            this.addCrossChainNetwork(targetNetworkConnection);
        }
        else {
            throw new Error("network not supported");
        }
    }
    getContracts(connectionConfig, contractAddresses, tokenAddresses) {
        const ccTransfer = new contracts_helper_1.contracts.CcTransferRouter(connectionConfig, contractAddresses.ccTransferAddress);
        const ccExchange = new contracts_helper_1.contracts.CcExchangeRouter(connectionConfig, contractAddresses.ccExchangeAddress);
        const burnContract = new contracts_helper_1.contracts.CcBurnRouter(connectionConfig, contractAddresses.ccBurnAddress);
        const lockerContract = new contracts_helper_1.contracts.LockerContract(connectionConfig, contractAddresses.lockerAddress);
        const teleBTC = new contracts_helper_1.contracts.ERC20(connectionConfig, tokenAddresses.teleBTCAddress, 8);
        const brc20router = contractAddresses.brc20RouterAddress
            ? new contracts_helper_1.contracts.Brc20.BRC20(connectionConfig, contractAddresses.brc20RouterAddress)
            : undefined;
        const uniswapV2Factory = new contracts_helper_1.contracts.UniSwapV2Factory(connectionConfig, contractAddresses.uniswapV2FactoryAddress);
        const uniswapV2Router = new contracts_helper_1.contracts.UniSwapV2Router(connectionConfig, contractAddresses.uniswapV2RouterAddress);
        const uniswapV2Connector = new contracts_helper_1.contracts.UniswapV2Connector(connectionConfig, contractAddresses.uniswapV2ConnectorAddress);
        const uniswapV3Connector = new contracts_helper_1.contracts.UniswapV3Connector(connectionConfig, contractAddresses.uniswapV3ConnectorAddress);
        return {
            burnContract,
            lockerContract,
            teleBTC,
            brc20router,
            uniswapV2Factory,
            uniswapV2Router,
            uniswapV2Connector,
            uniswapV3Connector,
            ccTransfer,
            ccExchange,
        };
    }
    getCrossChainContracts(connectionConfig, contractAddresses, tokenAddresses) {
        const teleswapEthConnector = new contracts_helper_1.contracts.EthConnector(connectionConfig, contractAddresses.teleswapEthConnector);
        return {
            teleswapEthConnector,
        };
    }
    isCrossChainNetwork(networkName) {
        return this.crossChainNetworkNames.includes(networkName);
    }
    isBaseNetworkName(networkName) {
        return this.crossChainNetworkNames.includes(networkName);
    }
    get bitcoinAddress() {
        return this.teleswapWallet.bitcoinAddress;
    }
    get bitcoinAddressType() {
        return this.teleswapWallet.currentAccountType;
    }
    initBitcoinAccountUsingMnemonic(mnemonic, addressType = "p2wpkh", index = 0, mnemonicPassword = "") {
        let address = this.teleswapWallet.setAccountPrivateKeyByMnemonic({
            mnemonic,
            mnemonicPassword,
            index,
            addressType,
        });
        this.isBitcoinInitialize = true;
        return address;
    }
    initEvmAccountUsingMnemonic(mnemonic, index = 0, mnemonicPassword = "") {
        let address;
        this.networks.forEach((n) => {
            n.baseEth.addAccountByMnemonic({
                mnemonic,
                mnemonicPassword,
                index,
            });
            if (!n.baseEth.currentAccount)
                throw new Error("account is not initialized correctly");
            if (address && address !== n.baseEth.currentAccount) {
                throw new Error("account is not initialized correctly");
            }
            address = n.baseEth.currentAccount;
            Object.values(n.contracts).forEach((c) => {
                if (c)
                    c.setCurrentAccount(address);
            });
        });
        this.crossChainNetworks.forEach((n) => {
            n.baseEth.addAccountByMnemonic({
                mnemonic,
                mnemonicPassword,
                index,
            });
            if (!n.baseEth.currentAccount)
                throw new Error("account is not initialized correctly");
            if (address && address !== n.baseEth.currentAccount) {
                throw new Error("account is not initialized correctly");
            }
            address = n.baseEth.currentAccount;
            Object.values(n.contracts).forEach((c) => {
                if (c)
                    c.setCurrentAccount(address);
            });
        });
        if (!address)
            throw new Error("account is not initialized correctly");
        this.isEvmInitialize = true;
        this.evmAddress = address;
        return address;
    }
    getNetwork(networkName = this.defaultBaseNetwork) {
        if (!networkName) {
            throw new Error("no network provided");
        }
        const network = this.networks.get(networkName);
        if (!network) {
            throw new Error("network connection information not found");
        }
        return network;
    }
    getCrossChainNetwork(networkName) {
        if (!networkName) {
            throw new Error("no network provided");
        }
        const network = this.crossChainNetworks.get(networkName);
        if (!network) {
            throw new Error("network connection information not found");
        }
        return network;
    }
    selectLocker(amount, type, networkName) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            let data = yield this.teleportdao.selectLocker(network.networkName.replace("_testnet", ""), amount, type);
            const locker = data.preferred;
            if (!locker)
                throw new Error("locker not found or your amount is incorrect");
            let lockerScript = this.btcInterface.convertAddressToScript(locker.sourceAddress);
            const isValid = yield network.contracts.lockerContract.isValidLocker(`0x${lockerScript.script.toString("hex")}`, locker.targetAddress);
            if (!isValid) {
                throw new Error("invalid locker");
            }
            return {
                sourceAddress: locker.sourceAddress,
                targetAddress: locker.targetAddress,
                lockingScript: `0x${lockerScript.script.toString("hex")}`,
            };
        });
    }
    setThirdPartyId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(this.defaultBaseNetwork || "polygon");
            this.thirdPartFee = yield network.teleswapScript.getThirdPartFee(id);
            this.thirdPartyId = id;
        });
    }
    wrapEstimate(amountBTC, networkName, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            return {
                minInputAmountBTC: feeResponse.minAmount,
                inputAmountBTC: feeResponse.amount.inputAmountBTC,
                outputAmountBTC: feeResponse.amount.receivedAmountBTC,
                teleswapFee: feeResponse.fee,
            };
        });
    }
    wrapUnsigned(recipientAddress, amountBTC, signer, networkName, speed = false, changeAddress, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[network.networkName || this.defaultBaseNetwork];
            const appId = configs_1.teleswap.requestAppId.Wrap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", network.networkName);
            return this.teleswapWallet.wrapUnsigned(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, signer, undefined, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, changeAddress, fullAmount);
        });
    }
    wrapAndSwapBaseNetworkEstimate(amountBTC, networkName, outputToken, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const amount = new bignumber_js_1.default(feeResponse.amount.receivedAmountBTC).multipliedBy(1e8).toFixed(0);
            const teleBTC = configs_1.teleswap.tokens[network.networkName].mainnet.teleBTCAddress;
            const finalOutputToken = outputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            const path = yield this.getWrapSwapPathV3(teleBTC, finalOutputToken, network.networkName);
            const outputAmount = yield network.contracts.uniswapV3Connector.getExactInput(path, amount);
            return {
                minInputAmountBTC: feeResponse.minAmount,
                inputAmountBTC: feeResponse.amount.inputAmountBTC,
                outputAmount: outputAmount[1].toString(),
                teleswapFee: feeResponse.fee,
                internalExchange: {
                    path: `BTC-TELEBTC(${network.networkName})->${finalOutputToken}(${network.networkName})`,
                    inputAmount: amount,
                    outputAmount: outputAmount[1].toString(),
                },
            };
        });
    }
    wrapAndSwapBaseNetworkUnsigned(recipientAddress, amountBTC, signer, networkName, outputToken, minOutputAmount, speed = false, changeAddress, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            if (speed && !minOutputAmount) {
                throw new Error("when speed is true you should set min output amount");
            }
            const network = this.getNetwork(networkName);
            const finalOutputToken = outputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[networkName || this.defaultBaseNetwork];
            const appId = configs_1.teleswap.requestAppId.WrapAndSwap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", network.networkName);
            return this.teleswapWallet.wrapUnsigned(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, signer, {
                outputToken: finalOutputToken,
                outputAmount: minOutputAmount || "0",
                bridgePercentageFee: 0,
            }, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, changeAddress, fullAmount);
        });
    }
    wrapAndSwapCrossChainEstimate(amountBTC, networkName, outputToken, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const ethTokenAddress = outputToken ? (0, web3_utils_1.toChecksumAddress)(outputToken) : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            if (!polygonTokenAddress) {
                throw new Error("invalid token");
            }
            const thirdPartFee = thirdPartyId
                ? yield middleNetwork.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield middleNetwork.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            const amount = new bignumber_js_1.default(feeResponse.amount.receivedAmountBTC).multipliedBy(1e8).toFixed(0);
            const teleBTC = configs_1.teleswap.tokens[middleNetwork.networkName].mainnet.teleBTCAddress;
            const path = yield this.getWrapSwapPathV3(teleBTC, polygonTokenAddress, middleNetwork.networkName);
            const outputAmount = yield middleNetwork.contracts.uniswapV3Connector.getExactInput(path, amount);
            const acrossFee = yield this.teleportdao.getAcrossFee(polygonTokenAddress, outputAmount[1].toString(), network.networkChainInfo.chainId, middleNetwork.networkChainInfo.chainId);
            const bridgeFee = increaseNumber(acrossFee.totalRelayFee.total);
            return {
                minInputAmountBTC: feeResponse.minAmount,
                inputAmountBTC: feeResponse.amount.inputAmountBTC,
                outputAmount: new bignumber_js_1.default(outputAmount[1].toString()).minus(bridgeFee).toFixed(0),
                teleswapFee: feeResponse.fee,
                internalExchange: {
                    path: `BTC-TELEBTC(polygon)->${polygonTokenAddress}(polygon)`,
                    inputAmount: amount,
                    outputAmount: outputAmount[1].toString(),
                },
                internalBridge: {
                    path: `${polygonTokenAddress}(polygon)->${outputToken || "NativeToken"}(${network.networkName})`,
                    fee: bridgeFee,
                },
            };
        });
    }
    wrapAndSwapCrossChainUnsigned(recipientAddress, amountBTC, signer, networkName, outputToken, minOutputAmount, speed = false, changeAddress, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!networkName) {
                throw new Error("crossChainNetwork not exist");
            }
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            if (speed && !minOutputAmount) {
                throw new Error("when speed is true you should set min output amount");
            }
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const ethTokenAddress = outputToken ? (0, web3_utils_1.toChecksumAddress)(outputToken) : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            if (!polygonTokenAddress) {
                throw new Error("invalid token address");
            }
            const thirdPartFee = thirdPartyId
                ? yield middleNetwork.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield middleNetwork.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[networkName];
            const appId = configs_1.teleswap.requestAppId.WrapAndSwap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", middleNetworkName);
            const teleBTC = configs_1.teleswap.tokens[middleNetwork.networkName].mainnet.teleBTCAddress;
            const path = yield this.getWrapSwapPathV3(teleBTC, polygonTokenAddress, middleNetwork.networkName);
            const outputAmount = yield middleNetwork.contracts.uniswapV3Connector.getExactInput(path, amount);
            const acrossFee = yield this.teleportdao.getAcrossFee(polygonTokenAddress, outputAmount[1].toString(), network.networkChainInfo.chainId, middleNetwork.networkChainInfo.chainId);
            const bridgePercentageFee = increaseNumber(acrossFee.totalRelayFee.pct);
            const fee = +((100 * +bridgePercentageFee) / +`1e${18}`).toFixed(5);
            return this.teleswapWallet.wrapUnsigned(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, signer, {
                outputToken: polygonTokenAddress,
                outputAmount: minOutputAmount || "0",
                bridgePercentageFee: fee,
            }, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, changeAddress, fullAmount);
        });
    }
    wrapAndSwapEstimate(amountBTC, networkName, outputToken, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet)
                throw new Error("testnet not supported");
            if (this.isCrossChainNetwork(networkName)) {
                return this.wrapAndSwapCrossChainEstimate(amountBTC, networkName, outputToken, thirdPartyId);
            }
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if (outputToken && (0, web3_utils_1.toChecksumAddress)(outputToken) === teleBTC.mainnet.teleBTCAddress) {
                return this.wrapEstimate(amountBTC, baseNetworkName, thirdPartyId);
            }
            return this.wrapAndSwapBaseNetworkEstimate(amountBTC, baseNetworkName, outputToken, thirdPartyId);
        });
    }
    wrapAndSwapUnsigned(recipientAddress, amountBTC, signer, networkName, outputToken, minOutputAmount, speed = false, changeAddress, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCrossChainNetwork(networkName)) {
                return this.wrapAndSwapCrossChainUnsigned(recipientAddress, amountBTC, signer, networkName, outputToken, minOutputAmount, speed, changeAddress, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
            }
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if (outputToken && (0, web3_utils_1.toChecksumAddress)(outputToken) === teleBTC.mainnet.teleBTCAddress) {
                return this.wrapUnsigned(recipientAddress, amountBTC, signer, baseNetworkName, speed, changeAddress, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
            }
            return this.wrapAndSwapBaseNetworkUnsigned(recipientAddress, amountBTC, signer, baseNetworkName, outputToken, minOutputAmount, speed, changeAddress, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
        });
    }
    brc20WrapUnsigned(receiverAddress, brc, signerInfo, ordinalSignerInfo, staticFeeRate, staticUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(receiverAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            const { chainId } = configs_1.chainInfo.bsc;
            const appId = configs_1.brc20.requestAppId.Wrap.default;
            if (!this.brc20Wallet) {
                throw new Error("need unisat token");
            }
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcWallet = this.brc20Wallet;
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const locker = yield network.contracts.brc20router.getLockerInfo();
            const lockerAddress = this.btcInterface.convertHashToAddress(locker.lockingScript.replace("0x", "p2sh"), "p2sh-p2wpkh");
            let wrapInfo = yield brcWallet.wrapBrc20Unsigned(receiverAddress, brc, brcTokenId, signerInfo, lockerAddress, undefined, ordinalSignerInfo, staticFeeRate, staticUtxo, { chainId, appId });
            return wrapInfo;
        });
    }
    brc20WrapAndSwapUnsigned(receiverAddress, brc, outputToken, signerInfo, ordinalSignerInfo, minOutputAmount, staticFeeRate, staticUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(receiverAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            const { chainId } = configs_1.chainInfo.bsc;
            const appId = configs_1.brc20.requestAppId.WrapAndSwap.default;
            if (!this.brc20Wallet) {
                throw new Error("need unisat token");
            }
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcWallet = this.brc20Wallet;
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const locker = yield network.contracts.brc20router.getLockerInfo();
            const lockerAddress = this.btcInterface.convertHashToAddress(locker.lockingScript.replace("0x", "p2sh"), "p2sh-p2wpkh");
            let wrapInfo = yield brcWallet.wrapBrc20Unsigned(receiverAddress, brc, brcTokenId, signerInfo, lockerAddress, {
                outputToken,
                outputAmount: minOutputAmount || "0",
            }, ordinalSignerInfo, staticFeeRate, staticUtxo, { chainId, appId });
            return wrapInfo;
        });
    }
    wrap(recipientAddress, amountBTC, networkName, speed = false, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[networkName || this.defaultBaseNetwork];
            const appId = configs_1.teleswap.requestAppId.Wrap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", network.networkName);
            return this.teleswapWallet.wrap(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, undefined, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, undefined, fullAmount);
        });
    }
    wrapAndSwapBaseNetwork(recipientAddress, amountBTC, networkName, outputToken, minOutputAmount, speed = false, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[networkName || this.defaultBaseNetwork];
            const appId = configs_1.teleswap.requestAppId.WrapAndSwap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", network.networkName);
            const finalOutputToken = outputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            return this.teleswapWallet.wrap(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, {
                outputToken: finalOutputToken,
                outputAmount: minOutputAmount || "0",
                bridgePercentageFee: 0,
            }, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, undefined, fullAmount);
        });
    }
    wrapAndSwapCrossChain(recipientAddress, amountBTC, networkName, outputToken, minOutputAmount, speed = false, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(recipientAddress))
                throw new Error("invalid eth address");
            if (!networkName) {
                throw new Error("crossChainNetwork not exist");
            }
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const ethTokenAddress = outputToken ? (0, web3_utils_1.toChecksumAddress)(outputToken) : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            if (!polygonTokenAddress) {
                throw new Error("invalid token address");
            }
            const thirdPartFee = thirdPartyId
                ? yield middleNetwork.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield middleNetwork.teleswapScript.calculateWrapFeeBackend(amountBTC, "Wrap", false, thirdPartFee.wrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(feeResponse.minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${feeResponse.minAmount}`);
            }
            const { chainId } = configs_1.chainInfo[networkName];
            const appId = configs_1.teleswap.requestAppId.WrapAndSwap.default;
            const amount = (0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0);
            const networkFee = (0, bignumber_js_1.default)(feeResponse.fee.networkFeeBTC).multipliedBy(1e8).toFixed(0);
            const locker = yield this.selectLocker(amountBTC, "wrap", middleNetworkName);
            const teleBTC = configs_1.teleswap.tokens[middleNetwork.networkName].mainnet.teleBTCAddress;
            const path = yield this.getWrapSwapPathV3(teleBTC, polygonTokenAddress, middleNetwork.networkName);
            const outputAmount = yield middleNetwork.contracts.uniswapV3Connector.getExactInput(path, amount);
            const acrossFee = yield this.teleportdao.getAcrossFee(polygonTokenAddress, outputAmount[1].toString(), network.networkChainInfo.chainId, middleNetwork.networkChainInfo.chainId);
            const bridgePercentageFee = increaseNumber(acrossFee.totalRelayFee.pct);
            const fee = +((100 * +bridgePercentageFee) / +`1e${18}`).toFixed(5);
            return this.teleswapWallet.wrap(recipientAddress, amount, networkFee, locker.sourceAddress, chainId, {
                outputToken: polygonTokenAddress,
                outputAmount: minOutputAmount || "0",
                bridgePercentageFee: fee,
            }, appId, speed, staticFeeRate, thirdPartyId || this.thirdPartyId, staticUTXO, undefined, fullAmount);
        });
    }
    wrapAndSwap(recipientAddress, amountBTC, networkName, outputToken, minOutputAmount, speed = false, staticFeeRate, staticUTXO, fullAmount = false, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCrossChainNetwork(networkName)) {
                return this.wrapAndSwapCrossChain(recipientAddress, amountBTC, networkName, outputToken, minOutputAmount, speed, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
            }
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if (outputToken && (0, web3_utils_1.toChecksumAddress)(outputToken) === teleBTC.mainnet.teleBTCAddress) {
                return this.wrap(recipientAddress, amountBTC, baseNetworkName, speed, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
            }
            return this.wrapAndSwapBaseNetwork(recipientAddress, amountBTC, networkName, outputToken, minOutputAmount, speed, staticFeeRate, staticUTXO, fullAmount, thirdPartyId);
        });
    }
    brc20Wrap(receiverAddress, brc, staticFeeRate, staticUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(receiverAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            const { chainId } = configs_1.chainInfo.bsc;
            const appId = configs_1.brc20.requestAppId.Wrap.default;
            if (!this.brc20Wallet) {
                throw new Error("need unisat token");
            }
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcWallet = this.brc20Wallet;
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const locker = yield network.contracts.brc20router.getLockerInfo();
            const lockerAddress = this.btcInterface.convertHashToAddress(locker.lockingScript.replace("0x", "p2sh"), "p2sh-p2wpkh");
            let wrapInfo = yield brcWallet.wrapBrc20(receiverAddress, brc, brcTokenId, lockerAddress, undefined, staticFeeRate, staticUtxo, { chainId, appId });
            return wrapInfo;
        });
    }
    brc20WrapAndSwap(receiverAddress, brc, outputToken, minOutputAmount, staticFeeRate, staticUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contracts_helper_1.EthereumBase.validateEthAddress(receiverAddress))
                throw new Error("invalid eth address");
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            const { chainId } = configs_1.chainInfo.bsc;
            const appId = configs_1.brc20.requestAppId.WrapAndSwap.default;
            if (!this.brc20Wallet) {
                throw new Error("need unisat token");
            }
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcWallet = this.brc20Wallet;
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const locker = yield network.contracts.brc20router.getLockerInfo();
            const lockerAddress = this.btcInterface.convertHashToAddress(locker.lockingScript.replace("0x", "p2sh"), "p2sh-p2wpkh");
            let wrapInfo = yield brcWallet.wrapBrc20(receiverAddress, brc, brcTokenId, lockerAddress, {
                outputToken,
                outputAmount: minOutputAmount || "0",
            }, staticFeeRate, staticUtxo, { chainId, appId });
            return wrapInfo;
        });
    }
    unwrapEstimate(amountBTC, networkName, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateUnwrapFeeBackend(amountBTC, false, thirdPartFee.unwrapFee);
            return {
                minInputAmountBTC: feeResponse.minAmount,
                inputAmountBTC: feeResponse.amount.inputAmountBTC,
                outputAmountBTC: feeResponse.amount.receivedAmountBTC,
                teleswapFee: feeResponse.fee,
            };
        });
    }
    unwrapInputs(amountBTC, bitcoinAddress, networkName, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            const network = this.getNetwork(networkName);
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(amountBTC, "unwrap", network.networkName);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const unwrapInputs = contracts_helper_1.contracts.CcBurnRouter.unwrapParams((0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0), `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId || this.thirdPartyId);
            const minAmount = yield network.teleswapScript.getMinUnwrapFeeBackend(thirdPartFee.unwrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${minAmount}`);
            }
            return {
                locker,
                inputs: unwrapInputs,
            };
        });
    }
    swapAndUnwrapBaseNetworkEstimate(exchangeInfo, networkName, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            const inputToken = exchangeInfo.inputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            let path = yield this.getUnwrapSwapPathV3(inputToken, network.tokenAddress.teleBTCAddress, network.networkName);
            const amountOut = yield network.contracts.uniswapV3Connector.getExactInput(path, exchangeInfo.inputAmount);
            const amountBTC = new bignumber_js_1.default(amountOut[1].toString()).dividedBy(1e8).toFixed(8);
            const thirdPartFee = thirdPartyId
                ? yield network.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield network.teleswapScript.calculateUnwrapFeeBackend(amountBTC, false, thirdPartFee.unwrapFee);
            const minAmount = yield network.teleswapScript.getMinUnwrapFeeBackend(thirdPartFee.unwrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${minAmount}`);
            }
            return {
                inputAmount: exchangeInfo.inputAmount,
                outputAmountBTC: feeResponse.amount.receivedAmountBTC,
                teleswapFee: feeResponse.fee,
                internalExchange: {
                    path: `${exchangeInfo.inputToken || "NativeToken"}(${network.networkName})->TELEBTC(${network.networkName})`,
                    inputAmount: exchangeInfo.inputAmount,
                    outputAmount: amountOut[1].toString(),
                },
                minInputAmountBTC: feeResponse.minAmount,
            };
        });
    }
    swapAndUnwrapBaseNetworkInputs(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            const network = this.getNetwork(networkName);
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(minBtcAmount, "unwrap", network.networkName);
            const { uniswapV3Connector } = network.contractAddress;
            const inputToken = exchangeInfo.inputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            let path = yield this.getUnwrapSwapPathV3(inputToken, network.tokenAddress.teleBTCAddress, network.networkName);
            let exchangeConnector = uniswapV3Connector;
            const block = yield network.contracts.burnContract.web3Eth.getBlock("latest");
            const lastTime = block.timestamp.toString();
            const deadline = +lastTime + 100000;
            const inputs = contracts_helper_1.contracts.CcBurnRouter.swapAndUnwrapParams({
                exchangeConnector,
                path,
                deadline,
                inputAmount: exchangeInfo.inputAmount,
                outputAmount: minBtcAmount,
                isFixedToken: (_a = exchangeInfo.isFixedToken) !== null && _a !== void 0 ? _a : true,
                isNativeToken: !exchangeInfo.inputToken,
            }, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId || this.thirdPartyId);
            return {
                locker,
                inputs,
            };
        });
    }
    swapAndUnwrapCrossChainEstimate(exchangeInfo, networkName, thirdPartyId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet)
                throw new Error("cross chain not supported in testnet");
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const networkToken = configs_1.tokens[network.networkName].mainnet;
            const ethTokenAddress = exchangeInfo.inputToken
                ? (0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken)
                : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            if (!polygonTokenAddress) {
                throw new Error("invalid token address");
            }
            let path = yield this.getUnwrapSwapPathV3(polygonTokenAddress, middleNetwork.tokenAddress.teleBTCAddress, middleNetwork.networkName);
            const uniqueCounter = "82";
            const sourceChainId = configs_1.chainInfo[network.networkName].chainId;
            const user = "0x0000000000000000000000000000000000000000";
            const connector = middleNetwork.contractAddress.networkConnector;
            if (!connector)
                throw new Error("network connector not found");
            const data = (0, crosschain_helper_1.encodeCrossChainSwap)(uniqueCounter, sourceChainId.toString(), user, middleNetwork.contractAddress.uniswapV3Connector, exchangeInfo.inputAmount, (_a = exchangeInfo.isFixedToken) !== null && _a !== void 0 ? _a : false, path, "0x80ed8d2a06dde341dd62f495c45f5fad6eb8f252", "3", "0xa91472df0f82c4bcfe01a274bd521e5d4c66586b7a5b87", this.thirdPartyId.toString());
            const acrossFee = yield this.teleportdao.getAcrossFee(exchangeInfo.inputToken || networkToken.WrappedNativeToken, exchangeInfo.inputAmount, middleNetwork.networkChainInfo.chainId, network.networkChainInfo.chainId, data, connector);
            const bridgeFee = increaseNumber(acrossFee.totalRelayFee.total);
            const amountOut = yield middleNetwork.contracts.uniswapV3Connector.getExactInput(path, (0, bignumber_js_1.default)(exchangeInfo.inputAmount).minus(bridgeFee).toFixed(0));
            const amountBTC = new bignumber_js_1.default(amountOut[1].toString()).dividedBy(1e8).toFixed(8);
            const thirdPartFee = thirdPartyId
                ? yield middleNetwork.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const feeResponse = yield middleNetwork.teleswapScript.calculateUnwrapFeeBackend(amountBTC, false, thirdPartFee.unwrapFee);
            const minAmount = yield middleNetwork.teleswapScript.getMinUnwrapFeeBackend(thirdPartFee.unwrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${minAmount}`);
            }
            return {
                inputAmount: exchangeInfo.inputAmount,
                outputAmountBTC: feeResponse.amount.receivedAmountBTC,
                teleswapFee: feeResponse.fee,
                internalExchange: {
                    path: `${polygonTokenAddress}(polygon)->TELEBTC(polygon)`,
                    inputAmount: exchangeInfo.inputAmount,
                    outputAmount: amountOut[1].toString(),
                },
                internalBridge: {
                    path: `${exchangeInfo.inputToken || "NativeToken"}(${network.networkName})->${polygonTokenAddress}(polygon)`,
                    fee: bridgeFee,
                },
                minInputAmountBTC: feeResponse.minAmount,
            };
        });
    }
    swapAndUnwrapCrossChainInputs(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId = this.thirdPartyId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet)
                throw new Error("cross chain not supported in testnet");
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(minBtcAmount, "unwrap", middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const networkToken = configs_1.tokens[network.networkName].mainnet;
            const ethTokenAddress = exchangeInfo.inputToken
                ? (0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken)
                : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            if (!polygonTokenAddress) {
                throw new Error("invalid token address");
            }
            const isNativeToken = polygonTokenAddress === configs_1.tokens.polygon.mainnet.WETHAddress;
            const { uniswapV3Connector } = middleNetwork.contractAddress;
            let path = yield this.getUnwrapSwapPathV3(polygonTokenAddress, middleNetwork.tokenAddress.teleBTCAddress, middleNetwork.networkName);
            let exchangeConnector = uniswapV3Connector;
            const uniqueCounter = "82";
            const sourceChainId = configs_1.chainInfo[network.networkName].chainId;
            const user = "0x0000000000000000000000000000000000000000";
            const connector = middleNetwork.contractAddress.networkConnector;
            if (!connector)
                throw new Error("network connector not found");
            const data = (0, crosschain_helper_1.encodeCrossChainSwap)(uniqueCounter, sourceChainId.toString(), user, middleNetwork.contractAddress.uniswapV3Connector, exchangeInfo.inputAmount, (_a = exchangeInfo.isFixedToken) !== null && _a !== void 0 ? _a : false, path, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType].toString(), locker.lockingScript, thirdPartyId.toString());
            const acrossFee = yield this.teleportdao.getAcrossFee(exchangeInfo.inputToken || networkToken.WrappedNativeToken, exchangeInfo.inputAmount, middleNetwork.networkChainInfo.chainId, network.networkChainInfo.chainId, data, connector);
            const amountOut = yield middleNetwork.contracts.uniswapV3Connector.getExactInput(path, (0, bignumber_js_1.default)(exchangeInfo.inputAmount)
                .minus(increaseNumber(acrossFee.totalRelayFee.total))
                .toFixed(0));
            const amountBTC = new bignumber_js_1.default(amountOut[1].toString()).dividedBy(1e8).toFixed(8);
            const thirdPartFee = thirdPartyId
                ? yield middleNetwork.teleswapScript.getThirdPartFee(thirdPartyId)
                : this.thirdPartFee;
            const minAmount = yield middleNetwork.teleswapScript.getMinUnwrapFeeBackend(thirdPartFee.unwrapFee);
            if ((0, bignumber_js_1.default)(amountBTC).isLessThan(minAmount)) {
                throw new Error(`BTC amount should be more than minimum amount:${minAmount}`);
            }
            const inputs = contracts_helper_1.contracts.EthConnector.swapAndUnwrapParams({
                ethTokenAddress,
                exchangeConnector,
                destinationPath: path,
                inputAmount: exchangeInfo.inputAmount,
                outputAmount: minBtcAmount,
                isFixedToken: (_b = exchangeInfo.isFixedToken) !== null && _b !== void 0 ? _b : true,
                isNativeToken,
            }, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId, increaseNumber(acrossFee.totalRelayFee.pct));
            return {
                locker,
                inputs,
            };
        });
    }
    swapAndUnwrapEstimate(exchangeInfo, networkName, thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet) {
                throw new Error("testnet not supported for this method");
            }
            if (this.isCrossChainNetwork(networkName)) {
                return this.swapAndUnwrapCrossChainEstimate(exchangeInfo, networkName, thirdPartyId);
            }
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if (exchangeInfo.inputToken &&
                (0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken) === teleBTC.mainnet.teleBTCAddress) {
                const amountBTC = new bignumber_js_1.default(exchangeInfo.inputAmount).dividedBy(1e8).toFixed(8);
                return this.unwrapEstimate(amountBTC, baseNetworkName, thirdPartyId);
            }
            return this.swapAndUnwrapBaseNetworkEstimate(exchangeInfo, networkName, thirdPartyId);
        });
    }
    swapAndUnwrapInputs(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId = this.thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet) {
                throw new Error("testnet not supported for this method");
            }
            if (this.isCrossChainNetwork(networkName)) {
                return this.swapAndUnwrapCrossChainInputs(exchangeInfo, bitcoinAddress, networkName, minBtcAmount, thirdPartyId);
            }
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if (exchangeInfo.inputToken &&
                (0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken) === teleBTC.mainnet.teleBTCAddress) {
                const amountBTC = new bignumber_js_1.default(exchangeInfo.inputAmount).dividedBy(1e8).toFixed(8);
                return this.unwrapInputs(amountBTC, bitcoinAddress, baseNetworkName, thirdPartyId);
            }
            return this.swapAndUnwrapBaseNetworkInputs(exchangeInfo, bitcoinAddress, networkName, minBtcAmount, thirdPartyId);
        });
    }
    unwrap(amountBTC, bitcoinAddress, networkName, thirdPartyId = this.thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            if (!this.isEvmInitialize) {
                throw new Error("target network account is not initialized");
            }
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(amountBTC, "unwrap", network.networkName);
            const approveResponse = yield this.checkERC20BalanceAndApprove(network.tokenAddress.teleBTCAddress, network.contracts.burnContract.contractAddress, amountBTC, network.targetConnectionConfig);
            const unwrapResponse = yield network.contracts.burnContract.unwrap((0, bignumber_js_1.default)(amountBTC).multipliedBy(1e8).toFixed(0), `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId);
            return {
                locker,
                unwrapResponse,
                approveResponse,
            };
        });
    }
    swapAndUnwrapBaseNetwork(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId = this.thirdPartyId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            if (!this.isEvmInitialize) {
                throw new Error("target network account is not initialized");
            }
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(minBtcAmount, "unwrap", network.networkName);
            const { uniswapV3Connector } = network.contractAddress;
            const inputToken = exchangeInfo.inputToken || configs_1.tokens[network.networkName].mainnet.WrappedNativeToken;
            let path = yield this.getUnwrapSwapPathV3(inputToken, network.tokenAddress.teleBTCAddress, network.networkName);
            let exchangeConnector = uniswapV3Connector;
            let approveResponse = null;
            if (exchangeInfo.inputToken) {
                approveResponse = yield this.checkERC20BalanceAndApprove(inputToken, network.contracts.burnContract.contractAddress, exchangeInfo.inputAmount, network.targetConnectionConfig, true);
            }
            const block = yield network.contracts.burnContract.web3Eth.getBlock("latest");
            const lastTime = block.timestamp.toString();
            const deadline = +lastTime + 100000;
            const unwrapResponse = yield network.contracts.burnContract.swapAndUnwrap({
                exchangeConnector,
                path,
                deadline,
                inputAmount: exchangeInfo.inputAmount,
                outputAmount: minBtcAmount,
                isFixedToken: (_a = exchangeInfo.isFixedToken) !== null && _a !== void 0 ? _a : true,
                isNativeToken: !exchangeInfo.inputToken,
            }, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId);
            return {
                locker,
                unwrapResponse,
                approveResponse,
            };
        });
    }
    swapAndUnwrapCrossChain(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId = this.thirdPartyId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!bitcoin_1.bitcoinUtils.validateAddress(bitcoinAddress))
                throw new Error("invalid bitcoin address");
            if (this.isTestnet)
                throw new Error("cross chain not supported in testnet");
            const network = this.getCrossChainNetwork(networkName);
            const middleNetworkName = this.isTestnet ? "polygon_testnet" : "polygon";
            const middleNetwork = this.getNetwork(middleNetworkName);
            if (!this.isEvmInitialize) {
                throw new Error("target network account is not initialized");
            }
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(bitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const locker = yield this.selectLocker(minBtcAmount, "unwrap", middleNetworkName);
            const ToPolygonToken = cross_chain_tokens_1.toPolygon[network.networkName];
            const networkToken = configs_1.tokens[network.networkName].mainnet;
            const ethTokenAddress = exchangeInfo.inputToken
                ? (0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken)
                : teleport_tokens_1.ethTeleswapToken;
            const polygonTokenAddress = ToPolygonToken[ethTokenAddress];
            const isNativeToken = !exchangeInfo.inputToken;
            if (!polygonTokenAddress) {
                throw new Error("invalid token address");
            }
            let path = yield this.getUnwrapSwapPathV3(polygonTokenAddress, middleNetwork.tokenAddress.teleBTCAddress, middleNetwork.networkName);
            const uniqueCounter = "82";
            const sourceChainId = configs_1.chainInfo[network.networkName].chainId;
            const user = "0x0000000000000000000000000000000000000000";
            const connector = middleNetwork.contractAddress.networkConnector;
            if (!connector)
                throw new Error("network connector not found");
            const data = (0, crosschain_helper_1.encodeCrossChainSwap)(uniqueCounter, sourceChainId.toString(), user, middleNetwork.contractAddress.uniswapV3Connector, exchangeInfo.inputAmount, (_a = exchangeInfo.isFixedToken) !== null && _a !== void 0 ? _a : false, path, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType].toString(), locker.lockingScript, thirdPartyId.toString());
            const acrossFee = yield this.teleportdao.getAcrossFee(exchangeInfo.inputToken || networkToken.WrappedNativeToken, exchangeInfo.inputAmount, middleNetwork.networkChainInfo.chainId, network.networkChainInfo.chainId, data, connector);
            let approveResponse = null;
            if (exchangeInfo.inputToken) {
                approveResponse = yield this.checkERC20BalanceAndApprove(exchangeInfo.inputToken, network.contracts.teleswapEthConnector.contractAddress, exchangeInfo.inputAmount, network.targetConnectionConfig, true);
            }
            const { uniswapV3Connector } = middleNetwork.contractAddress;
            let exchangeConnector = uniswapV3Connector;
            const unwrapResponse = yield network.contracts.teleswapEthConnector.swapAndUnwrap({
                ethTokenAddress,
                exchangeConnector,
                destinationPath: path,
                inputAmount: exchangeInfo.inputAmount,
                outputAmount: minBtcAmount,
                isFixedToken: (_b = exchangeInfo.isFixedToken) !== null && _b !== void 0 ? _b : true,
                isNativeToken,
            }, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], locker.lockingScript, thirdPartyId, increaseNumber(acrossFee.totalRelayFee.pct));
            return {
                locker,
                unwrapResponse,
                approveResponse,
            };
        });
    }
    swapAndUnwrap(exchangeInfo, bitcoinAddress, networkName, minBtcAmount = "0", thirdPartyId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isTestnet) {
                throw new Error("testnet not supported for this method");
            }
            if (this.isCrossChainNetwork(networkName)) {
                return this.swapAndUnwrapCrossChain(exchangeInfo, bitcoinAddress, networkName, minBtcAmount, thirdPartyId);
            }
            if (!exchangeInfo.inputToken)
                throw new Error("input token not found");
            const baseNetworkName = networkName;
            const teleBTC = configs_1.teleswap.tokens[baseNetworkName];
            if ((0, web3_utils_1.toChecksumAddress)(exchangeInfo.inputToken) === teleBTC.mainnet.teleBTCAddress) {
                const amountBTC = new bignumber_js_1.default(exchangeInfo.inputAmount).dividedBy(1e8).toFixed(8);
                return this.unwrap(amountBTC, bitcoinAddress, baseNetworkName, thirdPartyId);
            }
            return this.swapAndUnwrapBaseNetwork(exchangeInfo, bitcoinAddress, networkName, minBtcAmount, thirdPartyId);
        });
    }
    brc20Unwrap(brc, receiverBitcoinAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!bitcoin_1.bitcoinUtils.validateAddress(receiverBitcoinAddress)) {
                throw new Error("invalid bitcoin address");
            }
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(receiverBitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const appId = configs_1.brc20.requestAppId.Wrap.default;
            const unwrapInfo = yield network.contracts.brc20router.unwrapBrc20(brc.amount, brcTokenId, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], appId);
            return unwrapInfo;
        });
    }
    brc20UnwrapAndSwap(exchangeInfo, brc, receiverBitcoinAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!bitcoin_1.bitcoinUtils.validateAddress(receiverBitcoinAddress)) {
                throw new Error("invalid bitcoin address");
            }
            const network = this.getNetwork(this.isTestnet ? "not-supported" : "bsc");
            const appId = configs_1.brc20.requestAppId.WrapAndSwap.default;
            if (!network.contracts.brc20router) {
                throw new Error("wrong network");
            }
            const brcTokenId = yield network.contracts.brc20router.getTokenId(brc.tick);
            if (!brcTokenId) {
                throw new Error("token id not found");
            }
            const { hash, script, addressType } = this.btcInterface.convertAddressToScript(receiverBitcoinAddress);
            if (!hash) {
                throw new Error("Invalid Bitcoin address");
            }
            const unwrapInfo = yield network.contracts.brc20router.unwrapBrc20(brc.amount, brcTokenId, `0x${hash.toString("hex")}`, bitcoin_1.bitcoinUtils.addressTypeHelper.addressTypesNumber[addressType], appId, {
                inputAmount: exchangeInfo.inputAmount,
                inputToken: exchangeInfo.inputToken,
                path: [],
            });
            return unwrapInfo;
        });
    }
    checkERC20BalanceAndApprove(tokenContractAddress, approveAddress, amount, connectionConfig, amountInWei = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.evmAddress) {
                throw new Error("polygon account is not initialized");
            }
            let erc20 = new contracts_helper_1.contracts.ERC20(connectionConfig, tokenContractAddress);
            erc20.setCurrentAccount(this.evmAddress);
            let realAmount = amount;
            if (!amountInWei) {
                if (!erc20.unit) {
                    yield erc20.setDecimal();
                }
                if (!erc20.unit) {
                    throw new Error("erc20 decimal not set");
                }
                realAmount = (0, bignumber_js_1.default)(amount)
                    .multipliedBy(Math.pow(10, erc20.unit))
                    .toFixed(0);
            }
            let erc20TokenBalance = yield erc20.getBalance();
            console.log("check erc20Token Balance:", erc20TokenBalance);
            if ((0, bignumber_js_1.default)(erc20TokenBalance.toString()).isLessThan(realAmount)) {
                throw new Error("not enough teleBTC balance");
            }
            let approvedBalance = yield erc20.getApprovedBalanceForAddress(approveAddress);
            let approveTxId = null;
            if ((0, bignumber_js_1.default)(approvedBalance.toString()).isLessThan(realAmount)) {
                console.log("approve erc20Token ...");
                approveTxId = (yield erc20.approve(approveAddress, realAmount)).receipt.transactionHash;
                console.log("approve erc20Token txId", approveTxId);
            }
            return { amountMultipliedByDecimal: realAmount, txId: approveTxId };
        });
    }
    getUnwrapSwapPathV3(token1Address, token2Address, networkName) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            return (0, static_path_1.getUnwrapSwapPathV3)(network.networkName, token1Address, token2Address);
        });
    }
    getWrapSwapPathV3(token1Address, token2Address, networkName) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this.getNetwork(networkName);
            return (0, static_path_1.getSwapPathV3)(network.networkName, token1Address, token2Address);
        });
    }
}
exports.TeleswapSDK = TeleswapSDK;
exports.default = TeleswapSDK;
//# sourceMappingURL=teleswap-sdk.js.map