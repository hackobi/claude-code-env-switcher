import { EthereumBase, contracts } from "@teleportdao/contracts-helper";
import { BitcoinConnectionInfo, BitcoinInterface, ExtendedUtxo, SignerInfo, TeleswapWallet } from "@teleportdao/bitcoin";
import OrdinalWallet from "@teleportdao/bitcoin/dist/ordinal-wallet";
import { TeleportDao } from "@teleportdao/providers";
import { ConnectionConfig, CrossChainNetwork, SupportedNetwork, TestnetAndMainnetNetwork, TargetNetworkSDKConnection } from "./types/eth";
import { TeleswapScripts } from "./teleswap-scripts";
export declare class TeleswapSDK {
    btcInterface: BitcoinInterface;
    isEvmInitialize: boolean;
    isBitcoinInitialize: boolean;
    teleswapWallet: TeleswapWallet;
    sourceConnection: BitcoinConnectionInfo;
    networks: Map<string, {
        networkName: SupportedNetwork;
        baseEth: EthereumBase;
        targetConnectionConfig: ConnectionConfig;
        networkChainInfo: {
            nativeToken: string;
            name: string;
            chainId: number;
        };
        teleswapScript: TeleswapScripts;
        contracts: {
            burnContract: contracts.CcBurnRouter;
            lockerContract: contracts.LockerContract;
            teleBTC: contracts.ERC20;
            brc20router?: contracts.Brc20.BRC20;
            uniswapV2Factory: contracts.UniSwapV2Factory;
            uniswapV2Router: contracts.UniSwapV2Router;
            uniswapV2Connector: contracts.UniswapV2Connector;
            uniswapV3Connector: contracts.UniswapV3Connector;
            ccTransfer: contracts.CcTransferRouter;
            ccExchange: contracts.CcExchangeRouter;
        };
        tokenAddress: {
            teleBTCAddress: string;
        };
        contractAddress: {
            uniswapV2Connector: string;
            uniswapV3Connector: string;
            uniswapV2FactoryV2Address: string;
            uniswapV2RouterV2Address: string;
            networkConnector?: string;
        };
    }>;
    crossChainNetworks: Map<string, {
        networkName: CrossChainNetwork;
        baseEth: EthereumBase;
        targetConnectionConfig: ConnectionConfig;
        networkChainInfo: {
            nativeToken: string;
            name: string;
            chainId: number;
        };
        teleswapScript: TeleswapScripts;
        contracts: {
            teleswapEthConnector: contracts.EthConnector;
        };
        tokenAddress: object;
        contractAddress: object;
    }>;
    crossChainNetworkNames: string[];
    baseNetworkNames: string[];
    isTestnet: boolean;
    defaultBaseNetwork?: TestnetAndMainnetNetwork;
    defaultCrossChainNetwork?: CrossChainNetwork;
    brc20Wallet?: OrdinalWallet;
    evmAddress?: string;
    thirdPartFee: {
        unwrapFee: number;
        wrapFee: number;
    };
    thirdPartyId: number;
    teleportdao: TeleportDao;
    constructor(isTestnet?: boolean, sourceNetworkConnection?: BitcoinConnectionInfo, unisatToken?: string);
    setDefaultNetwork(targetNetworkConnection: TargetNetworkSDKConnection): void;
    initNetworksConnection(networkConnectionInfos?: TargetNetworkSDKConnection[]): Promise<void>;
    addBaseNetwork(targetNetworkConnection: TargetNetworkSDKConnection): void;
    addCrossChainNetwork(targetNetworkConnection: TargetNetworkSDKConnection): void;
    addNetwork(targetNetworkConnection: TargetNetworkSDKConnection): void;
    getContracts(connectionConfig: TargetNetworkSDKConnection, contractAddresses: {
        uniswapV3ConnectorAddress: string;
        uniswapV2ConnectorAddress: string;
        uniswapV2FactoryAddress: string;
        uniswapV2RouterAddress: string;
        priceOracleAddress: string;
        relayAddress: string;
        ccTransferAddress: string;
        ccExchangeAddress: string;
        ccBurnAddress: string;
        lockerAddress: string;
        brc20RouterAddress?: string;
    }, tokenAddresses: {
        teleBTCAddress: string;
    }): {
        burnContract: contracts.CcBurnRouter;
        lockerContract: contracts.LockerContract;
        teleBTC: contracts.ERC20;
        brc20router: contracts.Brc20.BRC20 | undefined;
        uniswapV2Factory: contracts.UniSwapV2Factory;
        uniswapV2Router: contracts.UniSwapV2Router;
        uniswapV2Connector: contracts.UniswapV2Connector;
        uniswapV3Connector: contracts.UniswapV3Connector;
        ccTransfer: contracts.CcTransferRouter;
        ccExchange: contracts.CcExchangeRouter;
    };
    getCrossChainContracts(connectionConfig: TargetNetworkSDKConnection, contractAddresses: {
        teleswapEthConnector: string;
    }, tokenAddresses: object): {
        teleswapEthConnector: contracts.EthConnector;
    };
    isCrossChainNetwork(networkName: string): boolean;
    isBaseNetworkName(networkName: string): boolean;
    get bitcoinAddress(): string | undefined;
    get bitcoinAddressType(): string | undefined;
    initBitcoinAccountUsingMnemonic(mnemonic: string, addressType?: string, index?: number, mnemonicPassword?: string): string;
    initEvmAccountUsingMnemonic(mnemonic: string, index?: number, mnemonicPassword?: string): string;
    getNetwork(networkName?: string | undefined): {
        networkName: SupportedNetwork;
        baseEth: EthereumBase;
        targetConnectionConfig: ConnectionConfig;
        networkChainInfo: {
            nativeToken: string;
            name: string;
            chainId: number;
        };
        teleswapScript: TeleswapScripts;
        contracts: {
            burnContract: contracts.CcBurnRouter;
            lockerContract: contracts.LockerContract;
            teleBTC: contracts.ERC20;
            brc20router?: contracts.Brc20.BRC20 | undefined;
            uniswapV2Factory: contracts.UniSwapV2Factory;
            uniswapV2Router: contracts.UniSwapV2Router;
            uniswapV2Connector: contracts.UniswapV2Connector;
            uniswapV3Connector: contracts.UniswapV3Connector;
            ccTransfer: contracts.CcTransferRouter;
            ccExchange: contracts.CcExchangeRouter;
        };
        tokenAddress: {
            teleBTCAddress: string;
        };
        contractAddress: {
            uniswapV2Connector: string;
            uniswapV3Connector: string;
            uniswapV2FactoryV2Address: string;
            uniswapV2RouterV2Address: string;
            networkConnector?: string | undefined;
        };
    };
    getCrossChainNetwork(networkName: string): {
        networkName: CrossChainNetwork;
        baseEth: EthereumBase;
        targetConnectionConfig: ConnectionConfig;
        networkChainInfo: {
            nativeToken: string;
            name: string;
            chainId: number;
        };
        teleswapScript: TeleswapScripts;
        contracts: {
            teleswapEthConnector: contracts.EthConnector;
        };
        tokenAddress: object;
        contractAddress: object;
    };
    selectLocker(amount: string, type: "wrap" | "unwrap", networkName: TestnetAndMainnetNetwork): Promise<{
        sourceAddress: string;
        targetAddress: string;
        lockingScript: string;
    }>;
    setThirdPartyId(id: number): Promise<void>;
    wrapEstimate(amountBTC: string, networkName?: SupportedNetwork, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            fillerFeeBTC: string;
            totalFeeBTC: string;
        };
    }>;
    wrapUnsigned(recipientAddress: string, amountBTC: string, signer: SignerInfo, networkName?: SupportedNetwork, speed?: boolean, changeAddress?: string, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<{
        unsignedTransaction: string;
        outputs: import("@teleportdao/bitcoin").Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    wrapAndSwapBaseNetworkEstimate(amountBTC: string, networkName: SupportedNetwork, outputToken?: string, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmount: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            fillerFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
    }>;
    wrapAndSwapBaseNetworkUnsigned(recipientAddress: string, amountBTC: string, signer: SignerInfo, networkName?: SupportedNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, changeAddress?: string, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<{
        unsignedTransaction: string;
        outputs: import("@teleportdao/bitcoin").Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    wrapAndSwapCrossChainEstimate(amountBTC: string, networkName: CrossChainNetwork, outputToken?: string, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmount: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            fillerFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
        internalBridge: {
            path: string;
            fee: string;
        };
    }>;
    wrapAndSwapCrossChainUnsigned(recipientAddress: string, amountBTC: string, signer: SignerInfo, networkName: CrossChainNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, changeAddress?: string, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<{
        unsignedTransaction: string;
        outputs: import("@teleportdao/bitcoin").Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    wrapAndSwapEstimate(amountBTC: string, networkName: SupportedNetwork | CrossChainNetwork, outputToken?: string, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            fillerFeeBTC: string;
            totalFeeBTC: string;
        };
    } | {
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmount: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            fillerFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
    }>;
    wrapAndSwapUnsigned(recipientAddress: string, amountBTC: string, signer: SignerInfo, networkName: SupportedNetwork | CrossChainNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, changeAddress?: string, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<{
        unsignedTransaction: string;
        outputs: import("@teleportdao/bitcoin").Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    brc20WrapUnsigned(receiverAddress: string, brc: {
        tick: string;
        amount: string;
    }, signerInfo: SignerInfo, ordinalSignerInfo?: SignerInfo, staticFeeRate?: number, staticUtxo?: ExtendedUtxo[]): Promise<{
        inscribeDepositUnsignedInfo: {
            unsignedTransaction: string;
            outputs: import("@teleportdao/bitcoin").Target[];
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            fee: number;
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            possibleTxId: string | undefined;
        };
        inscribeUnsignedInfo: {
            unsignedTransaction: string;
            inputs: {
                hash: string;
                index: number;
                value: number;
            }[];
            outputs: {
                value: number;
                address: string;
            }[];
            fee: number;
            possibleTxId: string;
        };
        transferTxUnsignedInfo: {
            possibleTxId: string;
            unsignedTransaction: string;
            outputs: import("@teleportdao/bitcoin").Target[];
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            fee: number;
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        };
        inscribeAddress: string;
    }>;
    brc20WrapAndSwapUnsigned(receiverAddress: string, brc: {
        tick: string;
        amount: string;
    }, outputToken: string, signerInfo: SignerInfo, ordinalSignerInfo?: SignerInfo, minOutputAmount?: string, staticFeeRate?: number, staticUtxo?: ExtendedUtxo[]): Promise<{
        inscribeDepositUnsignedInfo: {
            unsignedTransaction: string;
            outputs: import("@teleportdao/bitcoin").Target[];
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            fee: number;
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            possibleTxId: string | undefined;
        };
        inscribeUnsignedInfo: {
            unsignedTransaction: string;
            inputs: {
                hash: string;
                index: number;
                value: number;
            }[];
            outputs: {
                value: number;
                address: string;
            }[];
            fee: number;
            possibleTxId: string;
        };
        transferTxUnsignedInfo: {
            possibleTxId: string;
            unsignedTransaction: string;
            outputs: import("@teleportdao/bitcoin").Target[];
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            fee: number;
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
        };
        inscribeAddress: string;
    }>;
    wrap(recipientAddress: string, amountBTC: string, networkName?: SupportedNetwork, speed?: boolean, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<any>;
    wrapAndSwapBaseNetwork(recipientAddress: string, amountBTC: string, networkName?: SupportedNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<any>;
    wrapAndSwapCrossChain(recipientAddress: string, amountBTC: string, networkName: CrossChainNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<any>;
    wrapAndSwap(recipientAddress: string, amountBTC: string, networkName: SupportedNetwork | CrossChainNetwork, outputToken?: string, minOutputAmount?: string, speed?: boolean, staticFeeRate?: number, staticUTXO?: ExtendedUtxo[], fullAmount?: boolean, thirdPartyId?: number): Promise<any>;
    brc20Wrap(receiverAddress: string, brc: {
        tick: string;
        amount: string;
    }, staticFeeRate?: number, staticUtxo?: ExtendedUtxo[]): Promise<{
        transferTx: {
            hash: any;
            index: number;
            value: number;
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex: number | undefined;
        };
        inscribeTx?: undefined;
        inscribeAddress?: undefined;
        inscribeDepositTx?: undefined;
    } | {
        inscribeTx: {
            hash: any;
            index: number;
            value: number;
        };
        inscribeAddress: string;
        inscribeDepositTx: {
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            hash: string;
            value: number;
            index: number;
            change?: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex?: number | undefined;
        };
        transferTx: {
            hash: any;
            index: number;
            value: number;
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex: number | undefined;
        };
    }>;
    brc20WrapAndSwap(receiverAddress: string, brc: {
        tick: string;
        amount: string;
    }, outputToken: string, minOutputAmount?: string, staticFeeRate?: number, staticUtxo?: ExtendedUtxo[]): Promise<{
        transferTx: {
            hash: any;
            index: number;
            value: number;
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex: number | undefined;
        };
        inscribeTx?: undefined;
        inscribeAddress?: undefined;
        inscribeDepositTx?: undefined;
    } | {
        inscribeTx: {
            hash: any;
            index: number;
            value: number;
        };
        inscribeAddress: string;
        inscribeDepositTx: {
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            hash: string;
            value: number;
            index: number;
            change?: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex?: number | undefined;
        };
        transferTx: {
            hash: any;
            index: number;
            value: number;
            inputs: {
                hash: string;
                value: number;
                index: number;
                signerInfo: SignerInfo;
            }[];
            change: import("@teleportdao/bitcoin").ChangeTarget | undefined;
            changeIndex: number | undefined;
        };
    }>;
    unwrapEstimate(amountBTC: string, networkName?: SupportedNetwork, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            totalFeeBTC: string;
        };
    }>;
    unwrapInputs(amountBTC: string, bitcoinAddress: string, networkName?: SupportedNetwork, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        inputs: {
            params: (string | number)[];
            value: string;
        };
    }>;
    swapAndUnwrapBaseNetworkEstimate(exchangeInfo: {
        inputAmount: string;
        inputToken?: string;
        isFixedToken?: boolean;
    }, networkName?: SupportedNetwork, thirdPartyId?: number): Promise<{
        inputAmount: string;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
        minInputAmountBTC: string;
    }>;
    swapAndUnwrapBaseNetworkInputs(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName?: SupportedNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        inputs: {
            params: (string | number | boolean | (string | number)[])[];
            value: string;
        };
    }>;
    swapAndUnwrapCrossChainEstimate(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, networkName: CrossChainNetwork, thirdPartyId?: number): Promise<{
        inputAmount: string;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
        internalBridge: {
            path: string;
            fee: string;
        };
        minInputAmountBTC: string;
    }>;
    swapAndUnwrapCrossChainInputs(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName: CrossChainNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        inputs: {
            params: (string | number | boolean | (string | number)[])[];
            value: string;
        };
    }>;
    swapAndUnwrapEstimate(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, networkName: SupportedNetwork | CrossChainNetwork, thirdPartyId?: number): Promise<{
        minInputAmountBTC: string;
        inputAmountBTC: string | number;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            totalFeeBTC: string;
        };
    } | {
        inputAmount: string;
        outputAmountBTC: string;
        teleswapFee: {
            networkFeeBTC: string;
            protocolFeeBTC: string;
            lockerFeeBTC: string;
            thirdPartyFeeBTC: string;
            totalFeeBTC: string;
        };
        internalExchange: {
            path: string;
            inputAmount: string;
            outputAmount: string;
        };
        minInputAmountBTC: string;
    }>;
    swapAndUnwrapInputs(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName: SupportedNetwork | CrossChainNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        inputs: {
            params: (string | number | boolean | (string | number)[])[];
            value: string;
        };
    }>;
    unwrap(amountBTC: string, bitcoinAddress: string, networkName?: SupportedNetwork, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        unwrapResponse: {
            success: boolean;
            receipt: {
                readonly transactionHash: string;
                readonly transactionIndex: bigint;
                readonly blockHash: string;
                readonly blockNumber: bigint;
                readonly from: string;
                readonly to: string;
                readonly cumulativeGasUsed: bigint;
                readonly gasUsed: bigint;
                readonly effectiveGasPrice?: bigint | undefined;
                readonly contractAddress?: string | undefined;
                readonly logs: {
                    readonly id?: string | undefined;
                    readonly removed?: boolean | undefined;
                    readonly logIndex?: bigint | undefined;
                    readonly transactionIndex?: bigint | undefined;
                    readonly transactionHash?: string | undefined;
                    readonly blockHash?: string | undefined;
                    readonly blockNumber?: bigint | undefined;
                    readonly address?: string | undefined;
                    readonly data?: string | undefined;
                    readonly topics?: string[] | undefined;
                }[];
                readonly logsBloom: string;
                readonly root: string;
                readonly status: bigint;
                readonly type?: bigint | undefined;
                events?: {
                    [x: string]: {
                        readonly event: string;
                        readonly id?: string | undefined;
                        readonly logIndex?: bigint | undefined;
                        readonly transactionIndex?: bigint | undefined;
                        readonly transactionHash?: string | undefined;
                        readonly blockHash?: string | undefined;
                        readonly blockNumber?: bigint | undefined;
                        readonly address: string;
                        readonly topics: string[];
                        readonly data: string;
                        readonly raw?: {
                            data: string;
                            topics: unknown[];
                        } | undefined;
                        readonly returnValues: {
                            [x: string]: unknown;
                        };
                        readonly signature?: string | undefined;
                    };
                } | undefined;
            };
            txId: string;
            message: string;
            gasPrice: string;
            gasLimit: string | undefined;
        } | {
            success: boolean;
            message: string;
            receipt: undefined;
            txId: undefined;
            gasPrice: undefined;
            gasLimit: undefined;
        };
        approveResponse: {
            amountMultipliedByDecimal: string;
            txId: string | null;
        };
    }>;
    swapAndUnwrapBaseNetwork(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName?: SupportedNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        unwrapResponse: {
            success: boolean;
            receipt: {
                readonly transactionHash: string;
                readonly transactionIndex: bigint;
                readonly blockHash: string;
                readonly blockNumber: bigint;
                readonly from: string;
                readonly to: string;
                readonly cumulativeGasUsed: bigint;
                readonly gasUsed: bigint;
                readonly effectiveGasPrice?: bigint | undefined;
                readonly contractAddress?: string | undefined;
                readonly logs: {
                    readonly id?: string | undefined;
                    readonly removed?: boolean | undefined;
                    readonly logIndex?: bigint | undefined;
                    readonly transactionIndex?: bigint | undefined;
                    readonly transactionHash?: string | undefined;
                    readonly blockHash?: string | undefined;
                    readonly blockNumber?: bigint | undefined;
                    readonly address?: string | undefined;
                    readonly data?: string | undefined;
                    readonly topics?: string[] | undefined;
                }[];
                readonly logsBloom: string;
                readonly root: string;
                readonly status: bigint;
                readonly type?: bigint | undefined;
                events?: {
                    [x: string]: {
                        readonly event: string;
                        readonly id?: string | undefined;
                        readonly logIndex?: bigint | undefined;
                        readonly transactionIndex?: bigint | undefined;
                        readonly transactionHash?: string | undefined;
                        readonly blockHash?: string | undefined;
                        readonly blockNumber?: bigint | undefined;
                        readonly address: string;
                        readonly topics: string[];
                        readonly data: string;
                        readonly raw?: {
                            data: string;
                            topics: unknown[];
                        } | undefined;
                        readonly returnValues: {
                            [x: string]: unknown;
                        };
                        readonly signature?: string | undefined;
                    };
                } | undefined;
            };
            txId: string;
            message: string;
            gasPrice: string;
            gasLimit: string | undefined;
        } | {
            success: boolean;
            message: string;
            receipt: undefined;
            txId: undefined;
            gasPrice: undefined;
            gasLimit: undefined;
        };
        approveResponse: {
            amountMultipliedByDecimal: string;
            txId: string | null;
        } | null;
    }>;
    swapAndUnwrapCrossChain(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName: CrossChainNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        unwrapResponse: {
            success: boolean;
            receipt: {
                readonly transactionHash: string;
                readonly transactionIndex: bigint;
                readonly blockHash: string;
                readonly blockNumber: bigint;
                readonly from: string;
                readonly to: string;
                readonly cumulativeGasUsed: bigint;
                readonly gasUsed: bigint;
                readonly effectiveGasPrice?: bigint | undefined;
                readonly contractAddress?: string | undefined;
                readonly logs: {
                    readonly id?: string | undefined;
                    readonly removed?: boolean | undefined;
                    readonly logIndex?: bigint | undefined;
                    readonly transactionIndex?: bigint | undefined;
                    readonly transactionHash?: string | undefined;
                    readonly blockHash?: string | undefined;
                    readonly blockNumber?: bigint | undefined;
                    readonly address?: string | undefined;
                    readonly data?: string | undefined;
                    readonly topics?: string[] | undefined;
                }[];
                readonly logsBloom: string;
                readonly root: string;
                readonly status: bigint;
                readonly type?: bigint | undefined;
                events?: {
                    [x: string]: {
                        readonly event: string;
                        readonly id?: string | undefined;
                        readonly logIndex?: bigint | undefined;
                        readonly transactionIndex?: bigint | undefined;
                        readonly transactionHash?: string | undefined;
                        readonly blockHash?: string | undefined;
                        readonly blockNumber?: bigint | undefined;
                        readonly address: string;
                        readonly topics: string[];
                        readonly data: string;
                        readonly raw?: {
                            data: string;
                            topics: unknown[];
                        } | undefined;
                        readonly returnValues: {
                            [x: string]: unknown;
                        };
                        readonly signature?: string | undefined;
                    };
                } | undefined;
            };
            txId: string;
            message: string;
            gasPrice: string;
            gasLimit: string | undefined;
        } | {
            success: boolean;
            message: string;
            receipt: undefined;
            txId: undefined;
            gasPrice: undefined;
            gasLimit: undefined;
        };
        approveResponse: {
            amountMultipliedByDecimal: string;
            txId: string | null;
        } | null;
    }>;
    swapAndUnwrap(exchangeInfo: {
        inputToken?: string;
        inputAmount: string;
        isFixedToken?: boolean;
    }, bitcoinAddress: string, networkName: SupportedNetwork | CrossChainNetwork, minBtcAmount?: string, thirdPartyId?: number): Promise<{
        locker: {
            sourceAddress: string;
            targetAddress: string;
            lockingScript: string;
        };
        unwrapResponse: {
            success: boolean;
            receipt: {
                readonly transactionHash: string;
                readonly transactionIndex: bigint;
                readonly blockHash: string;
                readonly blockNumber: bigint;
                readonly from: string;
                readonly to: string;
                readonly cumulativeGasUsed: bigint;
                readonly gasUsed: bigint;
                readonly effectiveGasPrice?: bigint | undefined;
                readonly contractAddress?: string | undefined;
                readonly logs: {
                    readonly id?: string | undefined;
                    readonly removed?: boolean | undefined;
                    readonly logIndex?: bigint | undefined;
                    readonly transactionIndex?: bigint | undefined;
                    readonly transactionHash?: string | undefined;
                    readonly blockHash?: string | undefined;
                    readonly blockNumber?: bigint | undefined;
                    readonly address?: string | undefined;
                    readonly data?: string | undefined;
                    readonly topics?: string[] | undefined;
                }[];
                readonly logsBloom: string;
                readonly root: string;
                readonly status: bigint;
                readonly type?: bigint | undefined;
                events?: {
                    [x: string]: {
                        readonly event: string;
                        readonly id?: string | undefined;
                        readonly logIndex?: bigint | undefined;
                        readonly transactionIndex?: bigint | undefined;
                        readonly transactionHash?: string | undefined;
                        readonly blockHash?: string | undefined;
                        readonly blockNumber?: bigint | undefined;
                        readonly address: string;
                        readonly topics: string[];
                        readonly data: string;
                        readonly raw?: {
                            data: string;
                            topics: unknown[];
                        } | undefined;
                        readonly returnValues: {
                            [x: string]: unknown;
                        };
                        readonly signature?: string | undefined;
                    };
                } | undefined;
            };
            txId: string;
            message: string;
            gasPrice: string;
            gasLimit: string | undefined;
        } | {
            success: boolean;
            message: string;
            receipt: undefined;
            txId: undefined;
            gasPrice: undefined;
            gasLimit: undefined;
        };
        approveResponse: {
            amountMultipliedByDecimal: string;
            txId: string | null;
        } | null;
    }>;
    brc20Unwrap(brc: {
        tick: string;
        amount: string;
    }, receiverBitcoinAddress: string): Promise<{
        success: bigint;
        txId: string;
        message?: undefined;
    } | {
        success: boolean;
        message: any;
        txId: undefined;
    }>;
    brc20UnwrapAndSwap(exchangeInfo: {
        inputAmount: string;
        inputToken: string;
    }, brc: {
        tick: string;
        amount: string;
    }, receiverBitcoinAddress: string): Promise<{
        success: bigint;
        txId: string;
        message?: undefined;
    } | {
        success: boolean;
        message: any;
        txId: undefined;
    }>;
    checkERC20BalanceAndApprove(tokenContractAddress: string, approveAddress: string, amount: string, connectionConfig: ConnectionConfig, amountInWei?: boolean): Promise<{
        amountMultipliedByDecimal: string;
        txId: string | null;
    }>;
    getUnwrapSwapPathV3(token1Address: string, token2Address: string, networkName?: SupportedNetwork): Promise<string[]>;
    getWrapSwapPathV3(token1Address: string, token2Address: string, networkName?: SupportedNetwork): Promise<string[]>;
}
export default TeleswapSDK;
//# sourceMappingURL=teleswap-sdk.d.ts.map