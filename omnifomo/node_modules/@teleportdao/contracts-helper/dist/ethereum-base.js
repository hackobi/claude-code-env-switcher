"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumBase = void 0;
const web3_1 = require("web3");
const bignumber_js_1 = require("bignumber.js");
const bip39 = __importStar(require("bip39"));
const bip32 = __importStar(require("bip32"));
const configs_1 = require("@teleportdao/configs");
BigInt.prototype.toJSON = function () {
    return this.toString();
};
class EthereumBase {
    constructor({ connectionInfo, web3Eth, gasPriceIncreasePercentage = 0 }) {
        if (web3Eth)
            this.web3Eth = web3Eth;
        else if (connectionInfo) {
            this.setProviderUsingUrl(connectionInfo);
        }
        else {
            this.web3Eth = new web3_1.Web3().eth;
        }
        this.isAccountInitialized = false;
        this.hdWalletPath = configs_1.hdWalletPath.ethereum;
        this.gasPriceIncreasePercentage = gasPriceIncreasePercentage;
        this.gasAmountIncreasePercentage = 30;
        this.config();
    }
    config() {
        this.web3Eth.transactionConfirmationBlocks = 1;
        this.web3Eth.blockHeaderTimeout = 10000;
        this.web3Eth.transactionPollingInterval = 30000;
        this.web3Eth.transactionConfirmationPollingInterval = 30000;
        this.web3Eth.transactionPollingTimeout = 180000;
        this.web3Eth.transactionSendTimeout = 180000;
        this.web3Eth.transactionReceiptPollingInterval = 5000;
    }
    static validateEthAddress(adr) {
        try {
            const web3 = new web3_1.Web3();
            web3.utils.toChecksumAddress(adr);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    static extractEventTxInfo(rawEvent) {
        const { blockNumber, logIndex, transactionHash, event: eventName, signature } = rawEvent;
        return {
            blockNumber: +blockNumber.toString(),
            logIndex: +logIndex.toString(),
            transactionHash: transactionHash,
            eventName,
            signature: signature,
        };
    }
    setProviderUsingUrl({ url, headers = undefined }) {
        if (url.startsWith("ws")) {
            this.setWssProviderUsingUrl({ url, headers });
        }
        else {
            this.setHttpProviderUsingUrl({ url, headers });
        }
    }
    setWssProviderUsingUrl({ url, headers = undefined }, { reconnectSleep = 30000 } = {}) {
        const provider = new web3_1.WebSocketProvider(url, {
            headers,
        }, {
            autoReconnect: true,
            delay: 10000,
            maxAttempts: 3,
        });
        this.setWeb3EthProvider(provider);
        provider.on("connect", () => {
            console.log(`${new Date().toUTCString()}-- Web3 WS Connected - url : ${url}`);
        });
        provider.on("error", (e) => {
            console.log(`${new Date().toUTCString()}-- websocket error ${e.message}`);
            if (e.message.includes("Maximum number of reconnect attempts reached")) {
                provider.disconnect();
            }
        });
        provider.on("disconnect", () => {
            console.log(`${new Date().toUTCString()}-- websocket disconnected try reconnecting ...`);
            setTimeout(() => {
                provider.connect();
            }, reconnectSleep);
        });
    }
    setHttpProviderUsingUrl({ url, headers = undefined }) {
        this.setWeb3EthProvider(new web3_1.HttpProvider(url, {
            providerOptions: {
                headers,
            },
        }));
    }
    setWeb3EthProvider(provider) {
        if (this.web3Eth) {
            this.web3Eth.setProvider(provider);
        }
        else {
            this.web3Eth = new web3_1.Web3(provider).eth;
        }
    }
    setCurrentAccount(address) {
        if (this.web3Eth.accounts.wallet.get(address)) {
            this.isAccountInitialized = true;
        }
        this.currentAccount = address;
    }
    addAccountByPrivateKey(privateKeyHex) {
        const ethPrivateKeyHex = privateKeyHex.startsWith("0x") ? privateKeyHex : `0x${privateKeyHex}`;
        const account = this.web3Eth.accounts.privateKeyToAccount(ethPrivateKeyHex);
        const wallet = this.web3Eth.accounts.wallet.add(account);
        if (!wallet.get(account.address))
            throw new Error("invalid private key");
        if (!this.currentAccount)
            this.setCurrentAccount(account.address);
        if (!this.currentAccount)
            throw new Error("account is not set correctly");
        return account.address;
    }
    addAccountByMnemonic({ mnemonic, mnemonicPassword = "", index = 0, walletNumber = 0, }) {
        if (!bip39.validateMnemonic(mnemonic))
            throw new Error("invalid mnemonic");
        const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword);
        const node = bip32.fromSeed(seed);
        const path = `${this.hdWalletPath}/${walletNumber}`;
        const account = node.derivePath(path);
        const userKeyPair = account.derive(index);
        if (!userKeyPair.privateKey)
            throw new Error("invalid privatekey");
        return this.addAccountByPrivateKey(`0x${userKeyPair.privateKey.toString("hex")}`);
    }
    getLatestBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3Eth.getBlock(yield this.getLatestBlockNumber());
        });
    }
    getLatestBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3Eth.getBlockNumber();
        });
    }
    getNumberOfConfirmedTransactions(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.web3Eth.getTransactionCount(address);
        });
    }
    getNumberOfMemPoolTransactions(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const confirmedTxNum = yield this.getNumberOfConfirmedTransactions(address);
            const allTxNum = yield this.web3Eth.getTransactionCount(address, "pending");
            return allTxNum - confirmedTxNum;
        });
    }
    checkCurrentAccountBalance(warningMinAmount = 0.01 * 1e18, errorMinAmount = 0.005 * 1e18) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.currentAccount)
                throw new Error("account is not initialized");
            const walletBalance = yield this.web3Eth.getBalance(this.currentAccount);
            return {
                address: this.currentAccount,
                balance: new bignumber_js_1.BigNumber(walletBalance.toString()).dividedBy(1e18).toString(),
                warningMinAmount: new bignumber_js_1.BigNumber(warningMinAmount).dividedBy(1e18).toFixed(8),
                errorMinAmount: new bignumber_js_1.BigNumber(errorMinAmount).dividedBy(1e18).toFixed(8),
                warning: new bignumber_js_1.BigNumber(walletBalance.toString()).isLessThan(warningMinAmount),
                error: new bignumber_js_1.BigNumber(walletBalance.toString()).isLessThan(errorMinAmount),
            };
        });
    }
    checkCurrentAccountBalanceForContractCall({ maximumGasLimit = 1000000, NumberOfCallForWarning = 30, NumberOfCallForError = 1, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = new bignumber_js_1.BigNumber((yield this.web3Eth.getGasPrice()).toString())
                .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
                .toFixed(0);
            const fee = new bignumber_js_1.BigNumber(maximumGasLimit).multipliedBy(gasPrice);
            const warningAmount = fee.multipliedBy(NumberOfCallForWarning).toFixed(10);
            const errorAmount = fee.multipliedBy(NumberOfCallForError).toFixed(10);
            return this.checkCurrentAccountBalance(warningAmount, errorAmount);
        });
    }
    getTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.web3Eth.getTransaction(txId);
            return tx;
        });
    }
    sendEth(receiver, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const value = new bignumber_js_1.BigNumber(amount).multipliedBy(1e18).toFixed(0);
            const gasPrice = new bignumber_js_1.BigNumber((yield this.web3Eth.getGasPrice()).toString())
                .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
                .toFixed(0);
            const tx = yield this.web3Eth.sendTransaction({
                from: this.currentAccount,
                gasPrice,
                gas: 21000,
                to: receiver,
                value,
            });
            return tx;
        });
    }
    sendAllEth(receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.currentAccount) {
                throw new Error("account is not initialized");
            }
            const gasPrice = new bignumber_js_1.BigNumber((yield this.web3Eth.getGasPrice()).toString())
                .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
                .toFixed(0);
            const balance = yield this.web3Eth.getBalance(this.currentAccount);
            const value = (0, bignumber_js_1.BigNumber)(balance.toString())
                .minus((0, bignumber_js_1.BigNumber)(gasPrice).multipliedBy(21000))
                .toFixed(0);
            if (+value < 0) {
                throw new Error(`not enough balance: ${balance}`);
            }
            const tx = yield this.web3Eth.sendTransaction({
                from: this.currentAccount,
                gasPrice,
                gas: 21000,
                to: receiver,
                value,
            });
            return { tx, value };
        });
    }
}
exports.EthereumBase = EthereumBase;
exports.default = EthereumBase;
//# sourceMappingURL=ethereum-base.js.map