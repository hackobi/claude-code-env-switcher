"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseContract = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereum_base_1 = require("../ethereum-base");
const utils_1 = require("../utils");
class BaseContract extends ethereum_base_1.EthereumBase {
    constructor(connectionConfig, contractAddress, ABI) {
        super(connectionConfig);
        this.contractAddress = contractAddress;
        this.contract = new this.web3Eth.Contract(ABI, contractAddress);
        this.configContract();
    }
    configContract() {
        this.contract.handleRevert = true;
        this.contract.transactionConfirmationBlocks = 1;
        this.contract.blockHeaderTimeout = 30;
        this.contract.transactionPollingInterval = 30000;
        this.contract.transactionConfirmationPollingInterval = 30000;
        this.contract.transactionPollingTimeout = 180000;
        this.contract.transactionSendTimeout = 180000;
        this.contract.transactionReceiptPollingInterval = 5000;
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            const baseGasPrice = new bignumber_js_1.default((yield this.web3Eth.getGasPrice()).toString());
            return baseGasPrice.multipliedBy(1 + this.gasPriceIncreasePercentage / 100).toFixed(0);
        });
    }
    contractSendMethod(methodName, value, params = []) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = yield this.getGasPrice();
            const method = this.contract.methods[methodName];
            if (!method)
                throw new Error(`Method ${methodName} does not exist on the contract`);
            let gasAmount;
            try {
                gasAmount = yield method(...params).estimateGas({
                    from: this.currentAccount,
                    gasPrice,
                    value,
                });
                const gas = (0, bignumber_js_1.default)(gasAmount.toString()).multipliedBy(1.1).toFixed(0);
                const receipt = yield method(...params).send({
                    from: this.currentAccount,
                    gasPrice,
                    value,
                    gas,
                });
                return {
                    success: receipt.status === BigInt(1),
                    txId: receipt.transactionHash,
                    message: "transaction is sent successfully",
                    receipt,
                    gasPrice,
                    gasLimit: gasAmount.toString(),
                };
            }
            catch (err) {
                if (err.receipt) {
                    const receipt = err.receipt;
                    return {
                        success: false,
                        receipt,
                        txId: receipt.transactionHash,
                        message: `[code: ${err.code}] -> ${((_a = err.cause) === null || _a === void 0 ? void 0 : _a.message) || err.message}`,
                        gasPrice,
                        gasLimit: gasAmount === null || gasAmount === void 0 ? void 0 : gasAmount.toString(),
                    };
                }
                throw err;
            }
        });
    }
    contractSendMethodNoError(methodName, value, params = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethod(methodName, value, params).catch((error) => {
                var _a;
                return ({
                    success: false,
                    message: `[code: ${error.code}] -> ${((_a = error.cause) === null || _a === void 0 ? void 0 : _a.message) || error.message}`,
                    receipt: undefined,
                    txId: undefined,
                    gasPrice: undefined,
                    gasLimit: undefined,
                });
            });
        });
    }
    getPastEventsWithRange(eventName, fromBlock, blockRange, toBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            const lastBlock = toBlock || (yield this.getLatestBlockNumber());
            let block = +fromBlock;
            const events = [];
            while (block <= +lastBlock.toString()) {
                const rEvents = yield this.contract.getPastEvents(eventName, {
                    fromBlock: block,
                    toBlock: Math.min(+lastBlock.toString(), block + blockRange),
                });
                events.push(...rEvents);
                block += blockRange + 1;
            }
            return events.filter((e) => typeof e !== "string");
        });
    }
    static parseEvent(event) {
        const txInfo = this.extractEventTxInfo(event);
        return {
            txInfo,
            event: (0, utils_1.removeNumbersInContractEvent)(event).returnValues,
        };
    }
}
exports.BaseContract = BaseContract;
exports.default = BaseContract;
//# sourceMappingURL=contract-base.js.map