"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BRC20 = void 0;
const brc20_1 = require("../../abis/brc20");
const contract_base_1 = __importDefault(require("../contract-base"));
class BRC20 extends contract_base_1.default {
    constructor(connectionConfig, contractAddress) {
        super(connectionConfig, contractAddress, brc20_1.Brc20RouterABI);
    }
    startingBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.contract.methods.startingBlockNumber().call();
            return +res.toString();
        });
    }
    getProtocolPercentageFee() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.protocolPercentageFee().call();
        });
    }
    isWrapRequestProcessed(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`;
            let isUsed = yield this.contract.methods.isWrapRequestProcessed(txIdWith0x).call();
            return !!isUsed;
        });
    }
    isUnwrapRequestProcessed(counter) {
        return __awaiter(this, void 0, void 0, function* () {
            let isUsed = yield this.contract.methods.isUnwrapRequestProcessed(counter).call();
            return !!isUsed;
        });
    }
    getWrappedBrc20Address(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            let address = yield this.contract.methods.supportedBrc20s(tokenId).call();
            return address;
        });
    }
    getTokenId(tick) {
        return __awaiter(this, void 0, void 0, function* () {
            let tokenId = yield this.contract.methods.tokenIds(tick).call();
            if (tokenId === BigInt(0))
                return undefined;
            return +tokenId.toString();
        });
    }
    getLockerInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let targetAddress = yield this.contract.methods.locker().call();
            let lockingScript = yield this.contract.methods.lockerLockingScript().call();
            return {
                targetAddress,
                lockingScript,
            };
        });
    }
    getTeleporterAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            let targetAddress = yield this.contract.methods.teleporter().call();
            return targetAddress;
        });
    }
    wrapBrc20(parsedTx, merkleProof, blockNumber, blockFee, exchangePath, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!blockFee)
                    throw new Error("block fee not exist");
                const response = yield this.contractSendMethod("wrapBrc20", (+blockFee * 1.3).toFixed(), [
                    parsedTx.version,
                    parsedTx.vin,
                    parsedTx.vout,
                    parsedTx.locktime,
                    blockNumber,
                    merkleProof.intermediateNodes,
                    merkleProof.transactionIndex,
                    exchangePath || [],
                ]);
                return {
                    success: response.receipt.status,
                    txId: response.receipt.transactionHash,
                };
            }
            catch (error) {
                console.log("***********error******", JSON.stringify(error.message));
                return {
                    success: false,
                    message: error.message,
                    txId: undefined,
                };
            }
        });
    }
    unwrapBrc20(amount, tokenId, receiverBitcoinAddressScript, receiverAddressTypeNumber, appId, exchange) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.contractSendMethod("unwrapBrc20", "0", [
                    tokenId,
                    amount,
                    receiverBitcoinAddressScript,
                    receiverAddressTypeNumber,
                    appId,
                    (exchange === null || exchange === void 0 ? void 0 : exchange.inputAmount) || "0",
                    (exchange === null || exchange === void 0 ? void 0 : exchange.path) || [],
                ]);
                return {
                    success: response.receipt.status,
                    txId: response.receipt.transactionHash,
                };
            }
            catch (error) {
                console.log("***********error******", JSON.stringify(error.message));
                return {
                    success: false,
                    message: error.message,
                    txId: undefined,
                };
            }
        });
    }
    unwrapProof(parsedTx, merkleProof, blockNumber, blockFee, requestIndexes, nonce = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!blockFee)
                    throw new Error("block fee not exist");
                const response = yield this.contractSendMethod("unwrapProof", (+blockFee * 1.3).toFixed(), [
                    parsedTx.version,
                    parsedTx.vin,
                    parsedTx.vout,
                    parsedTx.locktime,
                    blockNumber,
                    merkleProof.intermediateNodes,
                    merkleProof.transactionIndex,
                    requestIndexes,
                ]);
                return {
                    success: response.receipt.status,
                    txId: response.receipt.transactionHash,
                };
            }
            catch (error) {
                console.log("***********error******", JSON.stringify(error.message));
                return {
                    success: false,
                    message: error.message,
                    txId: undefined,
                };
            }
        });
    }
    getPastEventsWithRange(eventName, fromBlock, blockRange) {
        return __awaiter(this, void 0, void 0, function* () {
            const lastBlock = yield this.getLatestBlockNumber();
            let block = +fromBlock;
            const events = [];
            while (block <= +lastBlock.toString()) {
                const rEvents = yield this.contract.getPastEvents(eventName, {
                    fromBlock: block,
                    toBlock: Math.min(+lastBlock.toString(), block + blockRange),
                });
                events.push(...rEvents);
                block += blockRange + 1;
            }
            return events.filter((e) => typeof e !== "string");
        });
    }
}
exports.BRC20 = BRC20;
exports.default = BRC20;
//# sourceMappingURL=brc20-interface.js.map