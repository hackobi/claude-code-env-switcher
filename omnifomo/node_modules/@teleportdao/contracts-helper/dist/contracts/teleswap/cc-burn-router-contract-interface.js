"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CcBurnRouter = void 0;
const abis_1 = require("../../abis");
const contract_base_1 = __importDefault(require("../contract-base"));
class CcBurnRouter extends contract_base_1.default {
    constructor(connectionConfig, contractAddress) {
        super(connectionConfig, contractAddress, abis_1.CCBurnRouterABI);
    }
    getProtocolPercentageFee() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.protocolPercentageFee().call();
        });
    }
    startingBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.contract.methods.startingBlockNumber().call();
            return res;
        });
    }
    getBitcoinFee() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.bitcoinFee().call();
        });
    }
    isTransferred(lockerTargetAddress, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.isTransferred(lockerTargetAddress, index).call();
        });
    }
    burnRequests(lockerTargetAddress, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.burnRequests(lockerTargetAddress, index).call();
        });
    }
    isUsedAsBurnProof(bitcoinTxId) {
        return __awaiter(this, void 0, void 0, function* () {
            const txIdWith0x = `0x${Buffer.from(bitcoinTxId, "hex").reverse().toString("hex")}`;
            return this.contract.methods.isUsedAsBurnProof(txIdWith0x).call();
        });
    }
    getBurnTransferDeadline() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.transferDeadline().call();
        });
    }
    thirdPartyFee(thirdPartId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contract.methods.thirdPartyFee(thirdPartId).call();
        });
    }
    sendBurnProof(parsedTx, merkleProof, blockNumber, requestIndexes, voutIndexes, lockerLockingScript, blockFee, nonce = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!blockFee)
                throw new Error("block fee not exist");
            return this.contractSendMethodNoError("burnProof", (+blockFee * 1.3).toFixed(), [
                parsedTx.version,
                parsedTx.vin,
                parsedTx.vout,
                parsedTx.locktime,
                blockNumber,
                merkleProof.intermediateNodes,
                merkleProof.transactionIndex,
                lockerLockingScript,
                requestIndexes,
                voutIndexes,
            ]);
        });
    }
    disputeBurn(lockerLockingScript, arrayOfRequestIndexes, nonce = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethodNoError("disputeBurn", "0", [
                lockerLockingScript,
                arrayOfRequestIndexes,
            ]);
        });
    }
    disputeLocker(lockerLockingScript, input, output, outVinIndex, blockFee, nonce = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!blockFee)
                throw new Error("block fee not exist");
            return this.contractSendMethodNoError("disputeLocker", (+blockFee * 1.3).toFixed(), [
                lockerLockingScript,
                [input.parsedTx.version, output.parsedTx.version],
                input.parsedTx.vin,
                input.parsedTx.vout,
                output.parsedTx.vin,
                output.parsedTx.vout,
                [input.parsedTx.locktime, output.parsedTx.locktime],
                input.merkleProof.intermediateNodes,
                [outVinIndex, input.merkleProof.transactionIndex, input.blockNumber],
            ]);
        });
    }
    static unwrapParams(amount, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId = 0) {
        const value = "0";
        const params = [
            amount,
            receiverBitcoinScript,
            addressTypeNumber,
            lockerLockingScript,
            thirdPartyId,
        ];
        return {
            params,
            value,
        };
    }
    unwrap(amount, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const { value, params } = CcBurnRouter.unwrapParams(amount, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId);
            return this.contractSendMethodNoError("unwrap", value, params);
        });
    }
    static swapAndUnwrapParams(exchangeInfo, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId = 0) {
        const value = exchangeInfo.isNativeToken === true ? exchangeInfo.inputAmount.toString() : "0";
        const params = [
            exchangeInfo.exchangeConnector,
            [exchangeInfo.inputAmount, exchangeInfo.outputAmount],
            exchangeInfo.isFixedToken,
            exchangeInfo.path,
            exchangeInfo.deadline,
            receiverBitcoinScript,
            addressTypeNumber,
            lockerLockingScript,
            thirdPartyId,
        ];
        return {
            params,
            value,
        };
    }
    swapAndUnwrap(exchangeInfo, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const { value, params } = CcBurnRouter.swapAndUnwrapParams(exchangeInfo, receiverBitcoinScript, addressTypeNumber, lockerLockingScript, thirdPartyId);
            return this.contractSendMethodNoError("swapAndUnwrap", value, params);
        });
    }
    setNetworkFee(networkFee) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.contractSendMethodNoError("setNetworkFee", "0", [networkFee]);
        });
    }
    getNewUnwrapEvents(fromBlock = 0, blockRange = 10000, toBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getPastEventsWithRange("NewUnwrap", fromBlock, blockRange, toBlock)).map((event) => CcBurnRouter.parseEvent(event));
        });
    }
    getPaidUnwrapEvents(fromBlock = 0, blockRange = 10000, toBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getPastEventsWithRange("PaidUnwrap", fromBlock, blockRange, toBlock)).map((event) => CcBurnRouter.parseEvent(event));
        });
    }
    getBurnDisputeEvents(fromBlock = 0, blockRange = 10000, toBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getPastEventsWithRange("BurnDispute", fromBlock, blockRange, toBlock)).map((event) => CcBurnRouter.parseEvent(event));
        });
    }
    getLockerDisputeEvents(fromBlock = 0, blockRange = 10000, toBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getPastEventsWithRange("LockerDispute", fromBlock, blockRange, toBlock)).map((event) => CcBurnRouter.parseEvent(event));
        });
    }
}
exports.CcBurnRouter = CcBurnRouter;
exports.default = CcBurnRouter;
//# sourceMappingURL=cc-burn-router-contract-interface.js.map