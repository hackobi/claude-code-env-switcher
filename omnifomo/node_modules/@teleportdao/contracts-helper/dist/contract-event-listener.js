"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractEventListener = void 0;
const web3_1 = __importDefault(require("web3"));
const queue_1 = require("./queue");
const utils_1 = require("./utils");
class ContractEventListener {
    constructor(contract, contractName, errorHandler = (error, moreInfo) => {
        console.log(`${new Date().toUTCString()}  ${typeof error === "string" ? error : (error === null || error === void 0 ? void 0 : error.message) || ""} ----> ${JSON.stringify(moreInfo)}`);
    }, inOrder = false, wssConfig = {
        reSubscribeTime: 30000,
    }, httpConfig = { delayBetweenRounds: 60000, blockRange: 1000 }) {
        this.contractName = contractName;
        this.contract = contract;
        this.wssConfig = wssConfig;
        this.httpConfig = httpConfig;
        this.errorHandler = errorHandler;
        this.listeners = {};
        this.inOrder = inOrder;
        this.web3 = new web3_1.default(this.contract.provider);
    }
    static getEventId(event) {
        return `${event.event}:${event.transactionHash}:${event.logIndex}:${event.blockNumber}`;
    }
    addListener(eventName, handler, lastBlock, httpConfig) {
        if (this.listeners[eventName]) {
            throw new Error(`listener for ${eventName} already exists`);
        }
        const queue = new queue_1.JobQueueInOrder(false, (job) => handler(job.data));
        const listenerHandler = this.inOrder
            ? (event) => __awaiter(this, void 0, void 0, function* () {
                return queue.addJob({
                    id: ContractEventListener.getEventId(event),
                    data: event,
                });
            })
            : handler;
        this.listeners[eventName] = {
            isSubscribe: false,
            lastBlock,
            eventEmitter: undefined,
            queue,
            handler: listenerHandler,
            httpConfig,
        };
    }
    getPastEventsWithRange(eventName, fromBlock, blockRange) {
        return __awaiter(this, void 0, void 0, function* () {
            const web3Eth = this.web3.eth;
            const lastBlock = yield web3Eth.getBlockNumber();
            let block = +fromBlock.toString();
            const events = [];
            while (block <= +lastBlock.toString()) {
                const rEvents = yield this.contract.getPastEvents(eventName, {
                    fromBlock: block,
                    toBlock: Math.min(+lastBlock.toString(), block + blockRange),
                });
                events.push(...rEvents);
                block += blockRange + 1;
            }
            return {
                events: events.filter((e) => typeof e !== "string"),
                lastBlock: lastBlock.toString(),
            };
        });
    }
    websocketListenOnEventOrResetConnection(eventName, numberOfRetry = 0) {
        var _a, _b, _c, _d;
        try {
            let reSubscribe = false;
            const listener = this.listeners[eventName];
            if (!listener) {
                throw new Error(`listener for ${eventName} not exists`);
            }
            if (listener.isSubscribe) {
                console.log("its ok .............................");
                return;
            }
            if (listener.eventEmitter) {
                listener.eventEmitter.removeAllListeners();
                listener.eventEmitter = undefined;
            }
            if (((_a = this.contract.provider) === null || _a === void 0 ? void 0 : _a.getStatus()) !== "connected") {
                (_b = this.contract.provider) === null || _b === void 0 ? void 0 : _b.once("connect", () => {
                    this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1);
                });
                return;
            }
            (_c = this.contract.provider) === null || _c === void 0 ? void 0 : _c.once("disconnect", (err) => __awaiter(this, void 0, void 0, function* () {
                if (reSubscribe)
                    return;
                reSubscribe = true;
                listener.isSubscribe = false;
                this.errorHandler(err || "", {
                    eventName,
                    numberOfRetry,
                    type: `disconnected.try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
                });
                yield (0, utils_1.sleep)(this.wssConfig.reSubscribeTime);
                this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1);
            }));
            (_d = this.contract.provider) === null || _d === void 0 ? void 0 : _d.once("connect", (err) => __awaiter(this, void 0, void 0, function* () {
                if (reSubscribe)
                    return;
                reSubscribe = true;
                listener.isSubscribe = false;
                this.errorHandler(err || "", {
                    eventName,
                    numberOfRetry,
                    type: `connected.try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
                });
                yield (0, utils_1.sleep)(this.wssConfig.reSubscribeTime);
                this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1);
            }));
            listener.eventEmitter = this.contract.events[eventName]({
                fromBlock: listener.lastBlock || "latest",
            });
            listener.eventEmitter.on("error", (err) => __awaiter(this, void 0, void 0, function* () {
                this.errorHandler(err, { eventName, numberOfRetry, type: "error" });
                if (reSubscribe)
                    return;
                this.errorHandler("", {
                    message: `try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
                });
                reSubscribe = true;
                listener.isSubscribe = false;
                yield (0, utils_1.sleep)(this.wssConfig.reSubscribeTime);
                this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1);
            }));
            listener.eventEmitter.on("connected", (subscriptionId) => {
                console.log(`${this.contractName} ${eventName} event subscriptionId: ${subscriptionId}`);
                listener.isSubscribe = true;
                reSubscribe = false;
            });
            listener.eventEmitter.on("data", (event) => __awaiter(this, void 0, void 0, function* () {
                listener.handler(event);
                if (event.blockNumber) {
                    listener.lastBlock = Math.max(+event.blockNumber.toString() + 1, listener.lastBlock || 0);
                }
            }));
            listener.eventEmitter.on("changed", (event) => __awaiter(this, void 0, void 0, function* () {
                this.errorHandler("event changed", {
                    eventName,
                    returnValues: event.returnValues,
                    txId: event.transactionHash,
                    logIndex: event.logIndex,
                    removed: event.removed,
                    type: "end",
                });
            }));
        }
        catch (e) {
            console.log(e.message);
        }
    }
    httpListenOnEventOrResetConnection(eventName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const listener = this.listeners[eventName];
                const blockRange = ((_a = listener.httpConfig) === null || _a === void 0 ? void 0 : _a.blockRange) || this.httpConfig.blockRange;
                const delayBetweenRounds = ((_b = listener.httpConfig) === null || _b === void 0 ? void 0 : _b.delayBetweenRounds) || this.httpConfig.delayBetweenRounds;
                listener.lastBlock = listener.lastBlock || +(yield this.web3.eth.getBlockNumber()).toString();
                listener.isSubscribe = true;
                while (listener.isSubscribe) {
                    const { events, lastBlock, } = yield this.getPastEventsWithRange(eventName, listener.lastBlock, blockRange);
                    for (const event of events) {
                        listener.handler(event);
                    }
                    listener.lastBlock = +lastBlock + 1;
                    yield (0, utils_1.sleep)(delayBetweenRounds);
                }
            }
            catch (e) {
                this.errorHandler(e, { eventName, type: "httpListenOnEventOrResetConnection" });
                yield (0, utils_1.sleep)(30000);
                this.httpListenOnEventOrResetConnection(eventName);
            }
        });
    }
    listenOnEventOrResetConnection(eventName) {
        var _a;
        if ((_a = this.contract.provider) === null || _a === void 0 ? void 0 : _a.supportsSubscriptions()) {
            this.websocketListenOnEventOrResetConnection(eventName);
            return;
        }
        this.httpListenOnEventOrResetConnection(eventName);
    }
    stopListenOnEvent(eventName) {
        const listener = this.listeners[eventName];
        if (listener) {
            listener.isSubscribe = false;
            if (listener.eventEmitter) {
                listener.eventEmitter.unsubscribe();
                listener.eventEmitter.removeAllListeners();
                listener.eventEmitter = undefined;
            }
        }
    }
    removeListener(eventName) {
        this.stopListenOnEvent(eventName);
        delete this.listeners[eventName];
    }
}
exports.ContractEventListener = ContractEventListener;
//# sourceMappingURL=contract-event-listener.js.map