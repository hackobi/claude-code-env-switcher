import { Contract, EventLog } from "web3-eth-contract"
import { ContractAbi, TransactionReceipt, FormatType, DEFAULT_RETURN_FORMAT } from "web3"
import BigNumber from "bignumber.js"
import { ConnectionConfig } from "../types/eth"
import { EthereumBase } from "../ethereum-base"
import { removeNumbersInContractEvent } from "../utils"

export class BaseContract<AbiType extends ContractAbi> extends EthereumBase {
  contract: Contract<AbiType>
  contractAddress: string

  constructor(connectionConfig: ConnectionConfig, contractAddress: string, ABI: AbiType) {
    super(connectionConfig)
    this.contractAddress = contractAddress
    this.contract = new this.web3Eth.Contract(ABI, contractAddress)
    this.configContract()
  }

  configContract() {
    this.contract.handleRevert = true
    //
    this.contract.transactionConfirmationBlocks = 1 // 24
    // socket
    this.contract.blockHeaderTimeout = 30 // 10
    //   this.contract.transactionBlockTimeout // 50
    // http
    this.contract.transactionPollingInterval = 30_000 // 1000
    this.contract.transactionConfirmationPollingInterval = 30_000 // 1000
    //
    this.contract.transactionPollingTimeout = 180_000 // 750000
    this.contract.transactionSendTimeout = 180_000 // 750000
    //
    this.contract.transactionReceiptPollingInterval = 5_000 // 1000
  }

  async getGasPrice(): Promise<string> {
    const baseGasPrice = new BigNumber((await this.web3Eth.getGasPrice()).toString())
    return baseGasPrice.multipliedBy(1 + this.gasPriceIncreasePercentage / 100).toFixed(0)
  }

  async contractSendMethod(methodName: string, value: string, params: any[] = []) {
    const gasPrice = await this.getGasPrice()
    const method = this.contract.methods[methodName]
    if (!method) throw new Error(`Method ${methodName} does not exist on the contract`)

    let gasAmount: bigint | undefined
    try {
      gasAmount = await method(...params).estimateGas({
        from: this.currentAccount,
        gasPrice,
        value,
      })
      // calculate gas amount 10 % more than the estimated
      const gas = BigNumber(gasAmount.toString()).multipliedBy(1.1).toFixed(0)

      const receipt = await method(...params).send({
        from: this.currentAccount,
        gasPrice,
        value,
        gas,
      })

      return {
        success: receipt.status === BigInt(1),
        txId: receipt.transactionHash,
        message: "transaction is sent successfully",
        receipt,
        gasPrice,
        gasLimit: gasAmount.toString(),
      }
    } catch (err: any) {
      if (err.receipt) {
        const receipt = err.receipt as FormatType<TransactionReceipt, typeof DEFAULT_RETURN_FORMAT>
        return {
          success: false,
          receipt,
          txId: receipt.transactionHash,
          message: `[code: ${err.code}] -> ${err.cause?.message || err.message}`,
          gasPrice,
          gasLimit: gasAmount?.toString(),
        }
      }
      throw err
    }
  }

  async contractSendMethodNoError(methodName: string, value: string, params: any[] = []) {
    return this.contractSendMethod(methodName, value, params).catch((error: any) => ({
      success: false,
      message: `[code: ${error.code}] -> ${error.cause?.message || error.message}`,
      receipt: undefined,
      txId: undefined,
      gasPrice: undefined,
      gasLimit: undefined,
    }))
  }

  async getPastEventsWithRange(
    eventName: string,
    fromBlock: number,
    blockRange: number,
    toBlock?: number,
  ) {
    const lastBlock = toBlock || (await this.getLatestBlockNumber())
    let block = +fromBlock
    const events = []
    while (block <= +lastBlock.toString()) {
      const rEvents = await this.contract.getPastEvents(eventName, {
        fromBlock: block,
        toBlock: Math.min(+lastBlock.toString(), block + blockRange),
      })
      events.push(...rEvents)
      block += blockRange + 1
    }
    return events.filter((e) => typeof e !== "string") as EventLog[]
  }

  static parseEvent<EventType>(event: EventLog) {
    const txInfo = this.extractEventTxInfo(event)
    return {
      txInfo,
      event: removeNumbersInContractEvent(event).returnValues as EventType,
    }
  }
}

export default BaseContract
