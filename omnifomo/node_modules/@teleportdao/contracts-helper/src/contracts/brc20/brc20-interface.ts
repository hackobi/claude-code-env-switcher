import { EventLog } from "web3"
import { Brc20RouterABI } from "../../abis/brc20"
import { ConnectionConfig } from "../../types"
import { removeNumbersInContractEvent } from "../../utils"
import BaseContract from "../contract-base"
// import { deleteEventNumbers } from "../utils/eth-utils"
// import { zeroAddress } from "./constant"

export type NewWrap = {
  user: string
  remainingAmount: bigint
  inputToken: string
  fee: {
    protocolFee: bigint
    lockerFee: bigint
    thirdPartyFee: bigint
  }
  txId: string
}

export type NewWrapAndSwap = {
  user: string
  remainingAmount: bigint
  inputToken: string
  outputAmount: bigint
  outputToken: string
  fee: {
    protocolFee: bigint
    lockerFee: bigint
    thirdPartyFee: bigint
  }
  txId: string
}

export type FailedWrapAndSwap = {
  user: string
  remainingAmount: bigint
  inputToken: string
  outputAmount: bigint
  outputToken: string
  fee: {
    protocolFee: bigint
    lockerFee: bigint
    thirdPartyFee: bigint
  }
  txId: string
}

export type Unwrap = {
  user: string
  userScript: string
  scriptType: string
  inputToken: string
  inputAmount: string
  remainingAmount: string
  protocolFee: string
  lockerFee: string
  reqIdx: string
}

export type UnwrapAndSwap = {
  user: string
  userScript: string
  scriptType: string
  inputAmount: string
  inputToken: string
  outputAmount: string
  remainingAmount: string
  outputToken: string
  protocolFee: string
  lockerFee: string
  reqIdx: string
}

export type ProcessedUnwrap = {
  user: string
  remainingAmount: string
  userScript: string
  scriptType: number
  reqIdx: string
}

export type UnwrapAndTxInfo = Unwrap & {
  txInfo: {
    blockNumber: number
    logIndex: number
    transactionHash: string
    eventName: string
    signature: string
  }
}

export type UnwrapAndSwapAndTxInfo = UnwrapAndSwap & {
  txInfo: {
    blockNumber: number
    logIndex: number
    transactionHash: string
    eventName: string
    signature: string
  }
}

export class BRC20 extends BaseContract<typeof Brc20RouterABI> {
  constructor(connectionConfig: ConnectionConfig, contractAddress: string) {
    super(connectionConfig, contractAddress, Brc20RouterABI)
  }

  async startingBlockNumber() {
    const res = await this.contract.methods.startingBlockNumber().call()
    return +res.toString()
  }

  async getProtocolPercentageFee() {
    return this.contract.methods.protocolPercentageFee().call()
  }

  async isWrapRequestProcessed(txId: string) {
    let txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`
    let isUsed = await this.contract.methods.isWrapRequestProcessed(txIdWith0x).call()
    return !!isUsed
  }

  async isUnwrapRequestProcessed(counter: number) {
    let isUsed = await this.contract.methods.isUnwrapRequestProcessed(counter).call()
    return !!isUsed
  }

  async getWrappedBrc20Address(tokenId: number) {
    let address = await this.contract.methods.supportedBrc20s(tokenId).call()
    return address
  }

  async getTokenId(tick: string) {
    let tokenId = await this.contract.methods.tokenIds(tick).call()
    if (tokenId === BigInt(0)) return undefined
    return +tokenId.toString()
  }

  async getLockerInfo() {
    let targetAddress = await this.contract.methods.locker().call()
    let lockingScript: string = await this.contract.methods.lockerLockingScript().call()
    return {
      targetAddress,
      lockingScript,
    }
  }

  async getTeleporterAddress() {
    let targetAddress = await this.contract.methods.teleporter().call()
    return targetAddress
  }

  async wrapBrc20(
    parsedTx: {
      version: string
      vin: string
      vout: string
      locktime: string
    },
    merkleProof: {
      intermediateNodes: string
      transactionIndex: number
    },
    blockNumber: number,
    blockFee: string,
    exchangePath?: string[],
    nonce?: string | number | undefined,
  ) {
    try {
      if (!blockFee) throw new Error("block fee not exist")
      const response = await this.contractSendMethod("wrapBrc20", (+blockFee * 1.3).toFixed(), [
        parsedTx.version,
        parsedTx.vin,
        parsedTx.vout,
        parsedTx.locktime,
        blockNumber,
        merkleProof.intermediateNodes,
        merkleProof.transactionIndex,
        exchangePath || [],
      ])
      return {
        success: response.receipt.status,
        txId: response.receipt.transactionHash,
      }
    } catch (error: any) {
      console.log("***********error******", JSON.stringify(error.message))
      return {
        success: false,
        message: error.message,
        txId: undefined,
      }
    }
  }

  async unwrapBrc20(
    amount: string,
    tokenId: number,
    receiverBitcoinAddressScript: string,
    receiverAddressTypeNumber: number,
    appId: number,
    exchange?: {
      inputAmount: string
      inputToken: string
      path: string[]
    },
  ) {
    try {
      const response = await this.contractSendMethod("unwrapBrc20", "0", [
        tokenId,
        amount,
        receiverBitcoinAddressScript,
        receiverAddressTypeNumber,
        appId,
        exchange?.inputAmount || "0",
        exchange?.path || [],
      ])
      return {
        success: response.receipt.status,
        txId: response.receipt.transactionHash,
      }
    } catch (error: any) {
      console.log("***********error******", JSON.stringify(error.message))
      return {
        success: false,
        message: error.message,
        txId: undefined,
      }
    }
  }

  async unwrapProof(
    parsedTx: {
      version: string
      vin: string
      vout: string
      locktime: string
    },
    merkleProof: {
      intermediateNodes: string
      transactionIndex: number
    },
    blockNumber: number,
    blockFee: number,
    requestIndexes: number[],
    nonce: string | number | undefined = undefined,
  ) {
    try {
      if (!blockFee) throw new Error("block fee not exist")
      const response = await this.contractSendMethod("unwrapProof", (+blockFee * 1.3).toFixed(), [
        parsedTx.version,
        parsedTx.vin,
        parsedTx.vout,
        parsedTx.locktime,
        blockNumber,
        merkleProof.intermediateNodes,
        merkleProof.transactionIndex,
        requestIndexes,
      ])
      return {
        success: response.receipt.status,
        txId: response.receipt.transactionHash,
      }
    } catch (error: any) {
      console.log("***********error******", JSON.stringify(error.message))
      return {
        success: false,
        message: error.message,
        txId: undefined,
      }
    }
  }

  async getPastEventsWithRange(eventName: string, fromBlock: number, blockRange: number) {
    const lastBlock = await this.getLatestBlockNumber()
    let block = +fromBlock
    const events = []
    while (block <= +lastBlock.toString()) {
      const rEvents = await this.contract.getPastEvents(eventName as any, {
        fromBlock: block,
        toBlock: Math.min(+lastBlock.toString(), block + blockRange),
      })
      events.push(...rEvents)
      block += blockRange + 1
    }
    return events.filter((e) => typeof e !== "string") as EventLog[]
  }
}

export default BRC20
