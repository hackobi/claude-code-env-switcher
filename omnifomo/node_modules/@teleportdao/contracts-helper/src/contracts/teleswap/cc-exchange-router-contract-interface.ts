import { CCExchangeRouterABI } from "../../abis"
import ContractBase from "../contract-base"
import { ConnectionConfig } from "../../types"

export type NewWrapAndSwap = {
  lockerTargetAddress: string
  user: string
  inputAndOutputToken: [inputToken: bigint, outputToken: bigint]
  inputAndOutputAmount: [inputAmount: bigint, outputAmount: bigint]
  speed: string
  teleporter: string
  bitcoinTxId: string
  appId: bigint
  thirdPartyId: bigint
  fees: [
    networkFee: bigint,
    lockerFee: bigint,
    protocolFee: bigint,
    thirdPartyFee: bigint,
    bridgeFee: bigint,
  ] // 4
  destinationChainId: bigint
}

export type FailedWrapAndSwap = {
  lockerTargetAddress: string
  recipientAddress: string
  inputAndOutputToken: [inputToken: string, outputToken: string]
  inputAndOutputAmount: [inputAmount: bigint, outputAmount: bigint]
  speed: string
  teleporter: string
  bitcoinTxId: string
  appId: bigint
  thirdPartyId: bigint
  fees: [
    networkFee: bigint,
    lockerFee: bigint,
    protocolFee: bigint,
    thirdPartyFee: bigint,
    bridgeFee: bigint,
  ] // 4
  destinationChainId: bigint
}

export class CcExchangeRouter extends ContractBase<typeof CCExchangeRouterABI> {
  constructor(connectionConfig: ConnectionConfig, contractAddress: string) {
    super(connectionConfig, contractAddress, CCExchangeRouterABI)
  }

  async getProtocolPercentageFee() {
    const res = this.contract.methods.protocolPercentageFee().call()
    return res
  }

  async thirdPartyFee(thirdPartId: number) {
    return this.contract.methods.thirdPartyFee(thirdPartId).call()
  }

  async startingBlockNumber() {
    const res = await this.contract.methods.startingBlockNumber().call()
    return res.toString()
  }

  async isUsed(txId: string) {
    const txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`
    const isUsed: boolean = await this.contract.methods.isRequestUsed(txIdWith0x).call()
    return isUsed
  }

  async wrapAndSwap(
    lockerScript: string,
    parsedTx: {
      version: string
      vin: string
      vout: string
      locktime: string
    },
    merkleProof: {
      intermediateNodes: string
      transactionIndex: number
    },
    blockNumber: number,
    blockFee: number | string,
    path: string[],
  ) {
    return this.contractSendMethodNoError(
      "wrapAndSwap",
      blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000",
      [
        [
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
        ],
        `0x${lockerScript}`,
        path,
      ],
    )
  }
}
export default CcExchangeRouter
