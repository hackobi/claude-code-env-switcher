import { BigNumber } from "bignumber.js"
import { bitcoinAddressTypes } from "@teleportdao/configs"
import { LockersLogicABI } from "../../abis"
import ContractBase from "../contract-base"
import { ConnectionConfig } from "../../types/eth"

const { addressTypesNumber, addressTypes } = bitcoinAddressTypes
export class LockerContract extends ContractBase<typeof LockersLogicABI> {
  constructor(connectionConfig: ConnectionConfig, contractAddress: string) {
    super(connectionConfig, contractAddress, LockersLogicABI)
  }

  async isLocker(lockingScript: string) {
    return this.contract.methods.isLocker(lockingScript).call()
  }

  async isLockerActive(targetAddress: string) {
    return this.contract.methods.isLockerActive(targetAddress).call()
  }

  async getLockerTargetAddress(lockingScript: string) {
    return this.contract.methods.getLockerTargetAddress(lockingScript).call()
  }

  async getLockerPercentageFee() {
    return this.contract.methods.lockerPercentageFee().call()
  }

  async getLockerCapacity(targetAddress: string) {
    return this.contract.methods.getLockerCapacity(targetAddress).call()
  }

  async getMinRequiredTNTLockedAmount() {
    return this.contract.methods.minRequiredTNTLockedAmount().call()
  }

  async getMinRequiredTSTLockedAmount() {
    return this.contract.methods.minRequiredTNTLockedAmount().call()
  }

  async isValidLocker(lockingScript: string, targetAddress: string) {
    const hexLockerScript = `0x${lockingScript.replace("0x", "")}`
    const address = await this.getLockerTargetAddress(hexLockerScript)
    const isLocker = await this.isLocker(hexLockerScript)
    return isLocker && address === targetAddress
  }

  async getCollateralTokenInfo(targetAddress: string) {
    const collateralToken = await this.contract.methods.lockerCollateralToken(targetAddress).call()
    const collateralDecimal = await this.contract.methods.collateralDecimal(targetAddress).call()
    return { collateralToken, collateralDecimal: +collateralDecimal.toString() }
  }

  async getLockerReliabilityFactor(targetAddress: string) {
    return this.contract.methods.lockerReliabilityFactor(targetAddress).call()
  }

  async getLockerInfo(targetAddress: string) {
    const {
      lockerLockingScript,
      lockerRescueType,
      lockerRescueScript,
      TSTLockedAmount,
      collateralTokenLockedAmount,
      netMinted,
      slashingTeleBTCAmount,
      reservedCollateralTokenForSlash,
      isLocker,
      isCandidate,
      isScriptHash,
    } = await this.contract.methods.lockersMapping(targetAddress).call()

    const isActive = isLocker && (await this.isLockerActive(targetAddress))

    return {
      lockerLockingScript,
      lockerRescueType: addressTypes[+lockerRescueType.toString()],
      lockerRescueScript,
      TSTLockedAmount,
      collateralTokenLockedAmount,
      netMinted,
      slashingTeleBTCAmount,
      reservedCollateralTokenForSlash,
      isLocker,
      isCandidate,
      isScriptHash,
      isActive,
    }
  }

  // todo : below function need to be updated
  async requestToBecomeLocker({
    lockerLockingScript,
    lockedCollateralToken,
    lockedTSTAmount,
    lockedCollateralTokenAmount,
    lockerRescueType,
    lockerRescueScript,
  }: {
    lockerLockingScript: string
    lockedTSTAmount: string | number
    lockedCollateralToken: string | number
    lockedCollateralTokenAmount: string | number
    lockerRescueType: keyof typeof addressTypesNumber
    lockerRescueScript: string
    nonce?: any
  }) {
    return this.contractSendMethodNoError(
      "requestToBecomeLocker",
      lockedCollateralToken === "0x0000000000000000000000000000000000000001"
        ? BigNumber(lockedCollateralTokenAmount).toString()
        : "0",
      [
        lockerLockingScript,
        lockedCollateralToken,
        lockedTSTAmount,
        lockedCollateralTokenAmount,
        addressTypesNumber[lockerRescueType],
        lockerRescueScript,
      ],
    )
  }

  async requestInactivation(nonce = undefined) {
    return this.contractSendMethodNoError("requestInactivation", "0")
  }

  async selfRemoveLocker(nonce = undefined) {
    return this.contractSendMethodNoError("selfRemoveLocker", "0", [])
  }

  async addCollateral({
    targetAddress = this.currentAccount,
    nativeTokenAmount,
  }: {
    targetAddress?: string
    nativeTokenAmount: string | number
  }) {
    return this.contractSendMethodNoError("addCollateral", "0", [targetAddress, nativeTokenAmount])
  }

  async removeCollateral({
    nativeTokenAmount,
  }: {
    nativeTokenAmount: string | number
    nonce?: any
  }) {
    return this.contractSendMethodNoError("removeCollateral", "0", [nativeTokenAmount])
  }
}
export default LockerContract
