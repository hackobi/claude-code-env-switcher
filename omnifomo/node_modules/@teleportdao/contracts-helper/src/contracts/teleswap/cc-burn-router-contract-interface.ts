import { EventLog } from "web3"
import { CCBurnRouterABI } from "../../abis"
import ContractBase from "../contract-base"
import { ConnectionConfig } from "../../types"

export type BurnDispute = {
  userTargetAddress: string
  _lockerTargetAddress: string
  lockerLockingScript: string
  requestIdOfLocker: bigint
}

export type LockerDispute = {
  _lockerTargetAddress: string
  lockerLockingScript: string
  _blockNumber: bigint
  txId: string
  amount: bigint
}

export type NewUnwrap = {
  userScript: string
  scriptType: bigint
  lockerTargetAddress: string
  userTargetAddress: string
  requestIdOfLocker: bigint
  deadline: bigint
  thirdPartyId: bigint
  inputToken: string
  amounts: [inputAmount: bigint, teleBTCAmount: bigint, burntAmount: bigint] // 3
  fees: [networkFee: bigint, lockerFee: bigint, protocolFee: bigint, thirdPartyFee: bigint] // 4
}

export type PaidUnwrap = {
  lockerTargetAddress: string
  requestIdOfLocker: bigint
  bitcoinTxId: string
  bitcoinTxOutputIndex: bigint
}

export class CcBurnRouter extends ContractBase<typeof CCBurnRouterABI> {
  constructor(connectionConfig: ConnectionConfig, contractAddress: string) {
    super(connectionConfig, contractAddress, CCBurnRouterABI)
  }

  async getProtocolPercentageFee() {
    return this.contract.methods.protocolPercentageFee().call()
  }

  async startingBlockNumber() {
    const res = await this.contract.methods.startingBlockNumber().call()
    return res
  }

  async getBitcoinFee() {
    return this.contract.methods.bitcoinFee().call()
  }

  async isTransferred(lockerTargetAddress: string, index: number) {
    return this.contract.methods.isTransferred(lockerTargetAddress, index).call()
  }

  async burnRequests(lockerTargetAddress: string, index: number) {
    return this.contract.methods.burnRequests(lockerTargetAddress, index).call()
  }

  async isUsedAsBurnProof(bitcoinTxId: string) {
    const txIdWith0x = `0x${Buffer.from(bitcoinTxId, "hex").reverse().toString("hex")}`
    return this.contract.methods.isUsedAsBurnProof(txIdWith0x).call()
  }

  async getBurnTransferDeadline() {
    return this.contract.methods.transferDeadline().call()
  }

  async thirdPartyFee(thirdPartId: number) {
    return this.contract.methods.thirdPartyFee(thirdPartId).call()
  }

  // write functions

  async sendBurnProof(
    parsedTx: {
      version: string
      vin: string
      vout: string
      locktime: string | number
    },
    merkleProof: {
      intermediateNodes: string
      transactionIndex: number
    },
    blockNumber: number,
    requestIndexes: number[],
    voutIndexes: number[],
    lockerLockingScript: string,
    blockFee: string,
    nonce = undefined,
  ) {
    if (!blockFee) throw new Error("block fee not exist")
    return this.contractSendMethodNoError("burnProof", (+blockFee * 1.3).toFixed(), [
      parsedTx.version,
      parsedTx.vin,
      parsedTx.vout,
      parsedTx.locktime,
      blockNumber,
      merkleProof.intermediateNodes,
      merkleProof.transactionIndex,
      lockerLockingScript,
      requestIndexes, // requestIndexes
      voutIndexes, // vout indexes
    ])
  }

  async disputeBurn(
    lockerLockingScript: string,
    arrayOfRequestIndexes: number[],
    nonce = undefined,
  ) {
    return this.contractSendMethodNoError("disputeBurn", "0", [
      lockerLockingScript,
      arrayOfRequestIndexes,
    ])
  }

  async disputeLocker(
    lockerLockingScript: string,
    input: {
      parsedTx: {
        version: string
        vin: string
        vout: string
        locktime: string | number
      }
      merkleProof: {
        intermediateNodes: string
        transactionIndex: string
      }
      blockNumber: number
    },
    output: {
      parsedTx: {
        version: string
        vin: string
        vout: string
        locktime: string | number
      }
      merkleProof: {
        intermediateNodes: string
        transactionIndex: string
      }
      blockNumber: number
    },
    outVinIndex: number[],
    blockFee: string | number,
    nonce = undefined,
  ) {
    if (!blockFee) throw new Error("block fee not exist")

    return this.contractSendMethodNoError("disputeLocker", (+blockFee * 1.3).toFixed(), [
      lockerLockingScript,
      [input.parsedTx.version, output.parsedTx.version],
      input.parsedTx.vin,
      input.parsedTx.vout,
      output.parsedTx.vin,
      output.parsedTx.vout,
      [input.parsedTx.locktime, output.parsedTx.locktime],
      input.merkleProof.intermediateNodes,
      [outVinIndex, input.merkleProof.transactionIndex, input.blockNumber],
    ])
  }

  static unwrapParams(
    amount: string | number,
    receiverBitcoinScript: string,
    addressTypeNumber: number,
    lockerLockingScript: string,
    thirdPartyId: number = 0,
  ) {
    const value = "0"
    const params = [
      amount,
      receiverBitcoinScript,
      addressTypeNumber,
      lockerLockingScript,
      thirdPartyId,
    ]
    return {
      params,
      value,
    }
  }

  async unwrap(
    amount: string | number,
    receiverBitcoinScript: string,
    addressTypeNumber: number,
    lockerLockingScript: string,
    thirdPartyId: number = 0,
  ) {
    const { value, params } = CcBurnRouter.unwrapParams(
      amount,
      receiverBitcoinScript,
      addressTypeNumber,
      lockerLockingScript,
      thirdPartyId,
    )
    return this.contractSendMethodNoError("unwrap", value, params)
  }

  static swapAndUnwrapParams(
    exchangeInfo: {
      exchangeConnector: string
      path: string[]
      deadline: number
      inputAmount: number | string
      outputAmount: number | string
      isFixedToken: boolean
      isNativeToken?: boolean
    },
    receiverBitcoinScript: string,
    addressTypeNumber: number,
    lockerLockingScript: string,
    thirdPartyId: number = 0,
  ) {
    const value = exchangeInfo.isNativeToken === true ? exchangeInfo.inputAmount.toString() : "0"
    const params = [
      exchangeInfo.exchangeConnector,
      [exchangeInfo.inputAmount, exchangeInfo.outputAmount],
      exchangeInfo.isFixedToken,
      exchangeInfo.path,
      exchangeInfo.deadline,
      receiverBitcoinScript,
      addressTypeNumber,
      lockerLockingScript,
      thirdPartyId,
    ]
    return {
      params,
      value,
    }
  }

  async swapAndUnwrap(
    exchangeInfo: {
      exchangeConnector: string
      path: string[]
      deadline: number
      inputAmount: number | string
      outputAmount: number | string
      isFixedToken: boolean
      isNativeToken?: boolean
    },
    receiverBitcoinScript: string,
    addressTypeNumber: number,
    lockerLockingScript: string,
    thirdPartyId: number = 0,
  ) {
    const { value, params } = CcBurnRouter.swapAndUnwrapParams(
      exchangeInfo,
      receiverBitcoinScript,
      addressTypeNumber,
      lockerLockingScript,
      thirdPartyId,
    )
    return this.contractSendMethodNoError("swapAndUnwrap", value, params)
  }

  async setNetworkFee(networkFee: number) {
    return this.contractSendMethodNoError("setNetworkFee", "0", [networkFee])
  }

  // events
  async getNewUnwrapEvents(fromBlock = 0, blockRange = 10000, toBlock?: number) {
    return (await this.getPastEventsWithRange("NewUnwrap", fromBlock, blockRange, toBlock)).map(
      (event) => CcBurnRouter.parseEvent<NewUnwrap>(event),
    )
  }

  async getPaidUnwrapEvents(fromBlock = 0, blockRange = 10000, toBlock?: number) {
    return (await this.getPastEventsWithRange("PaidUnwrap", fromBlock, blockRange, toBlock)).map(
      (event) => CcBurnRouter.parseEvent<PaidUnwrap>(event),
    )
  }

  async getBurnDisputeEvents(fromBlock = 0, blockRange = 10000, toBlock?: number) {
    return (await this.getPastEventsWithRange("BurnDispute", fromBlock, blockRange, toBlock)).map(
      (event) => CcBurnRouter.parseEvent<BurnDispute>(event),
    )
  }

  async getLockerDisputeEvents(fromBlock = 0, blockRange = 10000, toBlock?: number) {
    return (await this.getPastEventsWithRange("LockerDispute", fromBlock, blockRange, toBlock)).map(
      (event) => CcBurnRouter.parseEvent<LockerDispute>(event),
    )
  }
}
export default CcBurnRouter
