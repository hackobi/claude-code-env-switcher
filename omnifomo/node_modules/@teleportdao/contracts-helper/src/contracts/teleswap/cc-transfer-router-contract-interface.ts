import { CCTransferRouterABI } from "../../abis"
import ContractBase from "../contract-base"
import { ConnectionConfig } from "../../types"

export type NewWrap = {
  bitcoinTxId: string
  lockerLockingScript: string
  lockerTargetAddress: string
  user: string
  teleporter: string
  amounts: [inputAmount: bigint, teleBTCAmount: bigint]
  fees: [networkFee: bigint, lockerFee: bigint, protocolFee: bigint, thirdPartyFee: bigint] // 4
  thirdPartyId: bigint
  destinationChainId: bigint
}

export class CcTransferRouter extends ContractBase<typeof CCTransferRouterABI> {
  constructor(connectionConfig: ConnectionConfig, contractAddress: string) {
    super(connectionConfig, contractAddress, CCTransferRouterABI)
  }

  async startingBlockNumber() {
    const res = await this.contract.methods.startingBlockNumber().call()
    return res.toString()
  }

  async thirdPartyFee(thirdPartId: number) {
    return this.contract.methods.thirdPartyFee(thirdPartId).call()
  }

  async getProtocolPercentageFee() {
    return this.contract.methods.protocolPercentageFee().call()
  }

  async isUsed(txId: string) {
    let txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`
    let isUsed = await this.contract.methods.isRequestUsed(txIdWith0x).call()
    return isUsed
  }

  async wrap(
    lockerScript: string,
    parsedTx: {
      version: string
      vin: string
      vout: string
      locktime: string
    },
    merkleProof: {
      intermediateNodes: string
      transactionIndex: number
    },
    blockNumber: number,
    blockFee: string | number,
  ) {
    return this.contractSendMethodNoError(
      "wrap",
      blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000",
      [
        [
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
        ],
        `0x${lockerScript}`,
      ],
    )
  }
}
export default CcTransferRouter
