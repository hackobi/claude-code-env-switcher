// eslint-disable-next-line import/no-extraneous-dependencies
import { EventLog, Contract, LogsSubscription } from "web3-eth-contract"
import Web3, { ContractAbi } from "web3"
import { JobQueueInOrder } from "./queue"
import { sleep } from "./utils"

export class ContractEventListener<ABIType extends ContractAbi> {
  contract: Contract<ABIType>
  listeners: {
    [key: string]: {
      isSubscribe: boolean
      lastBlock: number | undefined
      eventEmitter?: LogsSubscription
      // todo : we can add array of handlers to handle multiple task for one event
      handler: (event: EventLog) => Promise<void>
      queue: JobQueueInOrder
      httpConfig?: { delayBetweenRounds: number; blockRange: number }
    }
  }
  contractName: string
  wssConfig: { reSubscribeTime: number }
  httpConfig: { delayBetweenRounds: number; blockRange: number }
  errorHandler: (error: any, moreInfo: any) => void
  web3: Web3
  inOrder: boolean
  constructor(
    contract: Contract<ABIType>,
    contractName: string,
    errorHandler: ((error: any, moreInfo: any) => void) | undefined = (
      error: any,
      moreInfo: any,
    ) => {
      console.log(
        `${new Date().toUTCString()}  ${
          typeof error === "string" ? error : error?.message || ""
        } ----> ${JSON.stringify(moreInfo)}`,
      )
    },
    inOrder = false,
    wssConfig = {
      reSubscribeTime: 30_000,
    },
    httpConfig = { delayBetweenRounds: 60_000, blockRange: 1000 },
  ) {
    this.contractName = contractName
    this.contract = contract
    this.wssConfig = wssConfig
    this.httpConfig = httpConfig
    this.errorHandler = errorHandler
    this.listeners = {}
    this.inOrder = inOrder
    this.web3 = new Web3(this.contract.provider)
  }

  static getEventId(event: EventLog) {
    return `${event.event}:${event.transactionHash}:${event.logIndex}:${event.blockNumber}`
  }

  addListener(
    eventName: string,
    handler: (event: EventLog) => Promise<void>,
    lastBlock?: number,
    httpConfig?: {
      delayBetweenRounds: number
      blockRange: number
    },
  ) {
    if (this.listeners[eventName]) {
      throw new Error(`listener for ${eventName} already exists`)
    }
    const queue = new JobQueueInOrder(false, (job) => handler(job.data))
    const listenerHandler = this.inOrder
      ? async (event: EventLog) =>
          queue.addJob({
            id: ContractEventListener.getEventId(event),
            data: event,
          })
      : handler
    this.listeners[eventName] = {
      isSubscribe: false,
      lastBlock,
      eventEmitter: undefined,
      queue,
      handler: listenerHandler,
      httpConfig,
    }
  }

  async getPastEventsWithRange(eventName: string, fromBlock: number, blockRange: number) {
    const web3Eth = this.web3.eth
    const lastBlock = await web3Eth.getBlockNumber()
    let block = +fromBlock.toString()
    const events = []
    while (block <= +lastBlock.toString()) {
      const rEvents = await this.contract.getPastEvents(eventName, {
        fromBlock: block,
        toBlock: Math.min(+lastBlock.toString(), block + blockRange),
      })
      events.push(...rEvents)
      block += blockRange + 1
    }
    return {
      events: events.filter((e) => typeof e !== "string") as EventLog[],
      lastBlock: lastBlock.toString(),
    }
  }

  websocketListenOnEventOrResetConnection(eventName: string, numberOfRetry = 0) {
    try {
      let reSubscribe = false
      const listener = this.listeners[eventName]
      if (!listener) {
        throw new Error(`listener for ${eventName} not exists`)
      }
      if (listener.isSubscribe) {
        console.log("its ok .............................")
        return
      }
      if (listener.eventEmitter) {
        listener.eventEmitter.removeAllListeners()
        listener.eventEmitter = undefined
      }

      if (this.contract.provider?.getStatus() !== "connected") {
        this.contract.provider?.once("connect", () => {
          this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1)
        })
        return
      }

      this.contract.provider?.once("disconnect", async (err: any) => {
        if (reSubscribe) return
        reSubscribe = true
        listener.isSubscribe = false
        this.errorHandler(err || "", {
          eventName,
          numberOfRetry,
          type: `disconnected.try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
        })
        await sleep(this.wssConfig.reSubscribeTime)
        this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1)
      })

      this.contract.provider?.once("connect", async (err: any) => {
        if (reSubscribe) return
        reSubscribe = true
        listener.isSubscribe = false
        this.errorHandler(err || "", {
          eventName,
          numberOfRetry,
          type: `connected.try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
        })
        await sleep(this.wssConfig.reSubscribeTime)
        this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1)
      })

      listener.eventEmitter = this.contract.events[eventName]({
        fromBlock: listener.lastBlock || "latest",
      })

      listener.eventEmitter.on("error", async (err) => {
        this.errorHandler(err, { eventName, numberOfRetry, type: "error" })
        if (reSubscribe) return
        this.errorHandler("", {
          message: `try reconnect after ${this.wssConfig.reSubscribeTime / 1000} s ...`,
        })
        reSubscribe = true
        listener.isSubscribe = false
        await sleep(this.wssConfig.reSubscribeTime)
        this.websocketListenOnEventOrResetConnection(eventName, numberOfRetry + 1)
      })

      listener.eventEmitter.on("connected", (subscriptionId) => {
        console.log(`${this.contractName} ${eventName} event subscriptionId: ${subscriptionId}`)
        listener.isSubscribe = true
        reSubscribe = false
      })

      listener.eventEmitter.on("data", async (event) => {
        listener.handler(event)
        if (event.blockNumber) {
          listener.lastBlock = Math.max(+event.blockNumber.toString() + 1, listener.lastBlock || 0)
        }
      })

      listener.eventEmitter.on("changed", async (event) => {
        this.errorHandler("event changed", {
          eventName,
          returnValues: event.returnValues,
          txId: event.transactionHash,
          logIndex: event.logIndex,
          removed: event.removed,
          type: "end",
        })
      })
    } catch (e: any) {
      console.log(e.message)
    }
  }

  async httpListenOnEventOrResetConnection(eventName: string) {
    try {
      const listener = this.listeners[eventName]
      const blockRange = listener.httpConfig?.blockRange || this.httpConfig.blockRange
      const delayBetweenRounds =
        listener.httpConfig?.delayBetweenRounds || this.httpConfig.delayBetweenRounds

      listener.lastBlock = listener.lastBlock || +(await this.web3.eth.getBlockNumber()).toString()
      listener.isSubscribe = true
      while (listener.isSubscribe) {
        const {
          events,
          lastBlock,
        }: {
          events: EventLog[]
          lastBlock: string
        } = await this.getPastEventsWithRange(eventName, listener.lastBlock, blockRange)
        for (const event of events) {
          listener.handler(event)
        }
        listener.lastBlock = +lastBlock + 1
        await sleep(delayBetweenRounds)
      }
    } catch (e: any) {
      this.errorHandler(e, { eventName, type: "httpListenOnEventOrResetConnection" })
      await sleep(30_000)
      this.httpListenOnEventOrResetConnection(eventName)
    }
  }

  listenOnEventOrResetConnection(eventName: string) {
    if (this.contract.provider?.supportsSubscriptions()) {
      this.websocketListenOnEventOrResetConnection(eventName)
      return
    }
    this.httpListenOnEventOrResetConnection(eventName)
  }

  stopListenOnEvent(eventName: string) {
    const listener = this.listeners[eventName]
    if (listener) {
      listener.isSubscribe = false
      if (listener.eventEmitter) {
        listener.eventEmitter.unsubscribe()
        listener.eventEmitter.removeAllListeners()
        listener.eventEmitter = undefined
      }
    }
  }

  removeListener(eventName: string) {
    this.stopListenOnEvent(eventName)
    delete this.listeners[eventName]
  }
}
