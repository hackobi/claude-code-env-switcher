import { Web3, WebSocketProvider, Web3BaseProvider, HttpProvider, utils } from "web3"
import { BigNumber } from "bignumber.js"
import * as bip39 from "bip39"
import * as bip32 from "bip32"
import { hdWalletPath } from "@teleportdao/configs"
import { EventLog } from "web3-types"

import type { ConnectionConfig, ConnectionInfo } from "./types/eth"

// eslint-disable-next-line import/newline-after-import
;(BigInt as any).prototype.toJSON = function () {
  return this.toString()
}

export class EthereumBase {
  web3Eth!: Web3["eth"]
  isAccountInitialized: boolean
  currentAccount?: string
  hdWalletPath: string
  gasPriceIncreasePercentage: number
  gasAmountIncreasePercentage: number
  constructor({ connectionInfo, web3Eth, gasPriceIncreasePercentage = 0 }: ConnectionConfig) {
    if (web3Eth) this.web3Eth = web3Eth
    else if (connectionInfo) {
      this.setProviderUsingUrl(connectionInfo)
    } else {
      this.web3Eth = new Web3().eth
    }

    this.isAccountInitialized = false

    this.hdWalletPath = hdWalletPath.ethereum

    this.gasPriceIncreasePercentage = gasPriceIncreasePercentage
    this.gasAmountIncreasePercentage = 30
    this.config()
  }

  config() {
    this.web3Eth.transactionConfirmationBlocks = 1 // 24
    // socket
    this.web3Eth.blockHeaderTimeout = 10_000 // 10
    //   this.web3Eth.transactionBlockTimeout // 50
    // http
    this.web3Eth.transactionPollingInterval = 30_000 // 1000
    this.web3Eth.transactionConfirmationPollingInterval = 30_000 // 1000
    this.web3Eth.transactionPollingTimeout = 180_000 // 750000
    this.web3Eth.transactionSendTimeout = 180_000 // 750000
    //
    this.web3Eth.transactionReceiptPollingInterval = 5_000
  }

  static validateEthAddress(adr: string) {
    try {
      const web3 = new Web3()
      web3.utils.toChecksumAddress(adr)
      return true
    } catch (e) {
      return false
    }
  }

  static extractEventTxInfo(rawEvent: EventLog) {
    const { blockNumber, logIndex, transactionHash, event: eventName, signature } = rawEvent
    return {
      blockNumber: +blockNumber!.toString(),
      logIndex: +logIndex!.toString(),
      transactionHash: transactionHash!,
      eventName,
      signature: signature!,
    }
  }

  setProviderUsingUrl({ url, headers = undefined }: ConnectionInfo) {
    if (url.startsWith("ws")) {
      this.setWssProviderUsingUrl({ url, headers })
    } else {
      this.setHttpProviderUsingUrl({ url, headers })
    }
  }

  setWssProviderUsingUrl(
    { url, headers = undefined }: ConnectionInfo,
    { reconnectSleep = 30_000 } = {},
  ) {
    const provider = new WebSocketProvider(
      url,
      {
        headers,
      },
      {
        autoReconnect: true,
        delay: 10_000,
        maxAttempts: 3,
      },
    )
    this.setWeb3EthProvider(provider)
    provider.on("connect", () => {
      console.log(`${new Date().toUTCString()}-- Web3 WS Connected - url : ${url}`)
    })
    provider.on("error", (e: any) => {
      console.log(`${new Date().toUTCString()}-- websocket error ${e.message}`)
      if ((e.message as string).includes("Maximum number of reconnect attempts reached")) {
        provider.disconnect()
      }
    })
    provider.on("disconnect", () => {
      console.log(`${new Date().toUTCString()}-- websocket disconnected try reconnecting ...`)
      setTimeout(() => {
        provider.connect()
      }, reconnectSleep)
    })
  }

  setHttpProviderUsingUrl({ url, headers = undefined }: ConnectionInfo) {
    this.setWeb3EthProvider(
      new HttpProvider(url, {
        providerOptions: {
          headers,
        },
      }),
    )
  }

  setWeb3EthProvider(provider: Web3BaseProvider) {
    if (this.web3Eth) {
      this.web3Eth.setProvider(provider)
    } else {
      this.web3Eth = new Web3(provider).eth
    }
  }
  // ---------------------- set account ---------------------

  setCurrentAccount(address: string) {
    if (this.web3Eth.accounts.wallet.get(address)) {
      this.isAccountInitialized = true
    }
    this.currentAccount = address
  }

  addAccountByPrivateKey(privateKeyHex: string) {
    const ethPrivateKeyHex = privateKeyHex.startsWith("0x") ? privateKeyHex : `0x${privateKeyHex}`
    const account = this.web3Eth.accounts.privateKeyToAccount(ethPrivateKeyHex)
    const wallet = this.web3Eth.accounts.wallet.add(account)
    if (!wallet.get(account.address)) throw new Error("invalid private key")
    if (!this.currentAccount) this.setCurrentAccount(account.address)
    if (!this.currentAccount) throw new Error("account is not set correctly")
    return account.address
  }

  addAccountByMnemonic({
    mnemonic,
    mnemonicPassword = "",
    index = 0,
    walletNumber = 0,
  }: {
    mnemonic: string
    mnemonicPassword?: string
    index: number
    walletNumber?: number
  }) {
    if (!bip39.validateMnemonic(mnemonic)) throw new Error("invalid mnemonic")
    const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword)
    const node = bip32.fromSeed(seed)
    const path = `${this.hdWalletPath}/${walletNumber}`
    const account = node.derivePath(path)
    const userKeyPair = account.derive(index)
    if (!userKeyPair.privateKey) throw new Error("invalid privatekey")
    return this.addAccountByPrivateKey(`0x${userKeyPair.privateKey.toString("hex")}`)
  }

  // -------------------------- methods ------------------------------

  async getLatestBlock() {
    return this.web3Eth.getBlock(await this.getLatestBlockNumber())
  }

  async getLatestBlockNumber() {
    return this.web3Eth.getBlockNumber()
  }

  async getNumberOfConfirmedTransactions(address: string) {
    return this.web3Eth.getTransactionCount(address)
  }

  async getNumberOfMemPoolTransactions(address: string) {
    const confirmedTxNum = await this.getNumberOfConfirmedTransactions(address)
    const allTxNum = await this.web3Eth.getTransactionCount(address, "pending")
    return allTxNum - confirmedTxNum
  }

  // --------------------- functions

  async checkCurrentAccountBalance(
    warningMinAmount: string | number = 0.01 * 1e18,
    errorMinAmount: string | number = 0.005 * 1e18,
  ) {
    if (!this.currentAccount) throw new Error("account is not initialized")
    const walletBalance = await this.web3Eth.getBalance(this.currentAccount)
    return {
      address: this.currentAccount,
      balance: new BigNumber(walletBalance.toString()).dividedBy(1e18).toString(),
      warningMinAmount: new BigNumber(warningMinAmount).dividedBy(1e18).toFixed(8),
      errorMinAmount: new BigNumber(errorMinAmount).dividedBy(1e18).toFixed(8),
      warning: new BigNumber(walletBalance.toString()).isLessThan(warningMinAmount),
      error: new BigNumber(walletBalance.toString()).isLessThan(errorMinAmount),
    }
  }

  async checkCurrentAccountBalanceForContractCall({
    maximumGasLimit = 1_000_000,
    NumberOfCallForWarning = 30,
    NumberOfCallForError = 1,
  }) {
    const gasPrice = new BigNumber((await this.web3Eth.getGasPrice()).toString())
      .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
      .toFixed(0)
    const fee = new BigNumber(maximumGasLimit).multipliedBy(gasPrice)
    const warningAmount = fee.multipliedBy(NumberOfCallForWarning).toFixed(10)
    const errorAmount = fee.multipliedBy(NumberOfCallForError).toFixed(10)
    return this.checkCurrentAccountBalance(warningAmount, errorAmount)
  }

  async getTransaction(txId: string) {
    const tx = await this.web3Eth.getTransaction(txId)
    return tx
  }

  async sendEth(receiver: string, amount: string | number) {
    const value = new BigNumber(amount).multipliedBy(1e18).toFixed(0)
    const gasPrice = new BigNumber((await this.web3Eth.getGasPrice()).toString())
      .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
      .toFixed(0)

    const tx = await this.web3Eth.sendTransaction({
      from: this.currentAccount,
      gasPrice,
      gas: 21_000,
      to: receiver,
      value,
    })

    return tx
  }

  async sendAllEth(receiver: string) {
    if (!this.currentAccount) {
      throw new Error("account is not initialized")
    }
    const gasPrice = new BigNumber((await this.web3Eth.getGasPrice()).toString())
      .multipliedBy(1 + +this.gasPriceIncreasePercentage / 100)
      .toFixed(0)
    const balance = await this.web3Eth.getBalance(this.currentAccount)
    const value = BigNumber(balance.toString())
      .minus(BigNumber(gasPrice).multipliedBy(21_000))
      .toFixed(0)

    if (+value < 0) {
      throw new Error(`not enough balance: ${balance}`)
    }
    const tx = await this.web3Eth.sendTransaction({
      from: this.currentAccount,
      gasPrice,
      gas: 21_000,
      to: receiver,
      value,
    })

    return { tx, value }
  }
}

export default EthereumBase
