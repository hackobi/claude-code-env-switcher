import BigNumber from "bignumber.js"
import { bitcoin as bitcoinProviders } from "@teleportdao/providers"
import { BitcoinInterface } from "./bitcoin-interface"
import { Transaction, BitcoinTokenNodeConnectionInfo } from "./type"
import type { SignerInfo } from "./transaction-builder"

import { sleep } from "./utils/tools"
import { checkAndParseBrc20Request } from "./helper/brc20-helper"

export class BitcoinInterfaceOrdinal extends BitcoinInterface {
  unisat: bitcoinProviders.UniSat
  constructor(
    connectionInfo: BitcoinTokenNodeConnectionInfo,
    networkName: string,
    uniSatToken: string,
  ) {
    super(networkName, connectionInfo)
    this.unisat = new bitcoinProviders.UniSat(
      {
        token: uniSatToken,
      },
      networkName.includes("testnet"),
    )
  }
  async getInscriptionWithRetry(
    inscriptionId: string,
    { numberOfRetry = 5, sleepTime = 20000 } = {},
  ) {
    let count = 0
    while (count <= numberOfRetry) {
      try {
        let inscription = await this.unisat.getInscriptionInfo(inscriptionId)
        if (inscription?.brc20) {
          return inscription
        }
      } catch (e: any) {
        console.log(e.message)
      }
      await sleep(sleepTime + count * 5000)
      count += 1
    }
    return null
  }

  async getTransactionBrc20TransferInfo(transaction: {
    txId: string
    vout: {
      address: string | null
      script: string
      value: number
    }[]
    vin: {
      txId: string
      index: number
      address?: string | null
      script?: string | null
      value?: number | null
    }[]
  }) {
    let txBrc20s: {
      txId: string
      receiver: string
      index: number
      brc20: {
        op: string
        tick: string
        lim: string
        amt: string
        decimal: string
      }
      inscription: bitcoinProviders.UnisatInscription
    }[] = []
    for (let x = 0; x < transaction.vout.length - 1; x += 1) {
      if (!transaction.vout[x].address) {
        return []
      }
      let inscription = await this.unisat.getInscriptionInfo(
        `${transaction.vin[x].txId}i${transaction.vin[x].index}`,
      )

      const brc20 = inscription?.brc20?.op === "transfer" ? inscription.brc20 : undefined
      if (brc20 && inscription) {
        txBrc20s.push({
          txId: transaction.txId,
          receiver: transaction.vout[x].address!,
          index: x,
          inscription,
          brc20,
        })
      } else {
        return []
      }
    }

    return txBrc20s
  }

  async convertToBrc20WrapRequest(transaction: Transaction, lockerAddress: string) {
    let { vout } = transaction
    let request = checkAndParseBrc20Request(vout, lockerAddress)
    let lockerLockingScript: string =
      transaction.addressScript ||
      this.convertAddressToScript(lockerAddress).script!.toString("hex")

    return {
      transaction,
      request,
      lockerAddress,
      lockerLockingScript,
    }
  }

  async getBrc20WrapRequests(
    addresses: string[],
    startblockNumber: number,
    endBlockNumber: number,
  ) {
    // transaction in StartBlock is not returned --> (startblockNumber,endBlockNumber]
    let transactions: Transaction[] = await this.getMultipleBlocksTransactions(
      addresses,
      startblockNumber,
      endBlockNumber || (await this.getLatestBlockNumber()),
    )

    let requests = []
    let invalidRequests = []

    // eslint-disable-next-line no-restricted-syntax
    for (let inputTx of transactions) {
      let data = await this.convertToBrc20WrapRequest(inputTx, inputTx.address)
      if (data.request.status) {
        let inscription = await this.getInscriptionWithRetry(
          `${inputTx.vin[0].txId}i${inputTx.vin[0].index}`,
        )
        const brc20 = inscription?.brc20?.op === "transfer" ? inscription.brc20 : undefined

        if (!brc20) {
          invalidRequests.push({
            ...data,
            message: `invalid brc20 -> ${inscription?.brc20?.op}:${inscription?.brc20?.amt}`,
          })
        } else if (
          !BigNumber(brc20.amt)
            .multipliedBy(1e18)
            .isEqualTo(data.request.data?.inputAmount || 0)
        ) {
          invalidRequests.push({
            ...data,
            message: `invalid brc20 amount -> ${inscription?.brc20?.op}:${inscription?.brc20?.amt}:${data.request.data?.inputAmount}`,
          })
        } else {
          requests.push({ ...data, brc20 })
        }
        // check brc20 info
        // this.unisat.getBrc20TickerTxHistory(data.request.data!.brc20!.ticker, data.transaction.txId)
        // ignore normal transaction
      } else if (data.request.code !== "NO_OP_RETURN") {
        invalidRequests.push(data)
      }
    }
    return { requests, invalidRequests }
  }

  async getBTCUtxo(address: string, signerInfo: SignerInfo) {
    return bitcoinProviders.UniSat.convertToNormalUtxo(
      (await this.unisat.getBTCUtxo(address))?.utxo || [],
    ).map(({ txId, index, value }) => ({
      hash: txId,
      index,
      value,
      signerInfo,
    }))
  }

  async getInscriptionUtxo(address: string, signerInfo: SignerInfo) {
    return bitcoinProviders.UniSat.convertToNormalUtxo(
      (await this.unisat.getInscriptionUtxo(address))?.utxo || [],
    ).map(({ txId, index, value }) => ({
      hash: txId,
      index,
      value,
      signerInfo,
    }))
  }
}
