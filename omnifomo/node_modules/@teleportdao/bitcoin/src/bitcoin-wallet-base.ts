import * as bip39 from "bip39"
import { hdWalletPath } from "@teleportdao/configs"
import { Network, Payment } from "bitcoinjs-lib"
import BIP32Factory from "bip32"
import ecc from "@bitcoinerlab/secp256k1"
import BigNumber from "bignumber.js"
import { BitcoinTransactionBuilder } from "./transaction-builder"
import type { RPCConnectionInfo, UtxoConnectionInfo } from "./type"

import type {
  ExtendedUtxo,
  SignerInfo,
  Target,
  TargetAddress,
} from "./transaction-builder/transaction-builder"
import BitcoinSign from "./sign/sign-transaction"

import { getPubKeyFromPrivateKeyHex } from "./bitcoin-utils"
import networks from "./utils/networks"
import { BitcoinInterfaceWallet } from "./bitcoin-interface-wallet"
import { runWithRetries } from "./utils/tools"

const bip32 = BIP32Factory(ecc)

export type FeeRateType = "normal" | "slow" | "fast" | number
export class BitcoinBaseWallet {
  network: Network
  hdWalletPath: {
    p2pkh: string
    p2wpkh: string
    "p2sh-p2wpkh": string
    p2sh: string
    p2wsh: string
    "p2sh-p2wsh": string
    p2tr: string
  }
  transactionBuilder: BitcoinTransactionBuilder
  btcInterface: BitcoinInterfaceWallet
  signer: BitcoinSign
  currentAccount?: string
  currentAccountType?: string
  privateKey?: Buffer
  publicKey?: Buffer
  publicKeys?: Buffer[]
  addressObj?: Payment
  bitcoinAddress: string | undefined
  constructor(
    networkName: string,
    connectionInfo?: {
      utxo?: UtxoConnectionInfo
      // rpc used for getRawTransaction in transaction builder if set (optional)
      rpc?: RPCConnectionInfo
    },
  ) {
    this.network = networks[networkName]
    this.hdWalletPath = hdWalletPath.bitcoin

    this.transactionBuilder = new BitcoinTransactionBuilder(
      networkName,
      this.network,
      connectionInfo,
    )
    this.btcInterface = this.transactionBuilder.btcInterface

    this.signer = new BitcoinSign(this.network)

    // initialize account
    this.currentAccount = undefined
    this.currentAccountType = undefined
    this.privateKey = undefined
    this.publicKey = undefined
  }

  static satoshiToBTC(satoshi: number | string) {
    return new BigNumber(satoshi).dividedBy(1e8).toString()
  }

  static btcToSatoshi(btc: number | string) {
    return new BigNumber(btc).multipliedBy(1e8).toFixed(0)
  }

  // initialize account

  get signerInfo() {
    return this.privateKey
      ? {
          address: this.bitcoinAddress!,
          publicKey: this.publicKey!.toString("hex"),
          addressType: this.currentAccountType!,
        }
      : undefined
  }

  setAccountPrivateKey(privateKeyHex: string) {
    this.privateKey = Buffer.from(privateKeyHex, "hex")
    let publicKey = getPubKeyFromPrivateKeyHex(privateKeyHex, this.network)
    this.publicKey = publicKey
    this.setAccountType("p2wpkh")
  }

  setAccountType(accountType = "p2pkh") {
    if (!this.publicKey) {
      throw new Error("account not initialized")
    }
    let addressObj = this.transactionBuilder.createAddressObject({
      addressType: accountType,
      publicKey: this.publicKey,
    })
    this.currentAccount = addressObj.address
    this.currentAccountType = accountType
    this.addressObj = addressObj
    this.bitcoinAddress = addressObj.address
    return addressObj.address!
  }

  setAccountPrivateKeyByMnemonic({
    mnemonic,
    mnemonicPassword = "",
    index = 0,
    walletNumber = 0,
    addressType = "p2sh-p2wpkh",
  }: {
    mnemonic: string
    mnemonicPassword?: string
    index?: number
    walletNumber?: number
    addressType?: string
  }) {
    if (!bip39.validateMnemonic(mnemonic)) throw new Error("invalid mnemonic")
    const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword)
    const node = bip32.fromSeed(seed)

    let basePath = this.hdWalletPath[addressType as keyof typeof this.hdWalletPath]
    if (!basePath) {
      throw new Error("incorrect path or addressType")
    }
    const path = `${basePath}/${walletNumber}`
    const account = node.derivePath(path)
    const userKeyPair = account.derive(index)
    this.setAccountPrivateKey(userKeyPair.privateKey!.toString("hex"))
    return this.setAccountType(addressType)
  }

  // helper function

  checkBalanceIsSufficient({
    targets,
    extendedUtxo,
    changeAddress,
    feeRate,
  }: {
    targets: Target[]
    extendedUtxo: ExtendedUtxo[]
    changeAddress: string
    feeRate: number
  }) {
    try {
      this.transactionBuilder.helperHandleInputsAndOutputs({
        targets,
        extendedUtxo,
        changeObject: {
          address: changeAddress,
        },
        feeRate,
      })
      return true
    } catch (err) {
      return false
    }
  }

  async getExtendedUtxo(input: SignerInfo) {
    return this.btcInterface.getExtendedUtxo(input)
  }

  async getFeeRate(feeRate: FeeRateType = "normal") {
    if (feeRate === 0) throw new Error("feeRate should be greater than 0")
    if (+feeRate > 0) return +feeRate
    if (typeof feeRate === "string") return this.btcInterface.getFeeRate(feeRate)
    throw new Error("incorrect feeRate")
  }

  // signed methods

  async sendBTC(
    receiverAddress: string,
    amountInSatoshi: number | "all",
    fee: FeeRateType = "normal",
    staticExtendedUtxo?: ExtendedUtxo[],
  ) {
    if (!this.signerInfo! || !this.privateKey) {
      throw new Error("account not initialized")
    }
    const unsignedTx = await this.sendBTCUnsignedTx(
      receiverAddress,
      amountInSatoshi,
      this.signerInfo!,
      fee,
      staticExtendedUtxo,
    )
    let signedPsbt = await this.signer.signPsbt(unsignedTx, this.privateKey)
    let signedTx = this.signer.finalizePsbts([signedPsbt])
    let txId = await this.sendSignedTx(signedTx)
    return txId
  }

  async sendBTCMultipleAddress(
    receivers: TargetAddress[],
    fee: FeeRateType = "normal",
    staticExtendedUtxo?: ExtendedUtxo[],
  ) {
    if (!this.signerInfo! || !this.privateKey) {
      throw new Error("account not initialized")
    }
    const unsignedTx = await this.sendBTCToMultipleAddressUnsignedTx(
      receivers,
      this.signerInfo!,
      fee,
      staticExtendedUtxo,
    )
    let signedPsbt = await this.signer.signPsbt(unsignedTx, this.privateKey)
    let signedTx = this.signer.finalizePsbts([signedPsbt])
    let txId = await this.sendSignedTx(signedTx)
    return txId
  }

  // unsigned methods
  async sendBTCToMultipleAddressUnsignedTx(
    receivers: TargetAddress[],
    signerInfo: SignerInfo,
    fee: FeeRateType = "normal",
    staticExtendedUtxo?: ExtendedUtxo[],
    fullAmount = false,
  ) {
    if (!fullAmount) {
      receivers.forEach((r) => {
        if (BigNumber(r.value).isEqualTo(0)) throw new Error("incorrect amount")
      })
    } else if (receivers.length > 1) throw new Error("fullAmount only support one receiver")

    let feeRate = await this.getFeeRate(fee)
    let extendedUtxo = staticExtendedUtxo || (await this.getExtendedUtxo(signerInfo))

    let unsignedTx = await this.transactionBuilder.processUnsignedTransaction({
      extendedUtxo,
      targets: receivers,
      changeAddress: signerInfo.address,
      feeRate,
      fullAmount,
    })
    return unsignedTx
  }

  async sendBTCUnsignedTx(
    receiver: string,
    amountInSatoshi: number | "all",
    signerInfo: SignerInfo,
    fee: FeeRateType = "normal",
    staticExtendedUtxo?: ExtendedUtxo[],
  ) {
    return this.sendBTCToMultipleAddressUnsignedTx(
      [{ address: receiver, value: amountInSatoshi === "all" ? 0 : amountInSatoshi }],
      signerInfo,
      fee,
      staticExtendedUtxo,
      amountInSatoshi === "all",
    )
  }

  // send tx

  async sendSignedTx(signedTx: string) {
    let txId = await this.btcInterface.sendRawTransaction(signedTx)
    return txId
  }

  async sendSignedPsbt(signedPsbt: string) {
    let signedTx = this.signer.finalizePsbts([signedPsbt])
    let txId = await this.sendSignedTx(signedTx)
    return txId
  }

  async sendSignedPsbtWithRetry(signedPsbt: string, { maxTries = 5, retrySleep = 5000 } = {}) {
    return runWithRetries(() => this.sendSignedPsbt(signedPsbt), {
      retrySleep,
      maxTries,
    })
  }

  async sendMultiSignedPsbt(signedPsbts: string[] = []) {
    let signedTx = this.signer.finalizePsbts(signedPsbts)
    let txId = await this.btcInterface.sendRawTransaction(signedTx)
    return txId
  }

  // increase transaction fee (beta vesrion)
  async increaseTransactionFeeUnsignedPsbt(
    txId: string,
    signerInfos: SignerInfo[],
    extraExtendedUtxo: ExtendedUtxo[],
    changeAddress: string,
    staticFeeRate?: number,
  ) {
    let transaction = await this.btcInterface.apiProvider.getTransaction(txId)

    let extendedUtxo = transaction.vin.map((vi) => ({
      signerInfo: signerInfos.find((s) => s.address === vi.address)!,
      hash: vi.txId,
      value: +vi.value,
      index: vi.index,
    }))

    if (extendedUtxo.find((x) => !x.signerInfo?.address)) {
      throw new Error("signerInfo not match")
    }

    let changeIndex = transaction.vout.findIndex((vo) =>
      transaction.vin.find((vi) => vo.address === vi.address || vo.address === changeAddress),
    )

    const feeRate = staticFeeRate || (await this.btcInterface.getFeeRate("fast"))

    let targets = transaction.vout
      .filter((_, index) => index !== changeIndex)
      .map((vo) =>
        vo.address
          ? {
              address: vo.address,
              value: vo.value,
            }
          : {
              script: Buffer.from(vo.script, "hex"),
              value: vo.value,
            },
      )
    return this.transactionBuilder.processUnsignedTransaction({
      extendedUtxo: [...extendedUtxo, ...extraExtendedUtxo],
      targets,
      feeRate,
      changeAddress: changeIndex >= 0 ? transaction.vout[changeIndex].address : changeAddress,
      selectType: "inOrder",
    })
  }
}
