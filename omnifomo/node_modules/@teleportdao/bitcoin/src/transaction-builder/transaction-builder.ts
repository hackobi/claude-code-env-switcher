/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable no-underscore-dangle */
import * as bitcoin from "bitcoinjs-lib"

import { createAddressObjectByPublicKey, getAddressType } from "../bitcoin-utils"

const coinselect = require("coinselect")
const coinselectSplit = require("coinselect/split")
const coinselectAccumulative = require("coinselect/accumulative")

// https://bitcoin.stackexchange.com/questions/84004/how-do-virtual-size-stripped-size-and-raw-size-compare-between-legacy-address-f
// export const componentBytes = {
//   bytePerInput: {
//     p2pkh: 148,
//     p2wpkh: 70, // 68
//     "p2sh-p2wpkh": 91,
//     p2tr: 60, // actual 58
//   },
//   baseTxBytes: 10 + 5, // +5 extra bytes to be sure
//   bytePerOutput: {
//     p2pkh: 35, // 34
//     p2wpkh: 35, // 31
//     p2sh: 35, // 32
//     p2tr: 45, // 43
//     default: 35,
//   },
//
// }
export const componentBytes = {
  bytePerInput: {
    p2pkh: 148,
    p2wpkh: 68, // 68
    "p2sh-p2wpkh": 91,
    p2tr: 58, // actual 58
    default: 100,
  },
  baseTxBytes: 10 + 5, // +5 extra bytes to be sure
  bytePerOutput: {
    p2pkh: 34, // 34
    p2wpkh: 31, // 31
    p2sh: 32, // 32
    p2tr: 43, // 43
    default: 35,
    max: 45,
  },

  scriptExtraBytes: {
    lessThan255: 12,
    moreThan255: 15,
  },
}

export const DUST = 1000

export type Utxo = {
  hash: string
  value: number
  index: number
}
export type SignerInfo = {
  address: string
  publicKey: string
  addressType: string
  derivationPath?: string
  masterFingerprint?: string
  includeHex?: boolean
}
export type ExtendedUtxo = {
  signerInfo: SignerInfo
  hash: string
  value: number
  index: number
}

export type TargetAddress = {
  address: string
  value: number
}

export type TargetScript = {
  script: Buffer
  value: number
}
export type Target = TargetAddress | TargetScript
export type ChangeTarget = TargetAddress & {
  bip32Derivation?: {
    path: string
    pubkey: Buffer
    masterFingerprint: Buffer
  }[]
}

export type BitcoinJSInputInfo = ExtendedUtxo & {
  bip32Derivation?: {
    path: string
    pubkey: Buffer
    masterFingerprint: Buffer
  }[]
  nonWitnessUtxo?: Buffer
  witnessUtxo?: {
    script: Buffer
    value: number
  }
  redeemScript?: Buffer
  tapInternalKey?: Buffer
}

export type ExtendedUnsignedTransaction = {
  unsignedTransaction: string
  outputs: Target[]
  inputs: {
    hash: string
    value: number
    index: number
    signerInfo: SignerInfo
  }[]
  fee: number
  change: TargetAddress | undefined
}

function coinSelectInOrder(
  utxos: { hash: string; index: number; value: number }[],
  outputs: {
    address?: string
    script?: Buffer
    value: number
  }[],
  feeRate: number,
) {
  let response = coinselectAccumulative(utxos, outputs, 1)
  return {
    ...response,
    fee: +(+response.fee * feeRate).toFixed(),
  }
}

export abstract class BaseTransactionBuilder {
  testnet: boolean
  network: bitcoin.Network
  maximumNumberOfOutputsInTransaction: number
  feeMin: number
  dustLimit: number
  NO_RBF_SEQUENCE = 0xffffffff
  // abstract
  constructor({
    network,
    testnet,
    feeMin = 0,
    dustLimit,
    maximumNumberOfOutputsInTransaction = 50,
  }: {
    network: bitcoin.Network
    testnet: boolean
    feeMin?: number
    dustLimit?: number
    maximumNumberOfOutputsInTransaction?: number
  }) {
    this.testnet = testnet
    this.network = network
    this.maximumNumberOfOutputsInTransaction = maximumNumberOfOutputsInTransaction
    this.feeMin = feeMin
    this.dustLimit = dustLimit || 1 * 2 * componentBytes.bytePerInput.p2pkh
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  abstract _getTransactionHex(transactionId: string): Promise<string>

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  createAddressObject(input: { addressType: string; publicKey: Buffer }) {
    return createAddressObjectByPublicKey(input, this.network)
  }

  // methods
  validateAddress(address: string) {
    try {
      getAddressType(address, this.network)
      return true
    } catch (error) {
      return false
    }
  }

  getOpReturnTarget(dataHex: string) {
    if (!(dataHex.length > 0)) throw new Error("invalid data in hex")
    const embed = bitcoin.payments.embed({
      data: [Buffer.from(dataHex, "hex")],
      network: this.network,
    })
    return {
      script: embed.output!,
      value: 0,
    }
  }

  calculateTxSize(
    inputTypes: string[],
    outputs: {
      script?: Buffer
      address?: string
      value: number
    }[],
    changeAddressType = "default",
  ) {
    const inputsSizes = inputTypes.map(
      (addressType) =>
        componentBytes.bytePerInput[addressType as keyof typeof componentBytes.bytePerInput],
    )
    const outputSizes = outputs.map((outP: any) => {
      if (outP.address) {
        let addressType = "default"
        try {
          addressType = getAddressType(outP.address, this.network)
        } catch {
          addressType = "default"
        }
        return componentBytes.bytePerOutput[
          addressType as keyof typeof componentBytes.bytePerOutput
        ]
      }

      if (outP.script) {
        if (outP.script.byteLength < 255) {
          return outP.script.byteLength + componentBytes.scriptExtraBytes.lessThan255
        }
        return outP.script.byteLength + componentBytes.scriptExtraBytes.moreThan255
      }

      return componentBytes.bytePerOutput[
        changeAddressType as keyof typeof componentBytes.bytePerOutput
      ]
    })

    const txSize: number =
      componentBytes.baseTxBytes +
      inputsSizes.reduce((a, c) => a + c, 0) +
      outputSizes.reduce((a, c) => a + c, 0)

    return txSize
  }

  helperHandleInputsAndOutputs({
    targets,
    extendedUtxo,
    feeRate,
    changeObject,
    selectType = "normal", // "accumulative" | "normal" | "full"
  }: {
    extendedUtxo: ExtendedUtxo[]
    targets: Target[]
    feeRate: number
    changeObject?: {
      address: string
      publicKey?: string
      addressType?: string
      derivationPath?: string
      masterFingerprint?: string
    }
    selectType?: "normal" | "accumulative" | "full" | "inOrder"
  }) {
    const filteredUtxo = extendedUtxo.filter(
      (u) =>
        u.value >
        +feeRate *
          componentBytes.bytePerInput[
            u.signerInfo.addressType as keyof typeof componentBytes.bytePerInput
          ],
    )
    let selectResponse
    switch (selectType) {
      case "normal":
        selectResponse = coinselect(filteredUtxo, targets, Math.round(feeRate))
        break
      case "accumulative":
        selectResponse = coinselectAccumulative(filteredUtxo, targets, Math.round(feeRate))
        break
      case "inOrder":
        selectResponse = coinSelectInOrder(filteredUtxo, targets, Math.round(feeRate))
        break
      case "full":
        if (!(targets[0] as TargetAddress).address) {
          throw new Error()
        }
        selectResponse = coinselectSplit(
          filteredUtxo,
          [{ address: (targets[0] as TargetAddress).address }],
          Math.round(feeRate),
        )
        break
      default:
        break
    }

    let {
      inputs,
      outputs,
      fee,
    }: {
      inputs?: ExtendedUtxo[]
      outputs?: {
        script?: Buffer
        address?: string
        value: number
      }[]
      fee: number
    } = selectResponse

    if (!inputs || !outputs) {
      inputs = filteredUtxo
      outputs = targets
      fee = inputs.reduce((a, b) => a + b.value, 0) - outputs.reduce((a, b) => a + b.value, 0)
    }

    let changeAddressType = "default"
    try {
      changeAddressType = getAddressType(changeObject?.address || "", this.network)
    } catch {
      changeAddressType = "default"
    }

    const txSize =
      this.calculateTxSize(
        inputs.map((i) => i.signerInfo.addressType),
        outputs,
        changeAddressType,
      ) + componentBytes.bytePerOutput.default

    let txFee = Math.round(txSize * feeRate)
    if (Math.round(feeRate) === 1) {
      txFee = Math.round(txFee + txFee * 0.1)
    }
    if (
      inputs.reduce((a, b) => a + b.value, 0) -
        outputs.filter((o) => o.address || o.script).reduce((a, b) => a + b.value, 0) -
        txFee <
      0
    ) {
      let spendableBalance = inputs.reduce((a, b) => a + b.value, 0)
      let totalOutputAmount = outputs
        .filter((o) => o.address || o.script)
        .reduce((a, b) => a + b.value, 0)
      let need = spendableBalance - totalOutputAmount - txFee
      throw new Error(
        `not enough balance. details: ${JSON.stringify(
          { spendableBalance, totalOutputAmount, txFee, need },
          null,
          2,
        )}`,
      )
    }
    let diff = fee - txFee
    let changeIndex = outputs.findIndex((x) => !x?.address && !x.script && (x.value || 0) > 0)
    let change: ChangeTarget | undefined
    if (changeIndex >= 0 || diff > DUST) {
      if (changeIndex >= 0) {
        diff = diff + componentBytes.bytePerOutput.default * Math.round(feeRate)
      }

      if (diff < 0) {
        diff = 0
      }

      if (selectType === "full") {
        outputs[0].value = outputs[0].value + diff
        fee = fee - diff
      } else {
        if (!changeObject) throw new Error("change not exist")
        change = {
          address: changeObject.address,
          value: changeIndex >= 0 ? outputs[changeIndex].value + diff : diff,
        }
        fee = fee - diff
      }

      if (changeIndex >= 0) {
        outputs.splice(changeIndex, 1)
      }
    }

    return {
      inputs,
      fee,
      outputs: outputs as Target[],
      change,
    }
  }

  async filterAndConvertTxDataToStandardFormat({
    extendedUtxo,
    targets,
    changeObject,
    feeRate,
    selectType,
  }: {
    extendedUtxo: ExtendedUtxo[]
    targets: Target[]
    feeRate: number
    changeObject?: {
      address: string
      publicKey?: string
      addressType?: string
      derivationPath?: string
      masterFingerprint?: string
    }
    selectType?: "normal" | "accumulative" | "full" | "inOrder"
  }) {
    let {
      inputs: filteredInputs,
      outputs,
      change,
      fee,
    } = this.helperHandleInputsAndOutputs({
      targets,
      extendedUtxo,
      feeRate,
      changeObject,
      selectType,
    })

    let inputs = await this.convertExtendedUtxoToInputs(filteredInputs)

    return {
      inputs,
      outputs,
      change,
      fee,
      feeRate,
    }
  }

  // ?note : we can extend this class and change this method for network other than bitcoin
  async convertExtendedUtxoToInputs(baseInputs: ExtendedUtxo[] = []) {
    let inputs: (BitcoinJSInputInfo & {
      signerInfo: SignerInfo
    })[] = baseInputs
    const transactionHex: { [key: string]: string } = {}
    for (let i in inputs) {
      let { address, publicKey, derivationPath, masterFingerprint, addressType } =
        inputs[i].signerInfo
      // todo : support without publicKey
      let addressObject = this.createAddressObject({
        publicKey: Buffer.from(publicKey, "hex"),
        addressType,
      })
      if (derivationPath && masterFingerprint && addressObject.pubkey) {
        inputs[i].bip32Derivation = [
          {
            path: derivationPath,
            pubkey: addressObject.pubkey,
            masterFingerprint: Buffer.from(masterFingerprint, "hex"),
          },
        ]
      }
      if (addressType === "p2pkh") {
        const txHex =
          transactionHex[inputs[i].hash] || (await this._getTransactionHex(inputs[i].hash))
        transactionHex[inputs[i].hash] = txHex
        inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex")
      } else if (addressType === "p2wpkh") {
        // add p2wpkh data
        if (!addressObject.output) throw new Error("invalid signer info")
        inputs[i].witnessUtxo = {
          script: addressObject.output,
          value: inputs[i].value,
        }

        if (inputs[i].signerInfo.includeHex) {
          const txHex =
            transactionHex[inputs[i].hash] || (await this._getTransactionHex(inputs[i].hash))
          transactionHex[inputs[i].hash] = txHex
          inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex")
        }
      } else if (addressType === "p2sh-p2wpkh") {
        // add p2sh-p2wpkh data
        if (!addressObject.output) throw new Error("invalid signer info")
        inputs[i].witnessUtxo = {
          script: addressObject.output,
          value: inputs[i].value,
        }
        if (!addressObject?.redeem?.output) throw new Error("invalid signer info for p2sh address")
        inputs[i].redeemScript = addressObject.redeem.output

        if (inputs[i].signerInfo.includeHex) {
          const txHex =
            transactionHex[inputs[i].hash] || (await this._getTransactionHex(inputs[i].hash))
          transactionHex[inputs[i].hash] = txHex
          inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex")
        }
      } else if (addressType === "p2tr") {
        if (!addressObject.output) throw new Error("invalid signer info")
        inputs[i].witnessUtxo = {
          script: addressObject.output,
          value: inputs[i].value,
        }
        if (!addressObject.pubkey) throw new Error("invalid signer info for p2tr address (pubkey)")
        inputs[i].tapInternalKey = addressObject.internalPubkey

        if (inputs[i].signerInfo.includeHex) {
          const txHex =
            transactionHex[inputs[i].hash] || (await this._getTransactionHex(inputs[i].hash))
          transactionHex[inputs[i].hash] = txHex
          inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex")
        }
      }
    }

    return inputs
  }

  // ?note : we can extend this class and change this method for network other than bitcoin
  createUnsignedTransaction({
    inputs,
    outputs,
    change,
    fee, // not used  in this section - just returned
    feeRate,
    sequenceNumber,
  }: {
    inputs: BitcoinJSInputInfo[]
    outputs: Target[]
    change?: ChangeTarget
    fee: number
    feeRate: number
    sequenceNumber?: number
  }) {
    const sequence = sequenceNumber || this.NO_RBF_SEQUENCE - 2
    const { network } = this
    const newPsbt = new bitcoin.Psbt({ network })
    newPsbt.setMaximumFeeRate(+(feeRate + feeRate / 100).toFixed())
    // add input
    for (const input of inputs) {
      let { addressType } = input.signerInfo
      switch (addressType) {
        case "p2pkh": {
          let i = {
            hash: input.hash,
            index: Number(input.index),
            nonWitnessUtxo: input.nonWitnessUtxo,
            sequence,
            bip32Derivation: input.bip32Derivation,
          }
          if (!i.bip32Derivation) delete i.bip32Derivation
          newPsbt.addInput(i)
          break
        }
        case "p2wpkh": {
          let i = {
            hash: input.hash,
            index: Number(input.index),
            witnessUtxo: input.witnessUtxo,
            // we dont need nonWitnessUtxo. bud some application force nonWitnessUtxo
            nonWitnessUtxo: input.nonWitnessUtxo,
            sequence,
            bip32Derivation: input.bip32Derivation,
          }
          if (!i.bip32Derivation) delete i.bip32Derivation
          if (!i.nonWitnessUtxo) delete i.nonWitnessUtxo
          newPsbt.addInput(i)
          break
        }
        case "p2sh-p2wpkh": {
          let i = {
            hash: input.hash,
            index: Number(input.index),
            witnessUtxo: input.witnessUtxo,
            // we dont need nonWitnessUtxo. bud some application force nonWitnessUtxo
            nonWitnessUtxo: input.nonWitnessUtxo,
            redeemScript: input.redeemScript,
            sequence,
            bip32Derivation: input.bip32Derivation,
          }
          if (!i.bip32Derivation) delete i.bip32Derivation
          if (!i.nonWitnessUtxo) delete i.nonWitnessUtxo
          newPsbt.addInput(i)
          break
        }
        case "p2tr": {
          let i = {
            hash: input.hash,
            index: Number(input.index),
            witnessUtxo: input.witnessUtxo,
            // we dont need nonWitnessUtxo. bud some application force nonWitnessUtxo
            nonWitnessUtxo: input.nonWitnessUtxo,
            tapInternalKey: input.tapInternalKey,
            sequence,
            bip32Derivation: input.bip32Derivation,
          }
          if (!i.bip32Derivation) delete i.bip32Derivation
          if (!i.nonWitnessUtxo) delete i.nonWitnessUtxo
          newPsbt.addInput(i)
          break
        }
        default:
          throw new Error("address type is incorrect")
      }
    }

    // add outputs
    for (const target of outputs) {
      newPsbt.addOutput(target)
    }

    // add changeAddress
    if (change && Object.keys(change).length !== 0) {
      newPsbt.addOutput(change)
    }

    // check created outputs with targets
    if (change && Object.keys(change).length !== 0) {
      if (newPsbt.txOutputs[outputs.length].address !== change.address) {
        throw new Error("error change address")
      }
      // if (newPsbt.txOutputs[outputs.length].value !== change.value) {
      //   throw new Error("error change value")
      // }
    }

    const unsignedPsbtBaseText = newPsbt.toBase64()

    const safeAddressTypeForPossibleTxId = ["p2wpkh", "p2tr"]
    const isPossibleTxId = inputs.reduce(
      (a, b) => a && safeAddressTypeForPossibleTxId.includes(b.signerInfo.addressType),
      true,
    )

    return {
      unsignedTransaction: unsignedPsbtBaseText,
      outputs,
      inputs: inputs.map((utx) => ({
        hash: utx.hash,
        value: Number(utx.value),
        index: utx.index,
        signerInfo: utx.signerInfo,
      })),
      fee,
      change,
      possibleTxId: isPossibleTxId ? this.getUnsignedPsbtTxId(unsignedPsbtBaseText) : undefined,
    }
  }

  async processUnsignedTransaction({
    extendedUtxo,
    targets = [],
    changeAddress = undefined,
    fullAmount = false,
    feeRate,
    selectType = "normal",
    sequenceNumber,
  }: {
    extendedUtxo: ExtendedUtxo[]
    targets: Target[]
    feeRate: number
    changeAddress?: string | SignerInfo
    fullAmount?: boolean
    selectType?: "normal" | "accumulative" | "full" | "inOrder"
    sequenceNumber?: number
  }) {
    if (!changeAddress && targets.length === 0) throw new Error("no target")
    let changeObject =
      typeof changeAddress === "string"
        ? {
            address: changeAddress,
          }
        : changeAddress
    const { inputs, outputs, change, fee } = await this.filterAndConvertTxDataToStandardFormat({
      extendedUtxo,
      targets,
      changeObject,
      feeRate,
      selectType: fullAmount ? "full" : selectType,
    })
    let unsignedTransaction = this.createUnsignedTransaction({
      inputs,
      outputs,
      change,
      fee,
      feeRate,
      sequenceNumber,
    })

    return unsignedTransaction
  }

  //  use with caution. just segwit address
  getUnsignedPsbtTxId(unsignedPsbt: string): string {
    //  use with caution
    let psbt = bitcoin.Psbt.fromBase64(unsignedPsbt, {
      network: this.network,
    })
    return (psbt as any).__CACHE.__TX.getId()
  }
}
