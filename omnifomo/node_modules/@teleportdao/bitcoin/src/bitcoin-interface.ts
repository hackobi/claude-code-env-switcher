import { bitcoin as bitcoinProvider } from "@teleportdao/providers"
import { runWithRetries } from "./utils/tools"
import {
  parseRawTransaction,
  calculateMerkleProof,
  extractTransactionsAndBlockInfoFromRawBlock,
} from "./bitcoin-utils"
import BitcoinInterfaceWallet from "./bitcoin-interface-wallet"

export class BitcoinInterface extends BitcoinInterfaceWallet {
  async getLatestBlockNumber(): Promise<number> {
    let latestHeight = await (this.rpcProvider || this.apiProvider).getLatestBlockNumber()
    return latestHeight
  }

  async getBlockHash(blockNumber: number): Promise<string> {
    let headerHash = await runWithRetries(() =>
      (this.rpcProvider || this.apiProvider).getBlockHash(blockNumber),
    )
    return headerHash
  }

  async getBlockHeaderHex(blockNumber: number): Promise<string> {
    let headerHex = await runWithRetries(() =>
      (this.rpcProvider || this.apiProvider).getBlockHeaderHex(blockNumber),
    )
    return headerHex
  }

  async getTransaction(txId: string) {
    return (this.rpcProvider || this.apiProvider).getTransaction(txId)
  }

  async getRawTransaction(txId: string) {
    return (this.rpcProvider || this.apiProvider).getRawTransaction(txId)
  }

  async sendRawTransaction(txId: string) {
    return (this.rpcProvider || this.apiProvider).sendRawTransaction(txId)
  }

  async getMerkleProof(
    txId: string,
    blockHash: string,
  ): Promise<{
    intermediateNodes: string
    transactionIndex: number
  }> {
    if (!this.rpcProvider) {
      return this.apiProvider.getMerkleProof(txId)
    }
    let txIds = await runWithRetries(() => this.rpcProvider!.getBlockTransactionIds(blockHash), {
      maxTries: 5,
      retrySleep: 2000,
    })
    let proof = calculateMerkleProof(txIds, txId)
    return proof
  }

  async getRequestProof(transaction: {
    txId: string
    hex?: string
    blockHash?: string
    blockNumber?: number
    merkleProof?: {
      intermediateNodes: string
      transactionIndex: number
    }
  }) {
    let transactionHex = transaction.hex || (await this.getRawTransaction(transaction.txId))

    let blockHash = transaction.blockHash
    let blockNumber = transaction.blockNumber
    if (!(transaction.blockHash && transaction.blockNumber)) {
      let txInfo = await this.getTransaction(transaction.txId)
      blockHash = txInfo.blockHash
      blockNumber = txInfo.blockNumber
    }
    let parsedTx = parseRawTransaction(transactionHex)
    let merkleProof =
      transaction.merkleProof || (await this.getMerkleProof(transaction.txId, blockHash!))

    return {
      parsedTx,
      merkleProof,
      blockNumber: blockNumber!,
      blockHash: blockHash!,
    }
  }

  // rpc
  async getBlockTransactions(
    addresses: string[],
    blockNumber: number,
    inputTxIds: {
      txId: string
      index: number
      address: string
      script?: string | undefined
      value?: number | undefined
    }[] = [],
  ) {
    if (!this.rpcProvider) {
      throw new Error("RPC provider not set")
    }
    let rawBlockHex = await runWithRetries(
      () => this.rpcProvider!.getBlockByBlockNumber(blockNumber, 0),
      {
        maxTries: 10,
        retrySleep: 2000,
      },
    )
    return extractTransactionsAndBlockInfoFromRawBlock(
      rawBlockHex,
      blockNumber,
      addresses,
      inputTxIds,
      this.network,
    )
  }

  // from start+1 to end
  async getMultipleBlocksTransactions(
    addresses: string[],
    startBlockNumber: number,
    endBlockNumber: number,
    inputTxIds: {
      txId: string
      index: number
      address: string
      script?: string | undefined
      value?: number | undefined
    }[] = [],
  ) {
    let blockTxs = []
    for (let blockNumber = +startBlockNumber + 1; blockNumber <= endBlockNumber; blockNumber += 1) {
      console.log(blockNumber)
      const response = await this.getBlockTransactions(addresses, blockNumber, inputTxIds)
      blockTxs.push(response.withdrawTxs, response.depositTxs)
    }
    blockTxs = await Promise.all(blockTxs)
    return blockTxs.flat(1)
  }
}

export default BitcoinInterface
