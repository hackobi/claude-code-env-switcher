/* eslint-disable @typescript-eslint/no-var-requires */
import * as bip39 from "bip39"
import BIP32Factory from "bip32"
import * as ecc from "@bitcoinerlab/secp256k1"
import * as bitcoin from "bitcoinjs-lib"
import * as bitcoinEcPair from "bitcoinjs-ecpair"
import networks from "./utils/networks"
import { Transaction } from "./type"

const bip32 = BIP32Factory(ecc)
const { ECPair } = bitcoinEcPair

bitcoin.initEccLib(ecc)

const varUnit = require("varuint-bitcoin")
const fastRoot = require("merkle-lib/fastRoot")
const merkle = require("merkle-lib")
const merkleProof = require("merkle-lib/proof")

// const bip32Prefix = {
//   xprv: "0x0488ade4", // Mainnet - P2PKH or P2SH  - m/44'/0'
//   yprv: "0x049d7878", // Mainnet - P2WPKH in P2SH - m/49'/0'
//   zprv: "0x04b2430c", // Mainnet - P2WPKH 	     - m/84'/0'
//   Yprv: "0x0295b005", // Mainnet - Multi-signature P2WSH in P2SH
//   Zprv: "0x02aa7a99", // Mainnet - Multi-signature P2WSH
//   tprv: "0x04358394", // Testnet - P2PKH or P2SH  - m/44'/1'
//   uprv: "0x044a4e28", // Testnet - P2WPKH in P2SH - m/49'/1'
//   vprv: "0x045f18bc", // Testnet - P2WPKH         - m/84'/1'
//   Uprv: "0x024285b5", // Testnet - Multi-signature P2WSH in P2SH
//   Vprv: "0x02575048", // Testnet - Multi-signature P2WSH

//   xpub: "0x0488b21e", // Mainnet - P2PKH or P2SH  - m/44'/0'
//   ypub: "0x049d7cb2", // Mainnet - P2WPKH in P2SH - m/49'/0'
//   zpub: "0x04b24746", // Mainnet - P2WPKH 	     - m/84'/0'
//   Ypub: "0x0295b43f", // Mainnet - Multi-signature P2WSH in P2SH
//   Zpub: "0x02aa7ed3", // Mainnet - Multi-signature P2WSH
//   tpub: "0x043587cf", // Testnet - P2PKH or P2SH  - m/44'/1'
//   upub: "0x044a5262", // Testnet - P2WPKH in P2SH - m/49'/1'
//   vpub: "0x045f1cf6", // Testnet - P2WPKH         - m/84'/1'
//   Upub: "0x024289ef", // Testnet - Multi-signature P2WSH in P2SH
//   Vpub: "0x02575483", // Testnet - Multi-signature P2WSH
// }
export { networks }

export function generateMnemonic() {
  const mnemonic = bip39.generateMnemonic(256)
  return mnemonic
}

export async function getPrivateKeyHexFromMnemonic(mnemonic: string, index = 0, isChange = false) {
  const node = bip32.fromSeed(await bip39.mnemonicToSeed(mnemonic))
  return node
    .derive(isChange ? 1 : 0)
    .derive(index)
    .privateKey!.toString("hex")
}

export function reverseBytes(hexInput: string) {
  return Buffer.from(hexInput, "hex").reverse().toString("hex")
}

export function getPublicKeyHexByXpubAndIndex(
  xpub: string,
  index = 0,
  isChange = false,
  network = networks.bitcoin,
) {
  const node = bip32.fromBase58(xpub, network)
  return node
    .derive(isChange ? 1 : 0)
    .derive(index)
    .publicKey.toString("hex")
}

export function getPubKeyFromPrivateKeyWIF(
  privateKeyWIF: string,
  network = bitcoin.networks.bitcoin,
) {
  let key = ECPair.fromWIF(privateKeyWIF, network)
  return key.publicKey
}

export function getPubKeyFromPrivateKeyHex(
  privateKeyHex: string,
  network = bitcoin.networks.bitcoin,
) {
  let key = ECPair.fromPrivateKey(Buffer.from(privateKeyHex, "hex"), { network })
  return key.publicKey
}

export function getPrivateKeyHexFromWIF(privateKeyWIF: string, network = bitcoin.networks.bitcoin) {
  let key = ECPair.fromWIF(privateKeyWIF, network)
  return key.privateKey!.toString("hex")
}

export function parseRawTransaction(rawTransaction: string) {
  const size = {
    version: 4,
    flag: 2,
    tx: 32,
    index: 4,
    sequence: 4,
    amount: 8,
  }

  let offset = 0
  let version = rawTransaction.slice(offset, size.version * 2)
  offset += size.version * 2
  let flag = rawTransaction.slice(offset, offset + size.flag * 2)
  offset = flag === "0001" ? offset + size.flag * 2 : offset // * 0x0001 is flag in segwit transactions

  let inputsStartIndex = offset

  let numberOfInputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
  let noiSize = varUnit.encodingLength(numberOfInputs)
  offset += noiSize * 2

  for (let i = 0; i < numberOfInputs; i += 1) {
    offset += size.tx * 2
    offset += size.index * 2
    let sigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
    let sigLengthSize = varUnit.encodingLength(sigLength)
    offset += sigLengthSize * 2
    offset += sigLength * 2
    offset += size.sequence * 2
  }
  let inputLastIndex = offset
  let outputStartIndex = offset

  let numberOfOutputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
  let nooSize = varUnit.encodingLength(numberOfOutputs)
  offset += nooSize * 2

  for (let i = 0; i < numberOfOutputs; i += 1) {
    offset += size.amount * 2
    let unlockSigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
    let unlockSigLengthSize = varUnit.encodingLength(unlockSigLength)
    offset += unlockSigLengthSize * 2
    offset += unlockSigLength * 2
  }
  let outputLastIndex = offset

  version = `0x${version}`
  flag = `0x${flag}`
  const vin = `0x${rawTransaction.slice(inputsStartIndex, inputLastIndex)}`
  const vout = `0x${rawTransaction.slice(outputStartIndex, outputLastIndex)}`
  let witness = `0x${rawTransaction.slice(outputLastIndex, rawTransaction.length - 8)}`
  let locktime = `0x${rawTransaction.slice(rawTransaction.length - 8, rawTransaction.length)}`
  return { version, flag, vin, vout, witness, locktime }
}

export function calculateMerkleProof(
  blockTransactions: string[],
  txId: string,
  blockMerkleRoot?: string,
) {
  let transactionIndex = blockTransactions.findIndex((tx) => tx === txId)
  if (transactionIndex < 0) throw new Error("txId is not in this tree")
  let data = blockTransactions.map((a) => Buffer.from(a, "hex").reverse())

  if (
    blockMerkleRoot &&
    blockMerkleRoot !== fastRoot(data, bitcoin.crypto.hash256).toString("hex")
  ) {
    throw new Error("calculated merkleRoot and block merkleRoot not matched")
  }

  let tree = merkle(data, bitcoin.crypto.hash256)
  let proof = merkleProof(tree, data[transactionIndex])

  let intermediateNodesArray = proof
    .map((_id?: Buffer) => _id && _id.toString("hex"))
    .filter((_id?: Buffer) => _id != null)
  let intermediateNodes: string = intermediateNodesArray.reduce(
    (a: string, value: string, index: number) =>
      index !== transactionIndex % 2 && index < intermediateNodesArray.length - 1 ? a + value : a,
    "0x",
  )
  return {
    intermediateNodes,
    transactionIndex,
  }
}

export function parseBlockHeader(headerHex: string) {
  const size: {
    [key: string]: number
  } = {
    version: 4,
    previousBlockHash: 32,
    merkleRoot: 32,
    timestamp: 4,
    difficulty: 4,
    nonce: 4,
  }
  let offset = 0
  let result: {
    [key: string]: string
  } = {}
  for (let key in size) {
    result[key] = headerHex.slice(offset, offset + size[key] * 2)
    offset += size[key] * 2
  }
  return result as {
    version: string
    previousBlockHash: string
    merkleRoot: string
    timestamp: string
    difficulty: string
    nonce: string
  }
}

export function getAddressType(address: string, network = bitcoin.networks.bitcoin) {
  if (address.startsWith(`${network.bech32}1p`)) {
    // todo validate p2tr address
    return "p2tr"
  }
  if (address.startsWith(network.bech32)) {
    bitcoin.address.fromBech32(address)
    return "p2wpkh"
  }
  let base58Data = bitcoin.address.fromBase58Check(address)
  if (base58Data.version === Number(network.scriptHash)) {
    return "p2sh"
  }
  if (base58Data.version === Number(network.pubKeyHash)) {
    return "p2pkh"
  }

  throw new Error("invalid address")
}

export function createAddressObjectByAddress(address: string, network = bitcoin.networks.bitcoin) {
  let addressType = getAddressType(address, network)
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        address,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        address,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        address,
        network,
      })
      break
    case "p2tr":
      addressObject = bitcoin.payments.p2tr({
        address,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return { addressObject, addressType }
}

// used in block parser functions ( newt 2 functions )
export function convertBitcoinScriptToAddress(script: Buffer, network = bitcoin.networks.bitcoin) {
  try {
    return bitcoin.address.fromOutputScript(script, network)
  } catch (error) {
    return undefined
  }
}

export function parseRawBlock(
  rawBlockHex: string,
  blockNumber?: number,
  network = bitcoin.networks.bitcoin,
) {
  let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"))
  let blockHash = block.getHash().toString("hex")
  let merkleRoot = block.merkleRoot!.toString("hex")
  let prvBlockHash = block.prevHash!.toString("hex")
  return {
    blockNumber,
    merkleRoot,
    prvBlockHash,
    transactions: block.transactions?.map((tx) => ({
      txId: tx.getId(),
      version: tx.version,
      locktime: tx.locktime,
      blockNumber,
      blockHash,
      vout: tx.outs.map((vo, index) => ({
        address: convertBitcoinScriptToAddress(vo.script, network),
        script: vo.script.toString("hex"),
        value: vo.value,
        index,
      })),
      vin: tx.ins.map((vi) => ({
        txId: Buffer.from(vi.hash).reverse().toString("hex"),
        index: vi.index,
      })),
    })),
  }
}

export function extractTransactionsAndBlockInfoFromRawBlock(
  rawBlockHex: string,
  blockNumber: number,
  addresses: string[] = [],
  inputTxIds: {
    txId: string
    index: number
    address: string
    script?: string
    value?: number
  }[] = [],
  network = bitcoin.networks.bitcoin,
) {
  let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"))
  let blockHash = block.getHash().reverse().toString("hex")
  let merkleRoot = block.merkleRoot!.toString("hex")
  let prvBlockHash = block.prevHash!.toString("hex")

  let blockInfo = {
    blockNumber,
    blockHash,
    merkleRoot,
    prvBlockHash,
  }

  let addressScript = addresses.map((address) =>
    createAddressObjectByAddress(address, network).addressObject.output!.toString("hex"),
  )

  let blockTxIds = block.transactions!.map((tx) => tx.getId())

  let withdrawTxs: Transaction[] = []
  let depositTxs: Transaction[] = []
  block.transactions?.forEach((tx) => {
    let txId = tx.getId()

    let inputTxAddress: string | undefined
    let isWithdraw = tx.ins.find((vi) => {
      let viTxId = Buffer.from(vi.hash).reverse().toString("hex")
      let viInput = inputTxIds.find((vin) => vin.txId === viTxId && vin.index === vi.index)
      inputTxAddress = viInput?.address
      return !!inputTxAddress
    })
    if (isWithdraw && inputTxAddress) {
      let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot)

      withdrawTxs.push({
        txId: tx.getId(),
        version: tx.version,
        locktime: tx.locktime,
        blockNumber,
        blockHash,
        merkleProof: txMerkleProof,
        vout: tx.outs.map((vo) => ({
          address: convertBitcoinScriptToAddress(vo.script, network),
          script: vo.script.toString("hex"),
          value: vo.value,
        })),
        vin: tx.ins.map((vi) => {
          let viTxId = Buffer.from(vi.hash).reverse().toString("hex")
          let viInput = inputTxIds.find((vin) => vin.txId === viTxId && vin.index === vi.index)
          return {
            txId: Buffer.from(vi.hash).reverse().toString("hex"),
            index: vi.index,
            address: viInput?.address,
            script: viInput?.script,
            value: viInput?.value,
          }
        }),
        address: inputTxAddress,
        addressScript: createAddressObjectByAddress(
          inputTxAddress,
          network,
        ).addressObject.output!.toString("hex"),
      })
    }

    let addressIndex: number = -1
    let isDeposit = tx.outs.find((blockTxVo) => {
      let sIndex = addressScript.findIndex(
        (addScript) => addScript === blockTxVo.script.toString("hex"),
      )
      if (sIndex >= 0) {
        addressIndex = sIndex
        return true
      }
      return false
    })

    if (isDeposit && addressIndex >= 0) {
      let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot)
      depositTxs.push({
        txId: tx.getId(),
        version: tx.version,
        locktime: tx.locktime,
        blockNumber,
        blockHash,
        merkleProof: txMerkleProof,
        vout: tx.outs.map((vo) => ({
          address: convertBitcoinScriptToAddress(vo.script, network),
          script: vo.script.toString("hex"),
          value: vo.value,
        })),
        vin: tx.ins.map((vi) => ({
          txId: Buffer.from(vi.hash).reverse().toString("hex"),
          index: vi.index,
        })),
        addressScript: addressScript[addressIndex],
        address: addresses[addressIndex],
      })
    }
  })
  return {
    blockInfo,
    withdrawTxs,
    depositTxs,
  }
}

export function validateAddress(address: string, network = bitcoin.networks.bitcoin) {
  try {
    let isValid = false
    let isAddressSegwit = address.startsWith(network.bech32)
    if (isAddressSegwit) {
      bitcoin.address.fromBech32(address)
      isValid = true
    } else {
      let base58Data = bitcoin.address.fromBase58Check(address)
      isValid =
        base58Data.version === Number(network.scriptHash) ||
        base58Data.version === Number(network.pubKeyHash)
    }
    return isValid
  } catch (error) {
    return false
  }
}

function toXOnlyPublicKey(pubKey: Buffer) {
  return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33)
}

export function createAddressObjectByScript(
  { addressType, script }: { addressType: string; script: Buffer },
  network: bitcoin.Network = bitcoin.networks.bitcoin,
) {
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        output: script,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        output: script,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        output: script,
        network,
      })
      break
    case "p2wsh":
      addressObject = bitcoin.payments.p2wsh({
        output: script,
        network,
      })
      break
    case "p2tr":
      addressObject = bitcoin.payments.p2tr({
        output: script,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

export function createAddressObjectByHash(
  { addressType, hash }: { addressType: string; hash: Buffer },
  network: bitcoin.Network = bitcoin.networks.bitcoin,
) {
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        hash,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        hash,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        hash,
        network,
      })
      break
    case "p2wsh":
      addressObject = bitcoin.payments.p2wsh({
        hash,
        network,
      })
      break
    case "p2tr":
      // here hash is the public key of tweaked private key (internal public key)
      addressObject = bitcoin.payments.p2tr({
        pubkey: hash,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

export function createAddressObjectByPublicKey(
  { addressType, publicKey }: { addressType: string; publicKey: Buffer },
  network: bitcoin.Network = bitcoin.networks.bitcoin,
): bitcoin.payments.Payment {
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        pubkey: publicKey,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        pubkey: publicKey,
        network,
      })
      break
    case "p2sh-p2wpkh":
      addressObject = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wpkh({
          pubkey: publicKey,
          network,
        }),
      })
      break
    case "p2tr":
      // this public key is public key of main private key
      addressObject = bitcoin.payments.p2tr({
        internalPubkey: toXOnlyPublicKey(publicKey),
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

export function publicKeyConvertor(publicKeyHex: string, compressed = true) {
  let pubkey = ECPair.fromPublicKey(Buffer.from(publicKeyHex, "hex"), {
    compressed,
  })
  return pubkey.publicKey.toString("hex")
}

export const addressTypeHelper: {
  addressTypesNumber: {
    [key: string]: number
  }
  addressTypes: string[]
} = {
  addressTypesNumber: { p2pk: 0, p2pkh: 1, p2sh: 2, p2wpkh: 3, p2wsh: 4, p2tr: 5 },
  addressTypes: ["p2pk", "p2pkh", "p2sh", "p2wpkh", "p2wsh", "p2tr"],
}
