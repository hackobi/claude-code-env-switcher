import { Psbt, crypto, Network } from "bitcoinjs-lib"
// import BIP32Factory from "bip32"
import ecc from "@bitcoinerlab/secp256k1"
import ECPairFactory from "ecpair"

const ECPair = ECPairFactory(ecc)

function tapTweakHash(pubKey: Buffer, h?: Buffer) {
  return crypto.taggedHash("TapTweak", Buffer.concat(h ? [pubKey, h] : [pubKey]))
}

function tweakSigner(
  privateKey: Buffer,
  network: Network,
  opts = {} as {
    [key: string]: Buffer
  },
) {
  let newPrv = privateKey
  let keyPair = ECPair.fromPrivateKey(privateKey, {
    network,
    compressed: true,
  })

  if (!keyPair.privateKey) throw new Error("private key not exist")

  if (keyPair.publicKey.toString("hex").startsWith("03")) {
    newPrv = ecc.privateNegate(keyPair.privateKey) as Buffer
  }

  const tweakedPrivateKey = ecc.privateAdd(
    newPrv,
    tapTweakHash(Buffer.from(keyPair.publicKey.toString("hex").slice(2), "hex"), opts?.tweakHash),
  )
  if (!tweakedPrivateKey) {
    throw new Error("Invalid tweaked private key!")
  }

  return ECPair.fromPrivateKey(Buffer.from(tweakedPrivateKey), {
    network,
  })
}

class BitcoinLikeSignTransaction {
  network: Network

  constructor(network: Network) {
    this.network = network
  }

  async signPsbt(
    unsignedPsbt: {
      unsignedTransaction: string
      inputsToSign?: number[]
    },
    privateKey: Buffer,
    sighashTypes?: any[],
    usingTweakSignerIfNeeded = true,
  ) {
    const { network } = this
    const keyPair = ECPair.fromPrivateKey(privateKey, {
      network,
      compressed: true,
    })
    const psbt = Psbt.fromBase64(unsignedPsbt.unsignedTransaction, {
      network,
    })

    let numberOfInputs = psbt.inputCount

    for (let i = 0; i < numberOfInputs; i += 1) {
      if (unsignedPsbt.inputsToSign && !unsignedPsbt.inputsToSign.includes(i)) {
        // eslint-disable-next-line no-continue
        continue
      }
      let type = psbt.getInputType(i)

      if (usingTweakSignerIfNeeded && type === "nonstandard") {
        console.log("using tweak signer")
        let a = tweakSigner(privateKey, this.network)
        await psbt.signInputAsync(i, a, sighashTypes)
      } else {
        await psbt.signInputAsync(i, keyPair, sighashTypes)
      }
    }

    // psbt.signAllInputs(keyPair)
    const partialSigendPsbt = psbt.toBase64()
    return partialSigendPsbt
  }

  finalizePsbts(psbtsBase64: string[] = []) {
    const finals = psbtsBase64.map((psbtBase64) =>
      Psbt.fromBase64(psbtBase64, { network: this.network }),
    )
    const psbt =
      finals.length === 1 ? finals[0] : new Psbt({ network: this.network }).combine(...finals)

    psbt.finalizeAllInputs()

    let finalizeTx = psbt.extractTransaction()
    // const rawTx = finalizeTx.toBuffer()
    // const hex = rawTx.toString("hex")
    return finalizeTx.toHex()
  }
}

export default BitcoinLikeSignTransaction
