import * as bitcoin from "bitcoinjs-lib"
import ecc from "@bitcoinerlab/secp256k1"

bitcoin.initEccLib(ecc)

// eslint-disable-next-line consistent-return
export function createAddressObjectByScriptNoType(
  script: Buffer,
  network: bitcoin.Network = bitcoin.networks.bitcoin,
) {
  let addressObject: bitcoin.payments.Payment

  try {
    addressObject = bitcoin.payments.p2pkh({
      output: script,
      network,
    })
    if (addressObject.address) {
      return {
        addressObject,
        addressType: "p2pkh",
      }
    }
  } catch (err) {
    /* empty */
  }

  try {
    addressObject = bitcoin.payments.p2wpkh({
      output: script,
      network,
    })
    if (addressObject.address) {
      return {
        addressObject,
        addressType: "p2wpkh",
      }
    }
  } catch (err) {
    /* empty */
  }

  try {
    addressObject = bitcoin.payments.p2sh({
      output: script,
      network,
    })
    if (addressObject.address) {
      return {
        addressObject,
        addressType: "p2sh",
      }
    }
  } catch (err) {
    /* empty */
  }

  try {
    addressObject = bitcoin.payments.p2wsh({
      output: script,
      network,
    })
    if (addressObject.address) {
      return {
        addressObject,
        addressType: "p2wsh",
      }
    }
  } catch (err) {
    /* empty */
  }

  try {
    addressObject = bitcoin.payments.p2tr({
      output: script,
      network,
    })
    if (addressObject.address) {
      return {
        addressObject,
        addressType: "p2tr",
      }
    }
  } catch (err) {
    /* empty */
  }
}

export function splitBuffer(buffer: Buffer, partLength: number) {
  const parts: Buffer[] = []
  for (let i = 0; i < buffer.length; i += partLength) {
    const part = buffer.subarray(i, i + partLength)
    parts.push(part)
  }
  return parts
}

export function getOrdinalScript(
  file: { buffer: Buffer; type: string },
  internalPublicKeyHex: string,
) {
  let bufferParts = splitBuffer(file.buffer, 520)
  const splittedFileHex = bufferParts.map((part) => part.toString("hex")).join(" ")
  const fileTypeHex = Buffer.from(file.type!, "utf8").toString("hex")
  const ORDINAL_ORD_HEX = Buffer.from("ord", "utf8").toString("hex")
  const script = `${internalPublicKeyHex} OP_CHECKSIG OP_FALSE OP_IF ${ORDINAL_ORD_HEX} 00000000000000000000 ${fileTypeHex} OP_0 ${splittedFileHex} OP_ENDIF`

  // we add 00000000000000000000 so we can modify INCORRECT OPCODE
  const leafScript = Buffer.from(
    bitcoin.script.fromASM(script).toString("hex").replace("0a00000000000000000000", "0101"),
    "hex",
  )
  return leafScript
}

export function toXOnly(pubKey: Buffer) {
  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33)
}
