import { teleswap } from "@teleportdao/configs"
import BigNumber from "bignumber.js"

type Vin = {
  address: string
  value: number
}

type Vout = {
  address?: string
  value: number
  script: string
}

export type WrapOpReturn = {
  chainId: number
  appId: number
  recipientAddress: string
  thirdPartyId: number
  networkFee: string
  speed: boolean
  //
  outputToken?: string
  outputAmount?: string
  bridgePercentageFee?: number
}

export type UnwrapInfo = {
  receivers: (Vout & {
    index: number
  })[]
  changes: (Vout & {
    index: number
  })[]
  totalInputValue: number
  lockerVin: {
    vinIndex: number
    address: string
    value: number
  }
}

export type WrapOpReturnWithType = WrapOpReturn & {
  requestType: "Wrap" | "WrapAndSwap"
}

// hex length -> 1 byte = 2
const wrapOpReturnLength = {
  chainId: 4,
  appId: 2,
  thirdPartyId: 2,
  networkFee: 6,
  bridgePercentageFee: 6,
  outputAmount: 28,
}

export function generateWrapOpReturn({
  chainId,
  appId,
  recipientAddress, // 20 bytes
  networkFee, // 2 bytes in percent %
  thirdPartyId = 0,
  speed = false, // 1 byte
  isExchange = false,
  outputToken, // 20 bytes
  outputAmount, // 28 bytes
  bridgePercentageFee = 0,
}: Omit<WrapOpReturn, "thirdPartyId"> & {
  thirdPartyId?: number
  isExchange?: boolean
}) {
  let data = ""
  if (BigNumber(chainId).toString(16).length > wrapOpReturnLength.chainId) {
    throw new Error("invalid chainId")
  }
  if (BigNumber(appId).toString(16).length > wrapOpReturnLength.appId) {
    throw new Error("invalid appId")
  }
  if (BigNumber(networkFee).toString(16).length > wrapOpReturnLength.networkFee) {
    throw new Error("invalid percentageFee")
  }
  if (BigNumber(thirdPartyId).toString(16).length > wrapOpReturnLength.thirdPartyId) {
    throw new Error("invalid percentageFee")
  }
  data += BigNumber(chainId).toString(16).padStart(wrapOpReturnLength.chainId, "0")
  data += BigNumber(appId).toString(16).padStart(wrapOpReturnLength.appId, "0")
  data += recipientAddress.replace("0x", "").toLowerCase().padStart(40, "0")
  data += BigNumber(networkFee).toString(16).padStart(wrapOpReturnLength.networkFee, "0")
  data += speed ? "01" : "00"
  data += BigNumber(thirdPartyId).toString(16).padStart(wrapOpReturnLength.thirdPartyId, "0")
  if (!isExchange) {
    if (data.length !== 28 * 2) throw new Error("invalid data length")
    return data
  }
  if (!outputToken) {
    throw new Error("invalid outputToken")
  }
  if (
    !outputAmount ||
    BigNumber(outputAmount).toString(16).length > wrapOpReturnLength.outputAmount
  ) {
    throw new Error("invalid outputAmount")
  }
  if (
    (bridgePercentageFee || 0) > 100 ||
    (bridgePercentageFee && bridgePercentageFee < 0.00001) ||
    BigNumber(bridgePercentageFee?.toFixed(5) || 0)
      .multipliedBy(1e5) // bridgePercentageFee is in %. 100 = 100% = 1e7
      .toString(16).length > wrapOpReturnLength.bridgePercentageFee
  ) {
    throw new Error("invalid percentageFee")
  }
  data += outputToken.replace("0x", "").toLowerCase().padStart(40, "0")
  data += BigNumber(outputAmount).toString(16).padStart(wrapOpReturnLength.outputAmount, "0")

  data += BigNumber(bridgePercentageFee?.toFixed(5) || 0)
    .multipliedBy(1e5)
    .toString(16)
    .padStart(wrapOpReturnLength.bridgePercentageFee, "0")
  if (data.length !== 65 * 2) throw new Error("invalid data length")
  return data
}

export function getBurnTransactionInfo(address: string, vin: Vin[] = [], vouts: Vout[] = []) {
  let lockerVinIndex = vin.findIndex((vi) => vi.address === address)
  if (lockerVinIndex >= 0) {
    let lockerVin = { ...vin[lockerVinIndex], vinIndex: lockerVinIndex }
    let totalInputValue = vin.reduce((acc, current) => acc + current.value, 0)
    let receivers: (Vout & {
      index: number
    })[] = []
    let changes: (Vout & {
      index: number
    })[] = []
    vouts.forEach((vout, i) => {
      let voutWithIndex = {
        ...vout,
        index: i,
      }
      if (voutWithIndex.address === address) {
        changes.push(voutWithIndex)
      } else {
        receivers.push(voutWithIndex)
      }
    })
    return { receivers, changes, totalInputValue, lockerVin }
  }
}

//

export function parseWrapRequest(data: string) {
  let parsedData: Partial<WrapOpReturnWithType> = {}
  parsedData.requestType = "Wrap"
  let offset = 0
  parsedData.chainId = BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.chainId))}`,
  ).toNumber() // 1 bytes
  parsedData.appId = BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.appId))}`,
  ).toNumber() // 2 bytes
  parsedData.recipientAddress = `0x${data.slice(offset, (offset += 40))}` // 20 bytes
  parsedData.networkFee = new BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.networkFee))}`,
  ).toFixed(0)
  parsedData.speed = data.slice(offset, (offset += 2)) === "01" // 1 byte
  parsedData.thirdPartyId = new BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.thirdPartyId))}`,
  ).toNumber()
  if (data.length === offset) {
    return {
      status: true,
      data: parsedData as WrapOpReturnWithType,
    }
  }

  parsedData.requestType = "WrapAndSwap"
  parsedData.outputToken = `0x${data.slice(offset, (offset += 40))}` // 20 bytes
  parsedData.outputAmount = new BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.outputAmount))}`,
  ).toFixed(0) // 28 bytes
  parsedData.bridgePercentageFee = new BigNumber(
    `0x${data.slice(offset, (offset += wrapOpReturnLength.bridgePercentageFee))}`,
  )
    .dividedBy(1e5)
    .toNumber()

  if (parsedData.bridgePercentageFee > 100) {
    return {
      status: false,
      message: `invalid OP_RETURN data for requestType: 'wrap or wrapAndSwap'. invalid bridgePercentageFee`,
      code: "INVALID_OP_RETURN",
    }
  }
  if (data.length === offset) {
    return {
      status: true,
      data: parsedData as WrapOpReturnWithType,
    }
  }

  return {
    status: false,
    message: `invalid OP_RETURN data for requestType: 'wrap or wrapAndSwap'. invalid data length : ${data.length} - valid length : ${offset}`,
    code: "INVALID_OP_RETURN",
  }
}

export function parseWrapRawRequest(opReturnData: string) {
  let data = opReturnData.slice(2, 4) === "4c" ? opReturnData.slice(6) : opReturnData.slice(4)

  let appIdHex = data.slice(
    wrapOpReturnLength.chainId,
    wrapOpReturnLength.chainId + wrapOpReturnLength.appId,
  )

  if (!appIdHex) {
    return {
      status: false,
      message: `invalid OP_RETURN data : ${data}`,
      code: "INVALID_APP_ID",
    }
  }

  let appId = BigNumber(`0x${appIdHex}`).toNumber() // 2 bytes

  //   get type base on appId
  let requestType = Object.keys(teleswap.requestAppId).find((key) =>
    teleswap.requestAppId[key as keyof typeof teleswap.requestAppId].appIds.includes(appId),
  )

  switch (requestType) {
    case "Wrap":
    case "WrapAndSwap":
      return parseWrapRequest(data)
    default:
      return {
        status: false,
        message: `invalid appId : ${appId}`,
        code: "INVALID_OP_RETURN",
      }
  }
}

export function checkAndParseWrapRequest(vouts: Vout[], lockerAddress: string) {
  let requestOutputIndex = vouts.findIndex((vout_) => vout_.script.startsWith("6a"))
  if (requestOutputIndex >= 0) {
    let opReturnData = vouts[requestOutputIndex]?.script || null
    if (!opReturnData) {
      return {
        status: false,
        message: "no data to validate. it should not happen",
        code: "INVALID_OP_RETURN",
      }
    }

    let valueOutputIndex = vouts.findIndex((vout_) => vout_.address === lockerAddress)
    let value = valueOutputIndex >= 0 ? vouts[valueOutputIndex].value || 0 : 0

    let response = parseWrapRawRequest(opReturnData)

    if (!response.status || !("data" in response) || !response.data) {
      return response as {
        status: boolean
        message: string
        code: string
      }
    }

    return {
      status: response.status,
      data: response.data,
      value,
      valueOutputIndex,
      requestOutputIndex,
    }
  }
  return {
    status: false,
    message: "transaction outputs must include an OP_RETURN",
    code: "NO_OP_RETURN",
  }
}
