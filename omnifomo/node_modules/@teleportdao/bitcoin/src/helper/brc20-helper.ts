import BigNumber from "bignumber.js"
import { brc20 } from "@teleportdao/configs"

export type WrapOpReturn = {
  chainId: number
  appId: number
  brc20TokenId: number
  recipientAddress: string
  inputAmount: string
  outputAmount?: string
  outputToken?: string
  thirdPartyId?: number
}
export type WrapOpReturnAndType = WrapOpReturn & {
  requestType: "Wrap" | "WrapAndSwap"
}

const brc20WrapRequests = brc20.requestAppId

export function generateBrc2OpReturn({
  chainId,
  appId,
  brc20TokenId,
  inputAmount,
  recipientAddress,
  thirdPartyId = 0,
  isExchange = false,
  outputToken,
  outputAmount,
}: WrapOpReturn & {
  isExchange?: boolean
}) {
  let data = ""
  if (chainId.toString(16).length > 4) throw new Error("chainId should be less than 2 bytes")
  data += chainId.toString(16).padStart(4, "0") // 2 bytes
  data += appId.toString(16).padStart(2, "0") // 1 bytes
  data += brc20TokenId.toString(16).padStart(4, "0") // 2 bytes
  data += BigNumber(inputAmount).toString(16).padStart(26, "0") // 13 bytes
  data += recipientAddress.replace("0x", "").toLowerCase().padStart(40, "0") // 20 bytes
  data += BigNumber(thirdPartyId).toString(16).padStart(2, "0") // 1 bytes
  if (isExchange) {
    if (!outputAmount || !outputToken) {
      throw new Error("outputAmount and outputToken are required for exchange")
    }
    data += outputToken.replace("0x", "").toLowerCase().padStart(40, "0") // 20 bytes
    data += BigNumber(outputAmount).toString(16).padStart(26, "0") // 13 bytes
  }
  return data
}

export function parseBrc20OpReturn(data: string) {
  let parsedData: Partial<WrapOpReturnAndType> = {}
  parsedData.chainId = Number(`0x${data.slice(0, 4)}`) // 2 bytes
  parsedData.appId = Number(`0x${data.slice(4, 6)}`) // 1 bytes
  parsedData.brc20TokenId = Number(`0x${data.slice(6, 10)}`) // 2 bytes
  parsedData.inputAmount = new BigNumber(`0x${data.slice(10, 36)}`).toFixed(0) // 11 bytes
  parsedData.recipientAddress = `0x${data.slice(36, 76)}` // 20 bytes
  parsedData.thirdPartyId = Number(`0x${data.slice(76, 78)}`) // 20 bytes
  if (data.length === 78) {
    parsedData.requestType = "Wrap"
    return {
      status: true,
      data: parsedData as WrapOpReturnAndType,
    }
  }
  parsedData.outputToken = `0x${data.slice(78, 118)}` // 20 bytes
  parsedData.outputAmount = new BigNumber(`0x${data.slice(118, 144)}`).toFixed(0) // 20 bytes
  if (data.length === 144) {
    parsedData.requestType = "WrapAndSwap"
    return {
      status: true,
      data: parsedData as WrapOpReturnAndType,
    }
  }

  return {
    status: false,
    message: `invalid OP_RETURN data for requestType: 'wrap or exchange'. invalid data length : ${data.length} - valid length : 144 , 78`,
    code: "INVALID_OP_RETURN",
  }
}

function parseBrc20RawRequest(opReturnData: string): {
  status: boolean
  data?: WrapOpReturnAndType
  message?: string
  code?: string
} {
  let data = opReturnData.slice(2, 4) === "4c" ? opReturnData.slice(6) : opReturnData.slice(4)
  // eslint-disable-next-line no-unused-vars
  let appIdHex = data.slice(4, 6) // 2 bytes
  if (!appIdHex) {
    return {
      status: false,
      message: `invalid OP_RETURN data : ${data}`,
      code: "INVALID_APP_ID",
    }
  }

  let appId = Number(`0x${appIdHex}`) // 2 bytes

  //   get type base on appId
  let requestType = Object.keys(brc20WrapRequests).find((key) =>
    brc20WrapRequests[key as keyof typeof brc20WrapRequests].appIds.includes(appId),
  )

  switch (requestType) {
    case "Wrap":
    case "WrapAndSwap":
      return parseBrc20OpReturn(data)
    default:
      return {
        status: false,
        message: `invalid appId : ${appId}`,
        code: "INVALID_OP_RETURN",
      }
  }
}

export function checkAndParseBrc20Request(
  vouts: {
    address?: string
    script: string
    value: number
  }[],
  address: string,
): {
  status: boolean
  data?: WrapOpReturnAndType
  dataOutputIndex?: number
  lockerFeeValue?: number
  lockerFeeOutputIndex?: number
  brc20OutputIndex?: number
  brc20OutputValue?: number
  message?: string
  code?: string
} {
  let requestOutputIndex = vouts.findIndex((vout_) => vout_.script.startsWith("6a"))
  if (requestOutputIndex >= 0) {
    let opReturnData = vouts[requestOutputIndex]?.script
    if (!opReturnData) {
      return {
        status: false,
        message: "invalid OP_RETURN",
        code: "INVALID_OP_RETURN",
      }
    }

    let brc20Transfer = vouts[0]
    if (brc20Transfer.address !== address || brc20Transfer.value < 546) {
      return {
        status: false,
        message: "no brc20 transfer output",
        code: "NO_BRC20_TRANSFER",
      }
    }

    let dataResponse = parseBrc20RawRequest(opReturnData)
    if (dataResponse.status) {
      let lockerFeeOutputIndex = vouts.findIndex((vout_, i) => vout_.address === address && +i > 0)
      let lockerFeeValue = lockerFeeOutputIndex >= 0 ? vouts[lockerFeeOutputIndex].value : 0
      return {
        status: true,
        data: dataResponse.data!,
        dataOutputIndex: requestOutputIndex,
        lockerFeeValue,
        lockerFeeOutputIndex,
        brc20OutputIndex: 0,
        brc20OutputValue: brc20Transfer.value,
      }
    }
    return dataResponse
  }
  return {
    status: false,
    message: "transaction outputs should contain OP_RETURN",
    code: "NO_OP_RETURN",
  }
}
