import { bitcoin as bitcoinProvider } from "@teleportdao/providers"
import { BitcoinInterfaceUtils } from "./bitcoin-interface-utils"
import type { BitcoinConnectionInfo } from "./type"
import type { SignerInfo } from "./transaction-builder/transaction-builder"

export class BitcoinInterfaceWallet extends BitcoinInterfaceUtils {
  utxoProvider: bitcoinProvider.Types.UtxoProvider
  apiProvider: bitcoinProvider.MempoolSpace
  rpcProvider?: bitcoinProvider.BitcoinRPC
  constructor(networkName: string, connectionInfo?: BitcoinConnectionInfo) {
    super(networkName)
    if (connectionInfo?.api?.provider === "BlockStream") {
      this.apiProvider = new bitcoinProvider.BlockStream(this.testnet)
    } else {
      this.apiProvider = new bitcoinProvider.MempoolSpace(this.testnet)
    }

    this.utxoProvider = connectionInfo?.utxo
      ? bitcoinProvider.getUtxoProvider(connectionInfo.utxo, networkName)!
      : this.apiProvider

    // only for send tx
    if (connectionInfo?.rpc) this.rpcProvider = bitcoinProvider.getRpcProvider(connectionInfo?.rpc)
  }

  async getFeeRate(speed?: "normal" | "slow" | "fast") {
    return this.apiProvider.getRecommendedFeeRate(speed)
  }

  async getUtxo(address: string) {
    return this.utxoProvider.getUtxos(address)
  }

  async getExtendedUtxo(signerInfo: SignerInfo) {
    let utxos = await this.getUtxo(signerInfo.address)
    return utxos.map((tx) => ({
      hash: tx.txId,
      value: tx.value,
      index: tx.index,
      signerInfo,
    }))
  }

  async getAddressesUtxo(allAddresses: string[]) {
    const chunkOfAddresses = []
    const chunkLength = 20
    for (let i = 0; i < allAddresses.length; i += chunkLength) {
      const tmp = allAddresses.slice(i, i + chunkLength)
      chunkOfAddresses.push(tmp)
    }

    let results = []

    for (let addresses of chunkOfAddresses) {
      const allPromises = []
      for (let address of addresses) {
        let promise = await this.getUtxo(address)
        allPromises.push(promise)
      }
      let result = await Promise.all(allPromises)
      if (result.flat(1).length === 0) {
        break
      }
      results.push(result.flat(1))
    }
    return results.flat(1)
  }

  async getAddressesExtendedUtxo(signerInfos: SignerInfo[]) {
    const chunkOfAddresses = []
    const chunkLength = 20
    for (let i = 0; i < signerInfos.length; i += chunkLength) {
      const tmp = signerInfos.slice(i, i + chunkLength)
      chunkOfAddresses.push(tmp)
    }

    let results = []

    for (let addresses of chunkOfAddresses) {
      const allPromises = []
      for (let signerInfo of addresses) {
        let promise = await this.getExtendedUtxo(signerInfo)
        allPromises.push(promise)
      }
      let result = await Promise.all(allPromises)
      if (result.flat(1).length === 0) {
        break
      }
      results.push(result.flat(1))
    }
    return results.flat(1)
  }

  async getBalance(address: string) {
    let utxos = await this.utxoProvider.getUtxos(address)
    return utxos.reduce((a, tx) => a + Number(tx.value), 0)
  }

  async getRawTransaction(txId: string) {
    if (this.rpcProvider) return this.rpcProvider.getRawTransaction(txId)
    if (this.utxoProvider.getRawTransaction) return this.utxoProvider.getRawTransaction(txId)
    return this.apiProvider.getRawTransaction(txId)
  }

  async sendRawTransaction(txHex: string) {
    if (this.rpcProvider) return this.rpcProvider.sendRawTransaction(txHex)
    if (this.utxoProvider.sendRawTransaction) return this.utxoProvider.sendRawTransaction(txHex)
    return this.apiProvider.sendRawTransaction(txHex)
  }
}

export default BitcoinInterfaceWallet
