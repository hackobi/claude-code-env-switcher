import { bitcoin } from "@teleportdao/providers"
import { teleswap } from "@teleportdao/configs"
import { parseBlockHeader } from "./bitcoin-utils"
import {
  checkAndParseWrapRequest,
  // getBurnTransactionInfo,
  UnwrapInfo,
  WrapOpReturnWithType,
} from "./helper/teleswap-helper"
import BitcoinInterface from "./bitcoin-interface"
import { BitcoinNodeConnectionInfo, Transaction } from "./type"

export type ValidWrapRequest = {
  transaction: bitcoin.Types.ConfirmedTransaction & {
    address?: string
    addressScript?: string
    merkleProof?: Transaction["merkleProof"]
  }
  request: {
    status: boolean
    data: WrapOpReturnWithType
    value: number
    valueOutputIndex: number
  }
  lockerAddress: string
  lockerLockingScript: string
}

export type InValidWrapRequest = {
  transaction: bitcoin.Types.ConfirmedTransaction & {
    address?: string
    addressScript?: string
    merkleProof?: Transaction["merkleProof"]
  }
  request: {
    status: boolean
    message: string
    code: string
  }
  lockerAddress: string
  lockerLockingScript: string
}

export type UnwrapRequest = {
  burnInfo: UnwrapInfo | undefined
  lockerAddress: string
  lockerLockingScript: string
}

export class BitcoinInterfaceTeleswap extends BitcoinInterface {
  constructor(connectionInfo: BitcoinNodeConnectionInfo, networkName: string) {
    if (!connectionInfo.rpc) {
      throw new Error("rpc provider is required")
    }
    super(networkName, connectionInfo)
  }
  // relayer
  async getHexBlockHeaders(startBlockNumber: number, endBlockNumber: number) {
    const blockHeaders = []
    let difficulty = null
    let hexBlockHeaders = ""

    let fromBlockNumber = startBlockNumber
    for (let blockNumber = startBlockNumber; blockNumber <= endBlockNumber; blockNumber += 1) {
      let blockHeader = await this.getBlockHeaderHex(blockNumber)
      console.log("block", blockNumber)
      let parsedBlockHeader = parseBlockHeader(blockHeader)
      if (difficulty && parsedBlockHeader.difficulty !== difficulty) {
        blockHeaders.push({
          hexBlockHeaders,
          fromBlockNumber,
          toBlockNumber: blockNumber - 1,
          difficulty,
        })
        hexBlockHeaders = blockHeader
        fromBlockNumber = blockNumber
      } else {
        hexBlockHeaders += blockHeader
      }
      difficulty = parsedBlockHeader.difficulty
    }
    if (hexBlockHeaders) {
      blockHeaders.push({
        hexBlockHeaders,
        fromBlockNumber,
        toBlockNumber: endBlockNumber,
        difficulty,
      })
    }

    return blockHeaders
  }

  async getWrapRequests(addresses: string[], startblockNumber: number, endBlockNumber: number) {
    // transaction in StartBlock is not returned --> (startblockNumber,endBlockNumber]
    let transactions = await this.getMultipleBlocksTransactions(
      addresses,
      startblockNumber,
      endBlockNumber,
    )

    let requests: ValidWrapRequest[] = []
    let invalidRequests: InValidWrapRequest[] = []

    for (let inputTx of transactions) {
      let { transaction, request, lockerAddress, lockerLockingScript } =
        await this.getWrapRequestByTx(inputTx, inputTx.address)
      if (request.status && "data" in request && request.data) {
        if (!teleswap.requestAppId[request.data.requestType].appIds.includes(request.data.appId)) {
          invalidRequests.push({
            transaction,
            request: {
              ...request,
              message: "invalid app id",
              code: "INVALID_APP_ID",
            },
            lockerAddress,
            lockerLockingScript,
          })
        } else {
          requests.push({
            transaction,
            request,
            lockerAddress,
            lockerLockingScript,
          })
        }
      } else if (request.code !== "NO_OP_RETURN") {
        invalidRequests.push({ transaction, request, lockerAddress, lockerLockingScript })
      }
    }
    return { requests, invalidRequests }
  }

  async getWrapRequestByTx(
    inputTransaction:
      | { txId: string }
      | (bitcoin.Types.ConfirmedTransaction & {
          address?: string
          addressScript?: string
          merkleProof?: Transaction["merkleProof"]
        }),
    lockerAddress: string,
  ) {
    let transaction: bitcoin.Types.ConfirmedTransaction & {
      address?: string
      addressScript?: string
      merkleProof?: Transaction["merkleProof"]
    }
    if ("vout" in inputTransaction && "blockNumber" in inputTransaction) {
      transaction = inputTransaction
    } else {
      if (!inputTransaction.txId) throw new Error("txId not exist")
      transaction = await this.getTransaction(inputTransaction.txId)
    }

    let vout = transaction.vout
    let request = checkAndParseWrapRequest(vout!, lockerAddress)
    let lockerLockingScript: string =
      transaction.addressScript ||
      this.convertAddressToScript(lockerAddress).script!.toString("hex")

    return {
      transaction,
      request,
      lockerAddress,
      lockerLockingScript,
    }
  }

  // async getLockersUnWrapTransactions(
  //   addresses: string[],
  //   startBlockNumber: number,
  //   endBlockNumber: number,
  // ) {
  //   let transactions = await this.getMultipleBlocksTransactions(
  //     addresses,
  //     startBlockNumber,
  //     endBlockNumber,
  //   )

  //   let validTxs = []
  //   for (let transaction of transactions) {
  //     let address = transaction.address
  //     // check if its a transaction to spend btc
  //     let txBurnInfo = await this.getTransactionUnwrapInfoByTx(transaction, address)
  //     if (txBurnInfo) {
  //       const { burnInfo, lockerAddress, lockerLockingScript } = txBurnInfo
  //       validTxs.push({
  //         transaction,
  //         burnInfo,
  //         lockerAddress,
  //         lockerLockingScript,
  //       })
  //     }
  //   }
  //   return validTxs
  // }

  // async getLockersUnwrapMEmpoolTransactions(
  //   addresses: string[],
  //   startBlockNumber: number,
  //   endBlockNumber: number,
  // ) {
  //   let transactions = await this.getMultipleBlocksTransactions(
  //     addresses,
  //     startBlockNumber,
  //     endBlockNumber,
  //   )

  //   let validTxs = []
  //   for (let transaction of transactions) {
  //     let address = transaction.address
  //     // check if its a transaction to spend btc
  //     let txBurnInfo = await this.getTransactionUnwrapInfoByTx(transaction, address)
  //     if (txBurnInfo) {
  //       const { burnInfo, lockerAddress, lockerLockingScript } = txBurnInfo
  //       validTxs.push({
  //         transaction,
  //         burnInfo,
  //         lockerAddress,
  //         lockerLockingScript,
  //       })
  //     }
  //   }
  //   return validTxs
  // }

  // async getTransactionUnwrapInfoByTx(
  //   transaction: ConfirmedTransaction,
  //   lockerAddress: string,
  // ) {
  //   if (!transaction.txId) throw new Error("txId not exist")
  //   let vin = transaction.vin || (await this.getTransaction(transaction.txId)).vin
  //   let burnInfo = getBurnTransactionInfo(lockerAddress, vin, transaction.vout)
  //   if (!burnInfo) return null
  //   let lockerLockingScript: string =
  //     transaction.addressScript ||
  //     this.convertAddressToScript(lockerAddress).script!.toString("hex")
  //   return {
  //     burnInfo,
  //     lockerAddress,
  //     lockerLockingScript,
  //   } as UnwrapRequest
  // }
}
