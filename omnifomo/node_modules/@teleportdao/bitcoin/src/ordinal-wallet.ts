import BigNumber from "bignumber.js"
import { bitcoin as bitcoinProviders } from "@teleportdao/providers"
import { OrdinalTransactionBuilder } from "./transaction-builder/ordinal-transaction-builder"
import BitcoinSign from "./sign/sign-transaction"
//
import { BitcoinInterfaceOrdinal } from "./bitcoin-interface-ordinal"
import { generateBrc2OpReturn } from "./helper/brc20-helper"
import { sleep } from "./utils/tools"
import { ChangeTarget, ExtendedUtxo, SignerInfo, Target } from "./transaction-builder"
import { BitcoinBaseWallet, FeeRateType } from "./bitcoin-wallet-base"
import { BitcoinTokenNodeConnectionInfo } from "./type"

class OrdinalWallet extends BitcoinBaseWallet {
  unisat: bitcoinProviders.UniSat
  transactionBuilder: OrdinalTransactionBuilder
  btcInterface: BitcoinInterfaceOrdinal
  signer: BitcoinSign
  constructor(
    networkName: string,
    uniSatToken: string,
    connectionInfo: BitcoinTokenNodeConnectionInfo,
  ) {
    if (!connectionInfo.rpc) {
      // because api providers usually don't support sending custom psbt include p2tr address so we need rpc provider
      throw new Error("rpc is required")
    }
    super(networkName, connectionInfo)

    this.transactionBuilder = new OrdinalTransactionBuilder(
      networkName,
      this.network,
      connectionInfo,
    )
    this.signer = new BitcoinSign(this.network)
    this.btcInterface = new BitcoinInterfaceOrdinal(connectionInfo, networkName, uniSatToken)
    this.unisat = this.btcInterface.unisat
  }

  static deployBRC20Data(tickName: string, max: number | string, limit: number | string) {
    let data = {
      p: "brc-20",
      op: "deploy",
      tick: tickName,
      max: `${max}`,
      lim: `${limit}`,
    }
    return {
      buffer: Buffer.from(JSON.stringify(data), "utf8"),
      type: "text/plain",
      // type: "application/json",
    }
  }

  static mintBRC20Data(tickName: string, amount: string | number) {
    if (BigNumber(amount).isLessThanOrEqualTo(0)) throw new Error("amount should be greater than 0")
    let data = {
      p: "brc-20",
      op: "mint",
      tick: tickName,
      amt: `${amount}`,
    }
    return {
      buffer: Buffer.from(JSON.stringify(data), "utf8"),
      type: "text/plain",
      // type: "application/json",
    }
  }

  static transferBRC20Data(tickName: string, amount: string | number) {
    if (BigNumber(amount).isLessThanOrEqualTo(0)) throw new Error("amount should be greater than 0")
    let data = {
      p: "brc-20",
      op: "transfer",
      tick: tickName,
      amt: `${amount}`,
    }
    return {
      buffer: Buffer.from(JSON.stringify(data), "utf8"),
      type: "text/plain",
      // type: "application/json",
    }
  }

  async inscribeOrdinalDepositUnsigned(
    file: {
      buffer: Buffer
      type: string
    },
    signer: SignerInfo,
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    const ordinalSignerPublicKey = ordinalSigner?.publicKey || signer.publicKey
    const publicKey = Buffer.from(ordinalSignerPublicKey, "hex")
    let transferOrdinal = this.transactionBuilder.createOrdinalAddress(file, publicKey)
    const leafScript = transferOrdinal.redeem.output
    const { ordinalAddress } = transferOrdinal

    let feeRate = await this.getFeeRate(fee)
    let extraFee = +(((400 + leafScript.length) / 4) * feeRate * 1.5).toFixed(0)
    let ordinalAmount = 600

    let utxo1: ExtendedUtxo[] =
      extendedUtxo || (await this.btcInterface.getBTCUtxo(signer.address, signer))

    let inscribeDepositUnsignedInfo = await this.sendBTCUnsignedTx(
      ordinalAddress,
      ordinalAmount + extraFee,
      signer,
      feeRate,
      utxo1,
    )

    return {
      inscribeDepositUnsignedInfo,
      transferOrdinal,
    }
  }

  async inscribeOrdinalUnsigned(
    file: {
      buffer: Buffer
      type: string
    },
    signer: SignerInfo,
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    const receiverAddress = ordinalSigner?.address || signer.address
    const { inscribeDepositUnsignedInfo, transferOrdinal } =
      await this.inscribeOrdinalDepositUnsigned(file, signer, ordinalSigner, fee, extendedUtxo)
    const { ordinalAddress } = transferOrdinal
    let ordinalAmount = 600

    if (!inscribeDepositUnsignedInfo.possibleTxId)
      throw new Error(
        "inscribeDepositUnsignedInfo.possibleTxId is required. inscriber address type is not p2tr",
      )

    let inscribeDeposit: {
      hash: string
      value: number
      index: number
    } = {
      hash: inscribeDepositUnsignedInfo.possibleTxId,
      value: inscribeDepositUnsignedInfo.outputs[0].value,
      index: 0,
    }
    let inscribeUnsignedInfo = this.transactionBuilder.createInscribeUnsignedTx(
      transferOrdinal,
      inscribeDeposit,
      receiverAddress,
      ordinalAmount,
    )
    return {
      inscribeDepositUnsignedInfo,
      inscribeUnsignedInfo,
      inscribeAddress: ordinalAddress,
      receiverAddress,
    }
  }

  async inscribeOrdinal(
    file: {
      buffer: Buffer
      type: string
    },
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
    ordinalReceiverAddress?: string,
  ) {
    if (!this.currentAccount || !this.currentAccountType || !this.publicKey || !this.privateKey) {
      throw new Error("account not initialized")
    }
    const receiverAddress = ordinalReceiverAddress || this.bitcoinAddress!

    const { inscribeDepositUnsignedInfo, transferOrdinal } =
      await this.inscribeOrdinalDepositUnsigned(
        file,
        this.signerInfo!,
        undefined,
        fee,
        extendedUtxo,
      )
    let ordinalUtxo = await this.btcInterface.getBTCUtxo(
      transferOrdinal.ordinalAddress,
      this.signerInfo!,
    )

    let inscribeDeposit: {
      inputs: {
        hash: string
        value: number
        index: number
        signerInfo: SignerInfo
      }[]
      hash: string
      value: number
      index: number
      change?: ChangeTarget
      changeIndex?: number
    }

    if (ordinalUtxo.length > 1) {
      throw new Error("multiple deposit found for this ordinal address")
    }

    if (
      ordinalUtxo.length === 0 ||
      ordinalUtxo[0].value <
        inscribeDepositUnsignedInfo.outputs[0].value -
          inscribeDepositUnsignedInfo.outputs[0].value * 0.15
    ) {
      const signedPsbt1 = await this.signer.signPsbt(inscribeDepositUnsignedInfo, this.privateKey!)
      console.log("inscribe deposit tx ...")
      const inscribeDepositTxId = await this.sendSignedPsbt(signedPsbt1)
      console.log(`inscribe deposit txId : ${inscribeDepositTxId}`)

      inscribeDeposit = {
        hash: inscribeDepositTxId,
        value: inscribeDepositUnsignedInfo.outputs[0].value,
        index: 0,
        inputs: inscribeDepositUnsignedInfo.inputs,
        change: inscribeDepositUnsignedInfo.change,
        changeIndex: inscribeDepositUnsignedInfo.change
          ? inscribeDepositUnsignedInfo.outputs.length
          : undefined,
      }
    } else {
      inscribeDeposit = {
        hash: ordinalUtxo[0].hash,
        value: ordinalUtxo[0].value,
        index: ordinalUtxo[0].index,
        inputs: [],
      }
      console.log("no need to deposit", inscribeDeposit)
    }

    const ordinalAmount = 600
    let inscribeUnsignedInfo = this.transactionBuilder.createInscribeUnsignedTx(
      transferOrdinal,
      inscribeDeposit,
      receiverAddress,
      ordinalAmount,
    )

    const signedPsbt2 = await this.signer.signPsbt(
      inscribeUnsignedInfo,
      this.privateKey!,
      undefined,
      false,
    )

    console.log("inscribeTxId ...")
    await sleep(10 * 1000)
    let inscribeTxId = await this.sendSignedPsbtWithRetry(signedPsbt2)
    console.log("inscribeTxId", inscribeTxId)
    return {
      inscribeTx: { hash: inscribeTxId, index: 0, value: ordinalAmount },
      inscribeDepositTx: inscribeDeposit,
      inscribeAddress: transferOrdinal.ordinalAddress,
    }
  }

  async deployBrc20(
    brc: { tick: string; max: number; limit: number },
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    let file = OrdinalWallet.deployBRC20Data(brc.tick, brc.max, brc.limit)
    return this.inscribeOrdinal(file, fee, extendedUtxo)
  }

  async mintBrc20(
    brc: { tick: string; amount: number | string },
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    let file = OrdinalWallet.mintBRC20Data(brc.tick, brc.amount)
    return this.inscribeOrdinal(file, fee, extendedUtxo)
  }

  async inscribeBrc20Unsigned(
    brc: { tick: string; amount: number | string },
    signer: SignerInfo,
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    let file = OrdinalWallet.transferBRC20Data(brc.tick, brc.amount)
    return this.inscribeOrdinalUnsigned(file, signer, ordinalSigner, fee, extendedUtxo)
  }

  async inscribeBrc20(
    brc: { tick: string; amount: number | string },
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    let file = OrdinalWallet.transferBRC20Data(brc.tick, brc.amount)
    return this.inscribeOrdinal(file, fee, extendedUtxo)
  }

  async transferBrc20Unsigned(
    receiver: string,
    brcInscribeUtxo: {
      hash: string
      value: number
      index: number
    },
    signer: SignerInfo,
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
    otherTargets?: Target[],
  ) {
    const ordinalSignerInfo = ordinalSigner || signer
    let utxo = extendedUtxo || (await this.btcInterface.getBTCUtxo(signer.address, signer))
    let feeRate = await this.getFeeRate(fee)
    let unsignedTx = await this.transactionBuilder.createNftPsbt({
      extendedUtxo: utxo,
      nftExtendedUtxo: {
        hash: brcInscribeUtxo.hash,
        index: 0,
        value: brcInscribeUtxo.value,
        signerInfo: ordinalSignerInfo,
      },
      feeRate,
      receiverAddress: receiver,
      changeAddress: signer.address,
      otherTargets,
    })
    return {
      ...unsignedTx,
      possibleTxId: this.transactionBuilder.getUnsignedPsbtTxId(unsignedTx.unsignedTransaction),
    }
  }

  async transferBrc20(
    receiver: string,
    brcInscribeUtxo: {
      hash: string
      value: number
      index: number
    },
    fee: FeeRateType = "normal",
    extendedUtxo: ExtendedUtxo[],
    otherTargets?: Target[],
  ) {
    if (!this.currentAccount || !this.currentAccountType || !this.publicKey || !this.privateKey) {
      throw new Error("account not initialized")
    }
    let feeRate = await this.getFeeRate(fee)
    let unsignedTx = await this.transactionBuilder.createNftPsbt({
      extendedUtxo,
      nftExtendedUtxo: {
        hash: brcInscribeUtxo.hash,
        index: 0,
        value: brcInscribeUtxo.value,
        signerInfo: this.signerInfo!,
      },
      feeRate,
      receiverAddress: receiver,
      changeAddress: this.bitcoinAddress!,
      otherTargets,
    })

    let signedTx = await this.signer.signPsbt(unsignedTx, this.privateKey!)
    let finalTransferTxId = await this.sendSignedPsbtWithRetry(signedTx)
    return {
      hash: finalTransferTxId,
      index: 0,
      value: brcInscribeUtxo.value,
      inputs: unsignedTx.inputs,
      change: unsignedTx.change,
      changeIndex: unsignedTx.change ? unsignedTx.outputs.length : undefined,
    }
  }

  async inscribeAndTransferBrc20Unsigned(
    receiver: string,
    brc: { tick: string; amount: number | string },
    signer: SignerInfo,
    ordinalSigner?: SignerInfo,
    otherTargets?: Target[],
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    const ordinalSignerInfo = ordinalSigner || signer
    // check all fee before process transaction
    let brc20Balance = await this.unisat.getBrc20AddressBalanceForTicker(signer.address, brc.tick)

    if (BigNumber(brc20Balance.transferableBalance).gte(brc.amount)) {
      let transferrableInscription = brc20Balance.transferableInscriptions.find(
        (insc) => insc.data.tick === brc.tick && BigNumber(insc.data.amt).isEqualTo(brc.amount),
      )

      console.log("transferrableInscription", transferrableInscription)
    }

    if (BigNumber(brc20Balance.availableBalanceSafe).isLessThan(brc.amount)) {
      throw new Error("insufficient balance")
    }

    let feeRate = await this.getFeeRate(fee)

    let utxo1: ExtendedUtxo[] =
      extendedUtxo || (await this.btcInterface.getBTCUtxo(signer.address, signer))
    let utxo2: ExtendedUtxo[] = []
    const { inscribeAddress, inscribeDepositUnsignedInfo, inscribeUnsignedInfo } =
      await this.inscribeBrc20Unsigned(brc, signer, ordinalSignerInfo, feeRate, utxo1)

    utxo2 = utxo1.filter(
      (u) =>
        inscribeDepositUnsignedInfo.inputs.findIndex(
          (i) => i.hash === u.hash && i.index === u.index,
        ) === -1,
    )

    if (inscribeDepositUnsignedInfo.change) {
      if (!inscribeDepositUnsignedInfo.possibleTxId) {
        throw new Error("inscribeDepositUnsignedInfo.possibleTxId is required")
      }
      utxo2.push({
        hash: inscribeDepositUnsignedInfo.possibleTxId,
        index: inscribeDepositUnsignedInfo.outputs.length,
        value: inscribeDepositUnsignedInfo.change.value,
        signerInfo: signer,
      })
    }
    let transferTxUnsignedInfo = await this.transferBrc20Unsigned(
      receiver,
      {
        hash: inscribeUnsignedInfo.possibleTxId,
        value: inscribeUnsignedInfo.outputs[0].value,
        index: 0,
      },
      signer,
      ordinalSignerInfo,
      feeRate,
      utxo2,
      otherTargets,
    )
    return {
      inscribeDepositUnsignedInfo,
      inscribeUnsignedInfo,
      transferTxUnsignedInfo,
      inscribeAddress,
    }
  }

  async inscribeAndTransferBrc20(
    receiver: string,
    brc: { tick: string; amount: number | string },
    otherTargets?: Target[],
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],
  ) {
    // check all fee before process transaction
    let brc20Balance = await this.unisat.getBrc20AddressBalanceForTicker(
      this.bitcoinAddress!,
      brc.tick,
    )

    if (BigNumber(brc20Balance.transferableBalance).gte(brc.amount)) {
      let transferrableInscription = brc20Balance.transferableInscriptions.find(
        (insc) => insc.data.tick === brc.tick && BigNumber(insc.data.amt).isEqualTo(brc.amount),
      )
      console.log("transferrableInscription", transferrableInscription)

      if (transferrableInscription) {
        let ins = await this.btcInterface.unisat.getInscriptionInfo(
          transferrableInscription.inscriptionId,
        )

        if (ins) {
          let transferTx = await this.transferBrc20(
            receiver,
            {
              hash: ins.utxo.txid!,
              index: ins.utxo.vout!,
              value: ins.utxo.satoshi!,
            },
            await this.getFeeRate(fee),
            extendedUtxo ||
              (await this.btcInterface.getBTCUtxo(this.bitcoinAddress!, this.signerInfo!)),
            otherTargets,
          )
          return {
            transferTx,
          }
        }
      }
    }

    if (BigNumber(brc20Balance.availableBalanceSafe).isLessThan(brc.amount)) {
      throw new Error(`insufficient balance ${brc20Balance.availableBalanceSafe} ${brc.amount}`)
    }

    let feeRate = await this.getFeeRate(fee)

    let utxo1: ExtendedUtxo[] =
      extendedUtxo || (await this.btcInterface.getBTCUtxo(this.bitcoinAddress!, this.signerInfo!))
    let utxo2: ExtendedUtxo[] = []
    const { inscribeAddress, inscribeDepositTx, inscribeTx } = await this.inscribeBrc20(
      brc,
      feeRate,
      utxo1,
    )

    utxo2 = utxo1.filter(
      (u) =>
        inscribeDepositTx.inputs.findIndex((i) => i.hash === u.hash && i.index === u.index) === -1,
    )

    if (inscribeDepositTx.change) {
      utxo2.push({
        hash: inscribeDepositTx.hash,
        index: inscribeDepositTx.changeIndex!,
        value: inscribeDepositTx.change.value,
        signerInfo: this.signerInfo!,
      })
    }
    await sleep(10 * 1000)
    let transferTx = await this.transferBrc20(receiver, inscribeTx, feeRate, utxo2, otherTargets)
    return {
      inscribeTx,
      inscribeAddress,
      inscribeDepositTx,
      transferTx,
    }
  }

  async wrapBrc20Unsigned(
    recipientAddress: string,
    brc: { tick: string; amount: number | string },
    brc20TokenId: number,
    signer: SignerInfo,
    lockerAddress: string,
    exchange?: {
      outputToken: string
      outputAmount: string
    },
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],

    { chainId = 137, appId = exchange ? 1 : 0 } = {},
  ) {
    const isExchange = !!exchange
    let dataHex = generateBrc2OpReturn({
      chainId,
      appId,
      brc20TokenId,
      inputAmount: BigNumber(brc.amount).multipliedBy(1e18).toFixed(0),
      recipientAddress,
      isExchange,
      outputToken: exchange?.outputToken,
      outputAmount: exchange?.outputAmount,
    })
    let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex)
    return this.inscribeAndTransferBrc20Unsigned(
      lockerAddress,
      brc,
      signer,
      ordinalSigner,
      [opTarget],
      fee,
      extendedUtxo,
    )
  }

  async wrapBrc20OnlyTransferUnsigned(
    recipientAddress: string,
    brcInscribeTx: {
      hash: string
      value: number
      index: number
    },
    brc: { tick: string; amount: number | string },
    brc20TokenId: number,
    signer: SignerInfo,
    lockerAddress: string,
    exchange?: {
      outputToken: string
      outputAmount: string
    },
    ordinalSigner?: SignerInfo,
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],

    { chainId = 137, appId = exchange ? 1 : 0 } = {},
  ) {
    let utxo: ExtendedUtxo[] =
      extendedUtxo || (await this.btcInterface.getBTCUtxo(signer.address, signer))

    const isExchange = !!exchange
    let dataHex = generateBrc2OpReturn({
      chainId,
      appId,
      brc20TokenId,
      inputAmount: BigNumber(brc.amount).multipliedBy(1e18).toFixed(0),
      recipientAddress,
      isExchange,
      outputToken: exchange?.outputToken,
      outputAmount: exchange?.outputAmount,
    })
    let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex)
    let feeRate = await this.getFeeRate(fee)
    let transferTxUnsignedInfo = await this.transferBrc20Unsigned(
      lockerAddress,
      brcInscribeTx,
      signer,
      ordinalSigner,
      feeRate,
      utxo,
      [opTarget],
    )
    return transferTxUnsignedInfo
  }

  async wrapBrc20(
    recipientAddress: string,
    brc: { tick: string; amount: number | string },
    brc20TokenId: number,
    lockerAddress: string,
    exchange?: {
      outputToken: string
      outputAmount: string
    },
    fee: FeeRateType = "normal",
    extendedUtxo?: ExtendedUtxo[],

    { chainId = 137, appId = exchange ? 1 : 0 } = {},
  ) {
    const isExchange = !!exchange

    let dataHex = generateBrc2OpReturn({
      chainId,
      appId,
      brc20TokenId,
      inputAmount: BigNumber(brc.amount).multipliedBy(1e18).toFixed(0),
      recipientAddress,
      isExchange,
      outputToken: exchange?.outputToken,
      outputAmount: exchange?.outputAmount,
    })
    let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex)
    return this.inscribeAndTransferBrc20(lockerAddress, brc, [opTarget], fee, extendedUtxo)
  }
}

export default OrdinalWallet
