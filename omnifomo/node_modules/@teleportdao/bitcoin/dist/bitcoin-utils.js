"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressTypeHelper = exports.publicKeyConvertor = exports.createAddressObjectByPublicKey = exports.createAddressObjectByHash = exports.createAddressObjectByScript = exports.validateAddress = exports.extractTransactionsAndBlockInfoFromRawBlock = exports.parseRawBlock = exports.convertBitcoinScriptToAddress = exports.createAddressObjectByAddress = exports.getAddressType = exports.parseBlockHeader = exports.calculateMerkleProof = exports.parseRawTransaction = exports.getPrivateKeyHexFromWIF = exports.getPubKeyFromPrivateKeyHex = exports.getPubKeyFromPrivateKeyWIF = exports.getPublicKeyHexByXpubAndIndex = exports.reverseBytes = exports.getPrivateKeyHexFromMnemonic = exports.generateMnemonic = exports.networks = void 0;
const bip39 = __importStar(require("bip39"));
const bip32_1 = __importDefault(require("bip32"));
const ecc = __importStar(require("@bitcoinerlab/secp256k1"));
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bitcoinEcPair = __importStar(require("bitcoinjs-ecpair"));
const networks_1 = __importDefault(require("./utils/networks"));
exports.networks = networks_1.default;
const bip32 = (0, bip32_1.default)(ecc);
const { ECPair } = bitcoinEcPair;
bitcoin.initEccLib(ecc);
const varUnit = require("varuint-bitcoin");
const fastRoot = require("merkle-lib/fastRoot");
const merkle = require("merkle-lib");
const merkleProof = require("merkle-lib/proof");
function generateMnemonic() {
    const mnemonic = bip39.generateMnemonic(256);
    return mnemonic;
}
exports.generateMnemonic = generateMnemonic;
function getPrivateKeyHexFromMnemonic(mnemonic, index = 0, isChange = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const node = bip32.fromSeed(yield bip39.mnemonicToSeed(mnemonic));
        return node
            .derive(isChange ? 1 : 0)
            .derive(index)
            .privateKey.toString("hex");
    });
}
exports.getPrivateKeyHexFromMnemonic = getPrivateKeyHexFromMnemonic;
function reverseBytes(hexInput) {
    return Buffer.from(hexInput, "hex").reverse().toString("hex");
}
exports.reverseBytes = reverseBytes;
function getPublicKeyHexByXpubAndIndex(xpub, index = 0, isChange = false, network = networks_1.default.bitcoin) {
    const node = bip32.fromBase58(xpub, network);
    return node
        .derive(isChange ? 1 : 0)
        .derive(index)
        .publicKey.toString("hex");
}
exports.getPublicKeyHexByXpubAndIndex = getPublicKeyHexByXpubAndIndex;
function getPubKeyFromPrivateKeyWIF(privateKeyWIF, network = bitcoin.networks.bitcoin) {
    let key = ECPair.fromWIF(privateKeyWIF, network);
    return key.publicKey;
}
exports.getPubKeyFromPrivateKeyWIF = getPubKeyFromPrivateKeyWIF;
function getPubKeyFromPrivateKeyHex(privateKeyHex, network = bitcoin.networks.bitcoin) {
    let key = ECPair.fromPrivateKey(Buffer.from(privateKeyHex, "hex"), { network });
    return key.publicKey;
}
exports.getPubKeyFromPrivateKeyHex = getPubKeyFromPrivateKeyHex;
function getPrivateKeyHexFromWIF(privateKeyWIF, network = bitcoin.networks.bitcoin) {
    let key = ECPair.fromWIF(privateKeyWIF, network);
    return key.privateKey.toString("hex");
}
exports.getPrivateKeyHexFromWIF = getPrivateKeyHexFromWIF;
function parseRawTransaction(rawTransaction) {
    const size = {
        version: 4,
        flag: 2,
        tx: 32,
        index: 4,
        sequence: 4,
        amount: 8,
    };
    let offset = 0;
    let version = rawTransaction.slice(offset, size.version * 2);
    offset += size.version * 2;
    let flag = rawTransaction.slice(offset, offset + size.flag * 2);
    offset = flag === "0001" ? offset + size.flag * 2 : offset;
    let inputsStartIndex = offset;
    let numberOfInputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
    let noiSize = varUnit.encodingLength(numberOfInputs);
    offset += noiSize * 2;
    for (let i = 0; i < numberOfInputs; i += 1) {
        offset += size.tx * 2;
        offset += size.index * 2;
        let sigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
        let sigLengthSize = varUnit.encodingLength(sigLength);
        offset += sigLengthSize * 2;
        offset += sigLength * 2;
        offset += size.sequence * 2;
    }
    let inputLastIndex = offset;
    let outputStartIndex = offset;
    let numberOfOutputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
    let nooSize = varUnit.encodingLength(numberOfOutputs);
    offset += nooSize * 2;
    for (let i = 0; i < numberOfOutputs; i += 1) {
        offset += size.amount * 2;
        let unlockSigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
        let unlockSigLengthSize = varUnit.encodingLength(unlockSigLength);
        offset += unlockSigLengthSize * 2;
        offset += unlockSigLength * 2;
    }
    let outputLastIndex = offset;
    version = `0x${version}`;
    flag = `0x${flag}`;
    const vin = `0x${rawTransaction.slice(inputsStartIndex, inputLastIndex)}`;
    const vout = `0x${rawTransaction.slice(outputStartIndex, outputLastIndex)}`;
    let witness = `0x${rawTransaction.slice(outputLastIndex, rawTransaction.length - 8)}`;
    let locktime = `0x${rawTransaction.slice(rawTransaction.length - 8, rawTransaction.length)}`;
    return { version, flag, vin, vout, witness, locktime };
}
exports.parseRawTransaction = parseRawTransaction;
function calculateMerkleProof(blockTransactions, txId, blockMerkleRoot) {
    let transactionIndex = blockTransactions.findIndex((tx) => tx === txId);
    if (transactionIndex < 0)
        throw new Error("txId is not in this tree");
    let data = blockTransactions.map((a) => Buffer.from(a, "hex").reverse());
    if (blockMerkleRoot &&
        blockMerkleRoot !== fastRoot(data, bitcoin.crypto.hash256).toString("hex")) {
        throw new Error("calculated merkleRoot and block merkleRoot not matched");
    }
    let tree = merkle(data, bitcoin.crypto.hash256);
    let proof = merkleProof(tree, data[transactionIndex]);
    let intermediateNodesArray = proof
        .map((_id) => _id && _id.toString("hex"))
        .filter((_id) => _id != null);
    let intermediateNodes = intermediateNodesArray.reduce((a, value, index) => index !== transactionIndex % 2 && index < intermediateNodesArray.length - 1 ? a + value : a, "0x");
    return {
        intermediateNodes,
        transactionIndex,
    };
}
exports.calculateMerkleProof = calculateMerkleProof;
function parseBlockHeader(headerHex) {
    const size = {
        version: 4,
        previousBlockHash: 32,
        merkleRoot: 32,
        timestamp: 4,
        difficulty: 4,
        nonce: 4,
    };
    let offset = 0;
    let result = {};
    for (let key in size) {
        result[key] = headerHex.slice(offset, offset + size[key] * 2);
        offset += size[key] * 2;
    }
    return result;
}
exports.parseBlockHeader = parseBlockHeader;
function getAddressType(address, network = bitcoin.networks.bitcoin) {
    if (address.startsWith(`${network.bech32}1p`)) {
        return "p2tr";
    }
    if (address.startsWith(network.bech32)) {
        bitcoin.address.fromBech32(address);
        return "p2wpkh";
    }
    let base58Data = bitcoin.address.fromBase58Check(address);
    if (base58Data.version === Number(network.scriptHash)) {
        return "p2sh";
    }
    if (base58Data.version === Number(network.pubKeyHash)) {
        return "p2pkh";
    }
    throw new Error("invalid address");
}
exports.getAddressType = getAddressType;
function createAddressObjectByAddress(address, network = bitcoin.networks.bitcoin) {
    let addressType = getAddressType(address, network);
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                address,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                address,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                address,
                network,
            });
            break;
        case "p2tr":
            addressObject = bitcoin.payments.p2tr({
                address,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return { addressObject, addressType };
}
exports.createAddressObjectByAddress = createAddressObjectByAddress;
function convertBitcoinScriptToAddress(script, network = bitcoin.networks.bitcoin) {
    try {
        return bitcoin.address.fromOutputScript(script, network);
    }
    catch (error) {
        return undefined;
    }
}
exports.convertBitcoinScriptToAddress = convertBitcoinScriptToAddress;
function parseRawBlock(rawBlockHex, blockNumber, network = bitcoin.networks.bitcoin) {
    var _a;
    let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"));
    let blockHash = block.getHash().toString("hex");
    let merkleRoot = block.merkleRoot.toString("hex");
    let prvBlockHash = block.prevHash.toString("hex");
    return {
        blockNumber,
        merkleRoot,
        prvBlockHash,
        transactions: (_a = block.transactions) === null || _a === void 0 ? void 0 : _a.map((tx) => ({
            txId: tx.getId(),
            version: tx.version,
            locktime: tx.locktime,
            blockNumber,
            blockHash,
            vout: tx.outs.map((vo, index) => ({
                address: convertBitcoinScriptToAddress(vo.script, network),
                script: vo.script.toString("hex"),
                value: vo.value,
                index,
            })),
            vin: tx.ins.map((vi) => ({
                txId: Buffer.from(vi.hash).reverse().toString("hex"),
                index: vi.index,
            })),
        })),
    };
}
exports.parseRawBlock = parseRawBlock;
function extractTransactionsAndBlockInfoFromRawBlock(rawBlockHex, blockNumber, addresses = [], inputTxIds = [], network = bitcoin.networks.bitcoin) {
    var _a;
    let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"));
    let blockHash = block.getHash().reverse().toString("hex");
    let merkleRoot = block.merkleRoot.toString("hex");
    let prvBlockHash = block.prevHash.toString("hex");
    let blockInfo = {
        blockNumber,
        blockHash,
        merkleRoot,
        prvBlockHash,
    };
    let addressScript = addresses.map((address) => createAddressObjectByAddress(address, network).addressObject.output.toString("hex"));
    let blockTxIds = block.transactions.map((tx) => tx.getId());
    let withdrawTxs = [];
    let depositTxs = [];
    (_a = block.transactions) === null || _a === void 0 ? void 0 : _a.forEach((tx) => {
        let txId = tx.getId();
        let inputTxAddress;
        let isWithdraw = tx.ins.find((vi) => {
            let viTxId = Buffer.from(vi.hash).reverse().toString("hex");
            let viInput = inputTxIds.find((vin) => vin.txId === viTxId && vin.index === vi.index);
            inputTxAddress = viInput === null || viInput === void 0 ? void 0 : viInput.address;
            return !!inputTxAddress;
        });
        if (isWithdraw && inputTxAddress) {
            let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot);
            withdrawTxs.push({
                txId: tx.getId(),
                version: tx.version,
                locktime: tx.locktime,
                blockNumber,
                blockHash,
                merkleProof: txMerkleProof,
                vout: tx.outs.map((vo) => ({
                    address: convertBitcoinScriptToAddress(vo.script, network),
                    script: vo.script.toString("hex"),
                    value: vo.value,
                })),
                vin: tx.ins.map((vi) => {
                    let viTxId = Buffer.from(vi.hash).reverse().toString("hex");
                    let viInput = inputTxIds.find((vin) => vin.txId === viTxId && vin.index === vi.index);
                    return {
                        txId: Buffer.from(vi.hash).reverse().toString("hex"),
                        index: vi.index,
                        address: viInput === null || viInput === void 0 ? void 0 : viInput.address,
                        script: viInput === null || viInput === void 0 ? void 0 : viInput.script,
                        value: viInput === null || viInput === void 0 ? void 0 : viInput.value,
                    };
                }),
                address: inputTxAddress,
                addressScript: createAddressObjectByAddress(inputTxAddress, network).addressObject.output.toString("hex"),
            });
        }
        let addressIndex = -1;
        let isDeposit = tx.outs.find((blockTxVo) => {
            let sIndex = addressScript.findIndex((addScript) => addScript === blockTxVo.script.toString("hex"));
            if (sIndex >= 0) {
                addressIndex = sIndex;
                return true;
            }
            return false;
        });
        if (isDeposit && addressIndex >= 0) {
            let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot);
            depositTxs.push({
                txId: tx.getId(),
                version: tx.version,
                locktime: tx.locktime,
                blockNumber,
                blockHash,
                merkleProof: txMerkleProof,
                vout: tx.outs.map((vo) => ({
                    address: convertBitcoinScriptToAddress(vo.script, network),
                    script: vo.script.toString("hex"),
                    value: vo.value,
                })),
                vin: tx.ins.map((vi) => ({
                    txId: Buffer.from(vi.hash).reverse().toString("hex"),
                    index: vi.index,
                })),
                addressScript: addressScript[addressIndex],
                address: addresses[addressIndex],
            });
        }
    });
    return {
        blockInfo,
        withdrawTxs,
        depositTxs,
    };
}
exports.extractTransactionsAndBlockInfoFromRawBlock = extractTransactionsAndBlockInfoFromRawBlock;
function validateAddress(address, network = bitcoin.networks.bitcoin) {
    try {
        let isValid = false;
        let isAddressSegwit = address.startsWith(network.bech32);
        if (isAddressSegwit) {
            bitcoin.address.fromBech32(address);
            isValid = true;
        }
        else {
            let base58Data = bitcoin.address.fromBase58Check(address);
            isValid =
                base58Data.version === Number(network.scriptHash) ||
                    base58Data.version === Number(network.pubKeyHash);
        }
        return isValid;
    }
    catch (error) {
        return false;
    }
}
exports.validateAddress = validateAddress;
function toXOnlyPublicKey(pubKey) {
    return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
}
function createAddressObjectByScript({ addressType, script }, network = bitcoin.networks.bitcoin) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                output: script,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                output: script,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                output: script,
                network,
            });
            break;
        case "p2wsh":
            addressObject = bitcoin.payments.p2wsh({
                output: script,
                network,
            });
            break;
        case "p2tr":
            addressObject = bitcoin.payments.p2tr({
                output: script,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
exports.createAddressObjectByScript = createAddressObjectByScript;
function createAddressObjectByHash({ addressType, hash }, network = bitcoin.networks.bitcoin) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                hash,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                hash,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                hash,
                network,
            });
            break;
        case "p2wsh":
            addressObject = bitcoin.payments.p2wsh({
                hash,
                network,
            });
            break;
        case "p2tr":
            addressObject = bitcoin.payments.p2tr({
                pubkey: hash,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
exports.createAddressObjectByHash = createAddressObjectByHash;
function createAddressObjectByPublicKey({ addressType, publicKey }, network = bitcoin.networks.bitcoin) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                pubkey: publicKey,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                pubkey: publicKey,
                network,
            });
            break;
        case "p2sh-p2wpkh":
            addressObject = bitcoin.payments.p2sh({
                redeem: bitcoin.payments.p2wpkh({
                    pubkey: publicKey,
                    network,
                }),
            });
            break;
        case "p2tr":
            addressObject = bitcoin.payments.p2tr({
                internalPubkey: toXOnlyPublicKey(publicKey),
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
exports.createAddressObjectByPublicKey = createAddressObjectByPublicKey;
function publicKeyConvertor(publicKeyHex, compressed = true) {
    let pubkey = ECPair.fromPublicKey(Buffer.from(publicKeyHex, "hex"), {
        compressed,
    });
    return pubkey.publicKey.toString("hex");
}
exports.publicKeyConvertor = publicKeyConvertor;
exports.addressTypeHelper = {
    addressTypesNumber: { p2pk: 0, p2pkh: 1, p2sh: 2, p2wpkh: 3, p2wsh: 4, p2tr: 5 },
    addressTypes: ["p2pk", "p2pkh", "p2sh", "p2wpkh", "p2wsh", "p2tr"],
};
//# sourceMappingURL=bitcoin-utils.js.map