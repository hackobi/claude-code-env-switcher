"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinInterfaceOrdinal = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const providers_1 = require("@teleportdao/providers");
const bitcoin_interface_1 = require("./bitcoin-interface");
const tools_1 = require("./utils/tools");
const brc20_helper_1 = require("./helper/brc20-helper");
class BitcoinInterfaceOrdinal extends bitcoin_interface_1.BitcoinInterface {
    constructor(connectionInfo, networkName, uniSatToken) {
        super(networkName, connectionInfo);
        this.unisat = new providers_1.bitcoin.UniSat({
            token: uniSatToken,
        }, networkName.includes("testnet"));
    }
    getInscriptionWithRetry(inscriptionId, { numberOfRetry = 5, sleepTime = 20000 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let count = 0;
            while (count <= numberOfRetry) {
                try {
                    let inscription = yield this.unisat.getInscriptionInfo(inscriptionId);
                    if (inscription === null || inscription === void 0 ? void 0 : inscription.brc20) {
                        return inscription;
                    }
                }
                catch (e) {
                    console.log(e.message);
                }
                yield (0, tools_1.sleep)(sleepTime + count * 5000);
                count += 1;
            }
            return null;
        });
    }
    getTransactionBrc20TransferInfo(transaction) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let txBrc20s = [];
            for (let x = 0; x < transaction.vout.length - 1; x += 1) {
                if (!transaction.vout[x].address) {
                    return [];
                }
                let inscription = yield this.unisat.getInscriptionInfo(`${transaction.vin[x].txId}i${transaction.vin[x].index}`);
                const brc20 = ((_a = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _a === void 0 ? void 0 : _a.op) === "transfer" ? inscription.brc20 : undefined;
                if (brc20 && inscription) {
                    txBrc20s.push({
                        txId: transaction.txId,
                        receiver: transaction.vout[x].address,
                        index: x,
                        inscription,
                        brc20,
                    });
                }
                else {
                    return [];
                }
            }
            return txBrc20s;
        });
    }
    convertToBrc20WrapRequest(transaction, lockerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let { vout } = transaction;
            let request = (0, brc20_helper_1.checkAndParseBrc20Request)(vout, lockerAddress);
            let lockerLockingScript = transaction.addressScript ||
                this.convertAddressToScript(lockerAddress).script.toString("hex");
            return {
                transaction,
                request,
                lockerAddress,
                lockerLockingScript,
            };
        });
    }
    getBrc20WrapRequests(addresses, startblockNumber, endBlockNumber) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            let transactions = yield this.getMultipleBlocksTransactions(addresses, startblockNumber, endBlockNumber || (yield this.getLatestBlockNumber()));
            let requests = [];
            let invalidRequests = [];
            for (let inputTx of transactions) {
                let data = yield this.convertToBrc20WrapRequest(inputTx, inputTx.address);
                if (data.request.status) {
                    let inscription = yield this.getInscriptionWithRetry(`${inputTx.vin[0].txId}i${inputTx.vin[0].index}`);
                    const brc20 = ((_a = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _a === void 0 ? void 0 : _a.op) === "transfer" ? inscription.brc20 : undefined;
                    if (!brc20) {
                        invalidRequests.push(Object.assign(Object.assign({}, data), { message: `invalid brc20 -> ${(_b = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _b === void 0 ? void 0 : _b.op}:${(_c = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _c === void 0 ? void 0 : _c.amt}` }));
                    }
                    else if (!(0, bignumber_js_1.default)(brc20.amt)
                        .multipliedBy(1e18)
                        .isEqualTo(((_d = data.request.data) === null || _d === void 0 ? void 0 : _d.inputAmount) || 0)) {
                        invalidRequests.push(Object.assign(Object.assign({}, data), { message: `invalid brc20 amount -> ${(_e = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _e === void 0 ? void 0 : _e.op}:${(_f = inscription === null || inscription === void 0 ? void 0 : inscription.brc20) === null || _f === void 0 ? void 0 : _f.amt}:${(_g = data.request.data) === null || _g === void 0 ? void 0 : _g.inputAmount}` }));
                    }
                    else {
                        requests.push(Object.assign(Object.assign({}, data), { brc20 }));
                    }
                }
                else if (data.request.code !== "NO_OP_RETURN") {
                    invalidRequests.push(data);
                }
            }
            return { requests, invalidRequests };
        });
    }
    getBTCUtxo(address, signerInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return providers_1.bitcoin.UniSat.convertToNormalUtxo(((_a = (yield this.unisat.getBTCUtxo(address))) === null || _a === void 0 ? void 0 : _a.utxo) || []).map(({ txId, index, value }) => ({
                hash: txId,
                index,
                value,
                signerInfo,
            }));
        });
    }
    getInscriptionUtxo(address, signerInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return providers_1.bitcoin.UniSat.convertToNormalUtxo(((_a = (yield this.unisat.getInscriptionUtxo(address))) === null || _a === void 0 ? void 0 : _a.utxo) || []).map(({ txId, index, value }) => ({
                hash: txId,
                index,
                value,
                signerInfo,
            }));
        });
    }
}
exports.BitcoinInterfaceOrdinal = BitcoinInterfaceOrdinal;
//# sourceMappingURL=bitcoin-interface-ordinal.js.map