/// <reference types="node" />
import { Network, Payment } from "bitcoinjs-lib";
import { BitcoinTransactionBuilder } from "./transaction-builder";
import type { RPCConnectionInfo, UtxoConnectionInfo } from "./type";
import type { ExtendedUtxo, SignerInfo, Target, TargetAddress } from "./transaction-builder/transaction-builder";
import BitcoinSigner from "./sign/sign-transaction";
import { BitcoinInterfaceWallet } from "./bitcoin-interface-wallet";
export type FeeRateType = "normal" | "slow" | "fast" | number;
export declare class BitcoinBaseWallet {
    SINGLESIG_TYPES: string[];
    MULTISIG_TYPES: string[];
    network: Network;
    hdWalletPath: {
        p2pkh: string;
        p2wpkh: string;
        "p2sh-p2wpkh": string;
        p2sh: string;
        p2wsh: string;
        "p2sh-p2wsh": string;
        p2tr: string;
    };
    transactionBuilder: BitcoinTransactionBuilder;
    btcInterface: BitcoinInterfaceWallet;
    signer: BitcoinSigner;
    currentAccount?: string;
    currentAccountType?: string;
    addressObj?: Payment;
    privateKey?: Buffer;
    publicKey?: Buffer;
    multisig?: {
        publicKeys: Buffer[];
        numberOfSigners: number;
    };
    constructor(networkName: string, connectionInfo?: {
        utxo?: UtxoConnectionInfo;
        rpc?: RPCConnectionInfo;
    });
    static satoshiToBTC(satoshi: number | string): string;
    static btcToSatoshi(btc: number | string): string;
    get bitcoinAddress(): string | undefined;
    get signerInfo(): {
        address: string;
        addressType: string;
        publicKey: string;
        publicKeys: string[] | undefined;
        numberOfSigners: number | undefined;
    } | undefined;
    setAccountPrivateKey(privateKeyHex: string, accountType?: string): void;
    setAccountType(accountType?: string, multisig?: {
        publicKeys: string[];
        numberOfSigners?: number;
    }): string;
    setAccountPrivateKeyByMnemonic({ mnemonic, mnemonicPassword, index, walletNumber, addressType, }: {
        mnemonic: string;
        mnemonicPassword?: string;
        index?: number;
        walletNumber?: number;
        addressType?: string;
    }): string;
    checkBalanceIsSufficient({ targets, extendedUtxo, changeAddress, feeRate, }: {
        targets: Target[];
        extendedUtxo: ExtendedUtxo[];
        changeAddress: string;
        feeRate: number;
    }): boolean;
    getExtendedUtxo(input: SignerInfo): Promise<{
        hash: string;
        value: number;
        index: number;
        signerInfo: SignerInfo;
    }[]>;
    getFeeRate(feeRate?: FeeRateType): Promise<number>;
    sendBTC(receiverAddress: string, amountInSatoshi: number | "all", fee?: FeeRateType, staticExtendedUtxo?: ExtendedUtxo[]): Promise<any>;
    sendBTCMultipleAddress(receivers: TargetAddress[], fee?: FeeRateType, staticExtendedUtxo?: ExtendedUtxo[]): Promise<any>;
    sendBTCToMultipleAddressUnsignedTx(receivers: TargetAddress[], signerInfo: SignerInfo, fee?: FeeRateType, staticExtendedUtxo?: ExtendedUtxo[], fullAmount?: boolean): Promise<{
        unsignedTransaction: string;
        outputs: Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("./transaction-builder").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    sendBTCUnsignedTx(receiver: string, amountInSatoshi: number | "all", signerInfo: SignerInfo, fee?: FeeRateType, staticExtendedUtxo?: ExtendedUtxo[]): Promise<{
        unsignedTransaction: string;
        outputs: Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("./transaction-builder").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    sendSignedTx(signedTx: string): Promise<any>;
    sendSignedPsbt(signedPsbt: string): Promise<any>;
    sendSignedPsbtWithRetry(signedPsbt: string, { maxTries, retrySleep }?: {
        maxTries?: number | undefined;
        retrySleep?: number | undefined;
    }): Promise<any>;
    sendMultiSignedPsbt(signedPsbts?: string[]): Promise<any>;
    increaseTransactionFeeUnsignedPsbt(txId: string, signerInfos: SignerInfo[], extraExtendedUtxo: ExtendedUtxo[], changeAddress: string, staticFeeRate?: number): Promise<{
        unsignedTransaction: string;
        outputs: Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: import("./transaction-builder").ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
}
//# sourceMappingURL=bitcoin-wallet-base%20copy.d.ts.map