"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndParseBrc20Request = exports.parseBrc20OpReturn = exports.generateBrc2OpReturn = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const configs_1 = require("@teleportdao/configs");
const brc20WrapRequests = configs_1.brc20.requestAppId;
function generateBrc2OpReturn({ chainId, appId, brc20TokenId, inputAmount, recipientAddress, thirdPartyId = 0, isExchange = false, outputToken, outputAmount, }) {
    let data = "";
    if (chainId.toString(16).length > 4)
        throw new Error("chainId should be less than 2 bytes");
    data += chainId.toString(16).padStart(4, "0");
    data += appId.toString(16).padStart(2, "0");
    data += brc20TokenId.toString(16).padStart(4, "0");
    data += (0, bignumber_js_1.default)(inputAmount).toString(16).padStart(26, "0");
    data += recipientAddress.replace("0x", "").toLowerCase().padStart(40, "0");
    data += (0, bignumber_js_1.default)(thirdPartyId).toString(16).padStart(2, "0");
    if (isExchange) {
        if (!outputAmount || !outputToken) {
            throw new Error("outputAmount and outputToken are required for exchange");
        }
        data += outputToken.replace("0x", "").toLowerCase().padStart(40, "0");
        data += (0, bignumber_js_1.default)(outputAmount).toString(16).padStart(26, "0");
    }
    return data;
}
exports.generateBrc2OpReturn = generateBrc2OpReturn;
function parseBrc20OpReturn(data) {
    let parsedData = {};
    parsedData.chainId = Number(`0x${data.slice(0, 4)}`);
    parsedData.appId = Number(`0x${data.slice(4, 6)}`);
    parsedData.brc20TokenId = Number(`0x${data.slice(6, 10)}`);
    parsedData.inputAmount = new bignumber_js_1.default(`0x${data.slice(10, 36)}`).toFixed(0);
    parsedData.recipientAddress = `0x${data.slice(36, 76)}`;
    parsedData.thirdPartyId = Number(`0x${data.slice(76, 78)}`);
    if (data.length === 78) {
        parsedData.requestType = "Wrap";
        return {
            status: true,
            data: parsedData,
        };
    }
    parsedData.outputToken = `0x${data.slice(78, 118)}`;
    parsedData.outputAmount = new bignumber_js_1.default(`0x${data.slice(118, 144)}`).toFixed(0);
    if (data.length === 144) {
        parsedData.requestType = "WrapAndSwap";
        return {
            status: true,
            data: parsedData,
        };
    }
    return {
        status: false,
        message: `invalid OP_RETURN data for requestType: 'wrap or exchange'. invalid data length : ${data.length} - valid length : 144 , 78`,
        code: "INVALID_OP_RETURN",
    };
}
exports.parseBrc20OpReturn = parseBrc20OpReturn;
function parseBrc20RawRequest(opReturnData) {
    let data = opReturnData.slice(2, 4) === "4c" ? opReturnData.slice(6) : opReturnData.slice(4);
    let appIdHex = data.slice(4, 6);
    if (!appIdHex) {
        return {
            status: false,
            message: `invalid OP_RETURN data : ${data}`,
            code: "INVALID_APP_ID",
        };
    }
    let appId = Number(`0x${appIdHex}`);
    let requestType = Object.keys(brc20WrapRequests).find((key) => brc20WrapRequests[key].appIds.includes(appId));
    switch (requestType) {
        case "Wrap":
        case "WrapAndSwap":
            return parseBrc20OpReturn(data);
        default:
            return {
                status: false,
                message: `invalid appId : ${appId}`,
                code: "INVALID_OP_RETURN",
            };
    }
}
function checkAndParseBrc20Request(vouts, address) {
    var _a;
    let requestOutputIndex = vouts.findIndex((vout_) => vout_.script.startsWith("6a"));
    if (requestOutputIndex >= 0) {
        let opReturnData = (_a = vouts[requestOutputIndex]) === null || _a === void 0 ? void 0 : _a.script;
        if (!opReturnData) {
            return {
                status: false,
                message: "invalid OP_RETURN",
                code: "INVALID_OP_RETURN",
            };
        }
        let brc20Transfer = vouts[0];
        if (brc20Transfer.address !== address || brc20Transfer.value < 546) {
            return {
                status: false,
                message: "no brc20 transfer output",
                code: "NO_BRC20_TRANSFER",
            };
        }
        let dataResponse = parseBrc20RawRequest(opReturnData);
        if (dataResponse.status) {
            let lockerFeeOutputIndex = vouts.findIndex((vout_, i) => vout_.address === address && +i > 0);
            let lockerFeeValue = lockerFeeOutputIndex >= 0 ? vouts[lockerFeeOutputIndex].value : 0;
            return {
                status: true,
                data: dataResponse.data,
                dataOutputIndex: requestOutputIndex,
                lockerFeeValue,
                lockerFeeOutputIndex,
                brc20OutputIndex: 0,
                brc20OutputValue: brc20Transfer.value,
            };
        }
        return dataResponse;
    }
    return {
        status: false,
        message: "transaction outputs should contain OP_RETURN",
        code: "NO_OP_RETURN",
    };
}
exports.checkAndParseBrc20Request = checkAndParseBrc20Request;
//# sourceMappingURL=brc20-helper.js.map