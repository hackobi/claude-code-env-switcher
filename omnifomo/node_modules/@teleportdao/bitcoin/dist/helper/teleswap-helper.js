"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAndParseWrapRequest = exports.parseWrapRawRequest = exports.parseWrapRequest = exports.getBurnTransactionInfo = exports.generateWrapOpReturn = void 0;
const configs_1 = require("@teleportdao/configs");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const wrapOpReturnLength = {
    chainId: 4,
    appId: 2,
    thirdPartyId: 2,
    networkFee: 6,
    bridgePercentageFee: 6,
    outputAmount: 28,
};
function generateWrapOpReturn({ chainId, appId, recipientAddress, networkFee, thirdPartyId = 0, speed = false, isExchange = false, outputToken, outputAmount, bridgePercentageFee = 0, }) {
    let data = "";
    if ((0, bignumber_js_1.default)(chainId).toString(16).length > wrapOpReturnLength.chainId) {
        throw new Error("invalid chainId");
    }
    if ((0, bignumber_js_1.default)(appId).toString(16).length > wrapOpReturnLength.appId) {
        throw new Error("invalid appId");
    }
    if ((0, bignumber_js_1.default)(networkFee).toString(16).length > wrapOpReturnLength.networkFee) {
        throw new Error("invalid percentageFee");
    }
    if ((0, bignumber_js_1.default)(thirdPartyId).toString(16).length > wrapOpReturnLength.thirdPartyId) {
        throw new Error("invalid percentageFee");
    }
    data += (0, bignumber_js_1.default)(chainId).toString(16).padStart(wrapOpReturnLength.chainId, "0");
    data += (0, bignumber_js_1.default)(appId).toString(16).padStart(wrapOpReturnLength.appId, "0");
    data += recipientAddress.replace("0x", "").toLowerCase().padStart(40, "0");
    data += (0, bignumber_js_1.default)(networkFee).toString(16).padStart(wrapOpReturnLength.networkFee, "0");
    data += speed ? "01" : "00";
    data += (0, bignumber_js_1.default)(thirdPartyId).toString(16).padStart(wrapOpReturnLength.thirdPartyId, "0");
    if (!isExchange) {
        if (data.length !== 28 * 2)
            throw new Error("invalid data length");
        return data;
    }
    if (!outputToken) {
        throw new Error("invalid outputToken");
    }
    if (!outputAmount ||
        (0, bignumber_js_1.default)(outputAmount).toString(16).length > wrapOpReturnLength.outputAmount) {
        throw new Error("invalid outputAmount");
    }
    if ((bridgePercentageFee || 0) > 100 ||
        (bridgePercentageFee && bridgePercentageFee < 0.00001) ||
        (0, bignumber_js_1.default)((bridgePercentageFee === null || bridgePercentageFee === void 0 ? void 0 : bridgePercentageFee.toFixed(5)) || 0)
            .multipliedBy(1e5)
            .toString(16).length > wrapOpReturnLength.bridgePercentageFee) {
        throw new Error("invalid percentageFee");
    }
    data += outputToken.replace("0x", "").toLowerCase().padStart(40, "0");
    data += (0, bignumber_js_1.default)(outputAmount).toString(16).padStart(wrapOpReturnLength.outputAmount, "0");
    data += (0, bignumber_js_1.default)((bridgePercentageFee === null || bridgePercentageFee === void 0 ? void 0 : bridgePercentageFee.toFixed(5)) || 0)
        .multipliedBy(1e5)
        .toString(16)
        .padStart(wrapOpReturnLength.bridgePercentageFee, "0");
    if (data.length !== 65 * 2)
        throw new Error("invalid data length");
    return data;
}
exports.generateWrapOpReturn = generateWrapOpReturn;
function getBurnTransactionInfo(address, vin = [], vouts = []) {
    let lockerVinIndex = vin.findIndex((vi) => vi.address === address);
    if (lockerVinIndex >= 0) {
        let lockerVin = Object.assign(Object.assign({}, vin[lockerVinIndex]), { vinIndex: lockerVinIndex });
        let totalInputValue = vin.reduce((acc, current) => acc + current.value, 0);
        let receivers = [];
        let changes = [];
        vouts.forEach((vout, i) => {
            let voutWithIndex = Object.assign(Object.assign({}, vout), { index: i });
            if (voutWithIndex.address === address) {
                changes.push(voutWithIndex);
            }
            else {
                receivers.push(voutWithIndex);
            }
        });
        return { receivers, changes, totalInputValue, lockerVin };
    }
}
exports.getBurnTransactionInfo = getBurnTransactionInfo;
function parseWrapRequest(data) {
    let parsedData = {};
    parsedData.requestType = "Wrap";
    let offset = 0;
    parsedData.chainId = (0, bignumber_js_1.default)(`0x${data.slice(offset, (offset += wrapOpReturnLength.chainId))}`).toNumber();
    parsedData.appId = (0, bignumber_js_1.default)(`0x${data.slice(offset, (offset += wrapOpReturnLength.appId))}`).toNumber();
    parsedData.recipientAddress = `0x${data.slice(offset, (offset += 40))}`;
    parsedData.networkFee = new bignumber_js_1.default(`0x${data.slice(offset, (offset += wrapOpReturnLength.networkFee))}`).toFixed(0);
    parsedData.speed = data.slice(offset, (offset += 2)) === "01";
    parsedData.thirdPartyId = new bignumber_js_1.default(`0x${data.slice(offset, (offset += wrapOpReturnLength.thirdPartyId))}`).toNumber();
    if (data.length === offset) {
        return {
            status: true,
            data: parsedData,
        };
    }
    parsedData.requestType = "WrapAndSwap";
    parsedData.outputToken = `0x${data.slice(offset, (offset += 40))}`;
    parsedData.outputAmount = new bignumber_js_1.default(`0x${data.slice(offset, (offset += wrapOpReturnLength.outputAmount))}`).toFixed(0);
    parsedData.bridgePercentageFee = new bignumber_js_1.default(`0x${data.slice(offset, (offset += wrapOpReturnLength.bridgePercentageFee))}`)
        .dividedBy(1e5)
        .toNumber();
    if (parsedData.bridgePercentageFee > 100) {
        return {
            status: false,
            message: `invalid OP_RETURN data for requestType: 'wrap or wrapAndSwap'. invalid bridgePercentageFee`,
            code: "INVALID_OP_RETURN",
        };
    }
    if (data.length === offset) {
        return {
            status: true,
            data: parsedData,
        };
    }
    return {
        status: false,
        message: `invalid OP_RETURN data for requestType: 'wrap or wrapAndSwap'. invalid data length : ${data.length} - valid length : ${offset}`,
        code: "INVALID_OP_RETURN",
    };
}
exports.parseWrapRequest = parseWrapRequest;
function parseWrapRawRequest(opReturnData) {
    let data = opReturnData.slice(2, 4) === "4c" ? opReturnData.slice(6) : opReturnData.slice(4);
    let appIdHex = data.slice(wrapOpReturnLength.chainId, wrapOpReturnLength.chainId + wrapOpReturnLength.appId);
    if (!appIdHex) {
        return {
            status: false,
            message: `invalid OP_RETURN data : ${data}`,
            code: "INVALID_APP_ID",
        };
    }
    let appId = (0, bignumber_js_1.default)(`0x${appIdHex}`).toNumber();
    let requestType = Object.keys(configs_1.teleswap.requestAppId).find((key) => configs_1.teleswap.requestAppId[key].appIds.includes(appId));
    switch (requestType) {
        case "Wrap":
        case "WrapAndSwap":
            return parseWrapRequest(data);
        default:
            return {
                status: false,
                message: `invalid appId : ${appId}`,
                code: "INVALID_OP_RETURN",
            };
    }
}
exports.parseWrapRawRequest = parseWrapRawRequest;
function checkAndParseWrapRequest(vouts, lockerAddress) {
    var _a;
    let requestOutputIndex = vouts.findIndex((vout_) => vout_.script.startsWith("6a"));
    if (requestOutputIndex >= 0) {
        let opReturnData = ((_a = vouts[requestOutputIndex]) === null || _a === void 0 ? void 0 : _a.script) || null;
        if (!opReturnData) {
            return {
                status: false,
                message: "no data to validate. it should not happen",
                code: "INVALID_OP_RETURN",
            };
        }
        let valueOutputIndex = vouts.findIndex((vout_) => vout_.address === lockerAddress);
        let value = valueOutputIndex >= 0 ? vouts[valueOutputIndex].value || 0 : 0;
        let response = parseWrapRawRequest(opReturnData);
        if (!response.status || !("data" in response) || !response.data) {
            return response;
        }
        return {
            status: response.status,
            data: response.data,
            value,
            valueOutputIndex,
            requestOutputIndex,
        };
    }
    return {
        status: false,
        message: "transaction outputs must include an OP_RETURN",
        code: "NO_OP_RETURN",
    };
}
exports.checkAndParseWrapRequest = checkAndParseWrapRequest;
//# sourceMappingURL=teleswap-helper.js.map