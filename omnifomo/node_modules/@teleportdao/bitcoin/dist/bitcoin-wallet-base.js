"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinBaseWallet = void 0;
const bip39 = __importStar(require("bip39"));
const configs_1 = require("@teleportdao/configs");
const bip32_1 = __importDefault(require("bip32"));
const secp256k1_1 = __importDefault(require("@bitcoinerlab/secp256k1"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const transaction_builder_1 = require("./transaction-builder");
const sign_transaction_1 = __importDefault(require("./sign/sign-transaction"));
const bitcoin_utils_1 = require("./bitcoin-utils");
const networks_1 = __importDefault(require("./utils/networks"));
const tools_1 = require("./utils/tools");
const bip32 = (0, bip32_1.default)(secp256k1_1.default);
class BitcoinBaseWallet {
    constructor(networkName, connectionInfo) {
        this.network = networks_1.default[networkName];
        this.hdWalletPath = configs_1.hdWalletPath.bitcoin;
        this.transactionBuilder = new transaction_builder_1.BitcoinTransactionBuilder(networkName, this.network, connectionInfo);
        this.btcInterface = this.transactionBuilder.btcInterface;
        this.signer = new sign_transaction_1.default(this.network);
        this.currentAccount = undefined;
        this.currentAccountType = undefined;
        this.privateKey = undefined;
        this.publicKey = undefined;
    }
    static satoshiToBTC(satoshi) {
        return new bignumber_js_1.default(satoshi).dividedBy(1e8).toString();
    }
    static btcToSatoshi(btc) {
        return new bignumber_js_1.default(btc).multipliedBy(1e8).toFixed(0);
    }
    get signerInfo() {
        return this.privateKey
            ? {
                address: this.bitcoinAddress,
                publicKey: this.publicKey.toString("hex"),
                addressType: this.currentAccountType,
            }
            : undefined;
    }
    setAccountPrivateKey(privateKeyHex) {
        this.privateKey = Buffer.from(privateKeyHex, "hex");
        let publicKey = (0, bitcoin_utils_1.getPubKeyFromPrivateKeyHex)(privateKeyHex, this.network);
        this.publicKey = publicKey;
        this.setAccountType("p2wpkh");
    }
    setAccountType(accountType = "p2pkh") {
        if (!this.publicKey) {
            throw new Error("account not initialized");
        }
        let addressObj = this.transactionBuilder.createAddressObject({
            addressType: accountType,
            publicKey: this.publicKey,
        });
        this.currentAccount = addressObj.address;
        this.currentAccountType = accountType;
        this.addressObj = addressObj;
        this.bitcoinAddress = addressObj.address;
        return addressObj.address;
    }
    setAccountPrivateKeyByMnemonic({ mnemonic, mnemonicPassword = "", index = 0, walletNumber = 0, addressType = "p2sh-p2wpkh", }) {
        if (!bip39.validateMnemonic(mnemonic))
            throw new Error("invalid mnemonic");
        const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword);
        const node = bip32.fromSeed(seed);
        let basePath = this.hdWalletPath[addressType];
        if (!basePath) {
            throw new Error("incorrect path or addressType");
        }
        const path = `${basePath}/${walletNumber}`;
        const account = node.derivePath(path);
        const userKeyPair = account.derive(index);
        this.setAccountPrivateKey(userKeyPair.privateKey.toString("hex"));
        return this.setAccountType(addressType);
    }
    checkBalanceIsSufficient({ targets, extendedUtxo, changeAddress, feeRate, }) {
        try {
            this.transactionBuilder.helperHandleInputsAndOutputs({
                targets,
                extendedUtxo,
                changeObject: {
                    address: changeAddress,
                },
                feeRate,
            });
            return true;
        }
        catch (err) {
            return false;
        }
    }
    getExtendedUtxo(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.btcInterface.getExtendedUtxo(input);
        });
    }
    getFeeRate(feeRate = "normal") {
        return __awaiter(this, void 0, void 0, function* () {
            if (feeRate === 0)
                throw new Error("feeRate should be greater than 0");
            if (+feeRate > 0)
                return +feeRate;
            if (typeof feeRate === "string")
                return this.btcInterface.getFeeRate(feeRate);
            throw new Error("incorrect feeRate");
        });
    }
    sendBTC(receiverAddress, amountInSatoshi, fee = "normal", staticExtendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.signerInfo || !this.privateKey) {
                throw new Error("account not initialized");
            }
            const unsignedTx = yield this.sendBTCUnsignedTx(receiverAddress, amountInSatoshi, this.signerInfo, fee, staticExtendedUtxo);
            let signedPsbt = yield this.signer.signPsbt(unsignedTx, this.privateKey);
            let signedTx = this.signer.finalizePsbts([signedPsbt]);
            let txId = yield this.sendSignedTx(signedTx);
            return txId;
        });
    }
    sendBTCMultipleAddress(receivers, fee = "normal", staticExtendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.signerInfo || !this.privateKey) {
                throw new Error("account not initialized");
            }
            const unsignedTx = yield this.sendBTCToMultipleAddressUnsignedTx(receivers, this.signerInfo, fee, staticExtendedUtxo);
            let signedPsbt = yield this.signer.signPsbt(unsignedTx, this.privateKey);
            let signedTx = this.signer.finalizePsbts([signedPsbt]);
            let txId = yield this.sendSignedTx(signedTx);
            return txId;
        });
    }
    sendBTCToMultipleAddressUnsignedTx(receivers, signerInfo, fee = "normal", staticExtendedUtxo, fullAmount = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fullAmount) {
                receivers.forEach((r) => {
                    if ((0, bignumber_js_1.default)(r.value).isEqualTo(0))
                        throw new Error("incorrect amount");
                });
            }
            else if (receivers.length > 1)
                throw new Error("fullAmount only support one receiver");
            let feeRate = yield this.getFeeRate(fee);
            let extendedUtxo = staticExtendedUtxo || (yield this.getExtendedUtxo(signerInfo));
            let unsignedTx = yield this.transactionBuilder.processUnsignedTransaction({
                extendedUtxo,
                targets: receivers,
                changeAddress: signerInfo.address,
                feeRate,
                fullAmount,
            });
            return unsignedTx;
        });
    }
    sendBTCUnsignedTx(receiver, amountInSatoshi, signerInfo, fee = "normal", staticExtendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendBTCToMultipleAddressUnsignedTx([{ address: receiver, value: amountInSatoshi === "all" ? 0 : amountInSatoshi }], signerInfo, fee, staticExtendedUtxo, amountInSatoshi === "all");
        });
    }
    sendSignedTx(signedTx) {
        return __awaiter(this, void 0, void 0, function* () {
            let txId = yield this.btcInterface.sendRawTransaction(signedTx);
            return txId;
        });
    }
    sendSignedPsbt(signedPsbt) {
        return __awaiter(this, void 0, void 0, function* () {
            let signedTx = this.signer.finalizePsbts([signedPsbt]);
            let txId = yield this.sendSignedTx(signedTx);
            return txId;
        });
    }
    sendSignedPsbtWithRetry(signedPsbt, { maxTries = 5, retrySleep = 5000 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, tools_1.runWithRetries)(() => this.sendSignedPsbt(signedPsbt), {
                retrySleep,
                maxTries,
            });
        });
    }
    sendMultiSignedPsbt(signedPsbts = []) {
        return __awaiter(this, void 0, void 0, function* () {
            let signedTx = this.signer.finalizePsbts(signedPsbts);
            let txId = yield this.btcInterface.sendRawTransaction(signedTx);
            return txId;
        });
    }
    increaseTransactionFeeUnsignedPsbt(txId, signerInfos, extraExtendedUtxo, changeAddress, staticFeeRate) {
        return __awaiter(this, void 0, void 0, function* () {
            let transaction = yield this.btcInterface.apiProvider.getTransaction(txId);
            let extendedUtxo = transaction.vin.map((vi) => ({
                signerInfo: signerInfos.find((s) => s.address === vi.address),
                hash: vi.txId,
                value: +vi.value,
                index: vi.index,
            }));
            if (extendedUtxo.find((x) => { var _a; return !((_a = x.signerInfo) === null || _a === void 0 ? void 0 : _a.address); })) {
                throw new Error("signerInfo not match");
            }
            let changeIndex = transaction.vout.findIndex((vo) => transaction.vin.find((vi) => vo.address === vi.address || vo.address === changeAddress));
            const feeRate = staticFeeRate || (yield this.btcInterface.getFeeRate("fast"));
            let targets = transaction.vout
                .filter((_, index) => index !== changeIndex)
                .map((vo) => vo.address
                ? {
                    address: vo.address,
                    value: vo.value,
                }
                : {
                    script: Buffer.from(vo.script, "hex"),
                    value: vo.value,
                });
            return this.transactionBuilder.processUnsignedTransaction({
                extendedUtxo: [...extendedUtxo, ...extraExtendedUtxo],
                targets,
                feeRate,
                changeAddress: changeIndex >= 0 ? transaction.vout[changeIndex].address : changeAddress,
                selectType: "inOrder",
            });
        });
    }
}
exports.BitcoinBaseWallet = BitcoinBaseWallet;
//# sourceMappingURL=bitcoin-wallet-base.js.map