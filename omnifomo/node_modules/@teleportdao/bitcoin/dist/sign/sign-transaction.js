"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const secp256k1_1 = __importDefault(require("@bitcoinerlab/secp256k1"));
const ecpair_1 = __importDefault(require("ecpair"));
const ECPair = (0, ecpair_1.default)(secp256k1_1.default);
function tapTweakHash(pubKey, h) {
    return bitcoinjs_lib_1.crypto.taggedHash("TapTweak", Buffer.concat(h ? [pubKey, h] : [pubKey]));
}
function tweakSigner(privateKey, network, opts = {}) {
    let newPrv = privateKey;
    let keyPair = ECPair.fromPrivateKey(privateKey, {
        network,
        compressed: true,
    });
    if (!keyPair.privateKey)
        throw new Error("private key not exist");
    if (keyPair.publicKey.toString("hex").startsWith("03")) {
        newPrv = secp256k1_1.default.privateNegate(keyPair.privateKey);
    }
    const tweakedPrivateKey = secp256k1_1.default.privateAdd(newPrv, tapTweakHash(Buffer.from(keyPair.publicKey.toString("hex").slice(2), "hex"), opts === null || opts === void 0 ? void 0 : opts.tweakHash));
    if (!tweakedPrivateKey) {
        throw new Error("Invalid tweaked private key!");
    }
    return ECPair.fromPrivateKey(Buffer.from(tweakedPrivateKey), {
        network,
    });
}
class BitcoinLikeSignTransaction {
    constructor(network) {
        this.network = network;
    }
    signPsbt(unsignedPsbt, privateKey, sighashTypes, usingTweakSignerIfNeeded = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const { network } = this;
            const keyPair = ECPair.fromPrivateKey(privateKey, {
                network,
                compressed: true,
            });
            const psbt = bitcoinjs_lib_1.Psbt.fromBase64(unsignedPsbt.unsignedTransaction, {
                network,
            });
            let numberOfInputs = psbt.inputCount;
            for (let i = 0; i < numberOfInputs; i += 1) {
                if (unsignedPsbt.inputsToSign && !unsignedPsbt.inputsToSign.includes(i)) {
                    continue;
                }
                let type = psbt.getInputType(i);
                if (usingTweakSignerIfNeeded && type === "nonstandard") {
                    console.log("using tweak signer");
                    let a = tweakSigner(privateKey, this.network);
                    yield psbt.signInputAsync(i, a, sighashTypes);
                }
                else {
                    yield psbt.signInputAsync(i, keyPair, sighashTypes);
                }
            }
            const partialSigendPsbt = psbt.toBase64();
            return partialSigendPsbt;
        });
    }
    finalizePsbts(psbtsBase64 = []) {
        const finals = psbtsBase64.map((psbtBase64) => bitcoinjs_lib_1.Psbt.fromBase64(psbtBase64, { network: this.network }));
        const psbt = finals.length === 1 ? finals[0] : new bitcoinjs_lib_1.Psbt({ network: this.network }).combine(...finals);
        psbt.finalizeAllInputs();
        let finalizeTx = psbt.extractTransaction();
        return finalizeTx.toHex();
    }
}
exports.default = BitcoinLikeSignTransaction;
//# sourceMappingURL=sign-transaction.js.map