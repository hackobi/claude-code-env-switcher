"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ordinal_transaction_builder_1 = require("./transaction-builder/ordinal-transaction-builder");
const sign_transaction_1 = __importDefault(require("./sign/sign-transaction"));
const bitcoin_interface_ordinal_1 = require("./bitcoin-interface-ordinal");
const brc20_helper_1 = require("./helper/brc20-helper");
const tools_1 = require("./utils/tools");
const bitcoin_wallet_base_1 = require("./bitcoin-wallet-base");
class OrdinalWallet extends bitcoin_wallet_base_1.BitcoinBaseWallet {
    constructor(networkName, uniSatToken, connectionInfo) {
        if (!connectionInfo.rpc) {
            throw new Error("rpc is required");
        }
        super(networkName, connectionInfo);
        this.transactionBuilder = new ordinal_transaction_builder_1.OrdinalTransactionBuilder(networkName, this.network, connectionInfo);
        this.signer = new sign_transaction_1.default(this.network);
        this.btcInterface = new bitcoin_interface_ordinal_1.BitcoinInterfaceOrdinal(connectionInfo, networkName, uniSatToken);
        this.unisat = this.btcInterface.unisat;
    }
    static deployBRC20Data(tickName, max, limit) {
        let data = {
            p: "brc-20",
            op: "deploy",
            tick: tickName,
            max: `${max}`,
            lim: `${limit}`,
        };
        return {
            buffer: Buffer.from(JSON.stringify(data), "utf8"),
            type: "text/plain",
        };
    }
    static mintBRC20Data(tickName, amount) {
        if ((0, bignumber_js_1.default)(amount).isLessThanOrEqualTo(0))
            throw new Error("amount should be greater than 0");
        let data = {
            p: "brc-20",
            op: "mint",
            tick: tickName,
            amt: `${amount}`,
        };
        return {
            buffer: Buffer.from(JSON.stringify(data), "utf8"),
            type: "text/plain",
        };
    }
    static transferBRC20Data(tickName, amount) {
        if ((0, bignumber_js_1.default)(amount).isLessThanOrEqualTo(0))
            throw new Error("amount should be greater than 0");
        let data = {
            p: "brc-20",
            op: "transfer",
            tick: tickName,
            amt: `${amount}`,
        };
        return {
            buffer: Buffer.from(JSON.stringify(data), "utf8"),
            type: "text/plain",
        };
    }
    inscribeOrdinalDepositUnsigned(file, signer, ordinalSigner, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            const ordinalSignerPublicKey = (ordinalSigner === null || ordinalSigner === void 0 ? void 0 : ordinalSigner.publicKey) || signer.publicKey;
            const publicKey = Buffer.from(ordinalSignerPublicKey, "hex");
            let transferOrdinal = this.transactionBuilder.createOrdinalAddress(file, publicKey);
            const leafScript = transferOrdinal.redeem.output;
            const { ordinalAddress } = transferOrdinal;
            let feeRate = yield this.getFeeRate(fee);
            let extraFee = +(((400 + leafScript.length) / 4) * feeRate * 1.5).toFixed(0);
            let ordinalAmount = 600;
            let utxo1 = extendedUtxo || (yield this.btcInterface.getBTCUtxo(signer.address, signer));
            let inscribeDepositUnsignedInfo = yield this.sendBTCUnsignedTx(ordinalAddress, ordinalAmount + extraFee, signer, feeRate, utxo1);
            return {
                inscribeDepositUnsignedInfo,
                transferOrdinal,
            };
        });
    }
    inscribeOrdinalUnsigned(file, signer, ordinalSigner, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            const receiverAddress = (ordinalSigner === null || ordinalSigner === void 0 ? void 0 : ordinalSigner.address) || signer.address;
            const { inscribeDepositUnsignedInfo, transferOrdinal } = yield this.inscribeOrdinalDepositUnsigned(file, signer, ordinalSigner, fee, extendedUtxo);
            const { ordinalAddress } = transferOrdinal;
            let ordinalAmount = 600;
            if (!inscribeDepositUnsignedInfo.possibleTxId)
                throw new Error("inscribeDepositUnsignedInfo.possibleTxId is required. inscriber address type is not p2tr");
            let inscribeDeposit = {
                hash: inscribeDepositUnsignedInfo.possibleTxId,
                value: inscribeDepositUnsignedInfo.outputs[0].value,
                index: 0,
            };
            let inscribeUnsignedInfo = this.transactionBuilder.createInscribeUnsignedTx(transferOrdinal, inscribeDeposit, receiverAddress, ordinalAmount);
            return {
                inscribeDepositUnsignedInfo,
                inscribeUnsignedInfo,
                inscribeAddress: ordinalAddress,
                receiverAddress,
            };
        });
    }
    inscribeOrdinal(file, fee = "normal", extendedUtxo, ordinalReceiverAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.currentAccount || !this.currentAccountType || !this.publicKey || !this.privateKey) {
                throw new Error("account not initialized");
            }
            const receiverAddress = ordinalReceiverAddress || this.bitcoinAddress;
            const { inscribeDepositUnsignedInfo, transferOrdinal } = yield this.inscribeOrdinalDepositUnsigned(file, this.signerInfo, undefined, fee, extendedUtxo);
            let ordinalUtxo = yield this.btcInterface.getBTCUtxo(transferOrdinal.ordinalAddress, this.signerInfo);
            let inscribeDeposit;
            if (ordinalUtxo.length > 1) {
                throw new Error("multiple deposit found for this ordinal address");
            }
            if (ordinalUtxo.length === 0 ||
                ordinalUtxo[0].value <
                    inscribeDepositUnsignedInfo.outputs[0].value -
                        inscribeDepositUnsignedInfo.outputs[0].value * 0.15) {
                const signedPsbt1 = yield this.signer.signPsbt(inscribeDepositUnsignedInfo, this.privateKey);
                console.log("inscribe deposit tx ...");
                const inscribeDepositTxId = yield this.sendSignedPsbt(signedPsbt1);
                console.log(`inscribe deposit txId : ${inscribeDepositTxId}`);
                inscribeDeposit = {
                    hash: inscribeDepositTxId,
                    value: inscribeDepositUnsignedInfo.outputs[0].value,
                    index: 0,
                    inputs: inscribeDepositUnsignedInfo.inputs,
                    change: inscribeDepositUnsignedInfo.change,
                    changeIndex: inscribeDepositUnsignedInfo.change
                        ? inscribeDepositUnsignedInfo.outputs.length
                        : undefined,
                };
            }
            else {
                inscribeDeposit = {
                    hash: ordinalUtxo[0].hash,
                    value: ordinalUtxo[0].value,
                    index: ordinalUtxo[0].index,
                    inputs: [],
                };
                console.log("no need to deposit", inscribeDeposit);
            }
            const ordinalAmount = 600;
            let inscribeUnsignedInfo = this.transactionBuilder.createInscribeUnsignedTx(transferOrdinal, inscribeDeposit, receiverAddress, ordinalAmount);
            const signedPsbt2 = yield this.signer.signPsbt(inscribeUnsignedInfo, this.privateKey, undefined, false);
            console.log("inscribeTxId ...");
            yield (0, tools_1.sleep)(10 * 1000);
            let inscribeTxId = yield this.sendSignedPsbtWithRetry(signedPsbt2);
            console.log("inscribeTxId", inscribeTxId);
            return {
                inscribeTx: { hash: inscribeTxId, index: 0, value: ordinalAmount },
                inscribeDepositTx: inscribeDeposit,
                inscribeAddress: transferOrdinal.ordinalAddress,
            };
        });
    }
    deployBrc20(brc, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = OrdinalWallet.deployBRC20Data(brc.tick, brc.max, brc.limit);
            return this.inscribeOrdinal(file, fee, extendedUtxo);
        });
    }
    mintBrc20(brc, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = OrdinalWallet.mintBRC20Data(brc.tick, brc.amount);
            return this.inscribeOrdinal(file, fee, extendedUtxo);
        });
    }
    inscribeBrc20Unsigned(brc, signer, ordinalSigner, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = OrdinalWallet.transferBRC20Data(brc.tick, brc.amount);
            return this.inscribeOrdinalUnsigned(file, signer, ordinalSigner, fee, extendedUtxo);
        });
    }
    inscribeBrc20(brc, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = OrdinalWallet.transferBRC20Data(brc.tick, brc.amount);
            return this.inscribeOrdinal(file, fee, extendedUtxo);
        });
    }
    transferBrc20Unsigned(receiver, brcInscribeUtxo, signer, ordinalSigner, fee = "normal", extendedUtxo, otherTargets) {
        return __awaiter(this, void 0, void 0, function* () {
            const ordinalSignerInfo = ordinalSigner || signer;
            let utxo = extendedUtxo || (yield this.btcInterface.getBTCUtxo(signer.address, signer));
            let feeRate = yield this.getFeeRate(fee);
            let unsignedTx = yield this.transactionBuilder.createNftPsbt({
                extendedUtxo: utxo,
                nftExtendedUtxo: {
                    hash: brcInscribeUtxo.hash,
                    index: 0,
                    value: brcInscribeUtxo.value,
                    signerInfo: ordinalSignerInfo,
                },
                feeRate,
                receiverAddress: receiver,
                changeAddress: signer.address,
                otherTargets,
            });
            return Object.assign(Object.assign({}, unsignedTx), { possibleTxId: this.transactionBuilder.getUnsignedPsbtTxId(unsignedTx.unsignedTransaction) });
        });
    }
    transferBrc20(receiver, brcInscribeUtxo, fee = "normal", extendedUtxo, otherTargets) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.currentAccount || !this.currentAccountType || !this.publicKey || !this.privateKey) {
                throw new Error("account not initialized");
            }
            let feeRate = yield this.getFeeRate(fee);
            let unsignedTx = yield this.transactionBuilder.createNftPsbt({
                extendedUtxo,
                nftExtendedUtxo: {
                    hash: brcInscribeUtxo.hash,
                    index: 0,
                    value: brcInscribeUtxo.value,
                    signerInfo: this.signerInfo,
                },
                feeRate,
                receiverAddress: receiver,
                changeAddress: this.bitcoinAddress,
                otherTargets,
            });
            let signedTx = yield this.signer.signPsbt(unsignedTx, this.privateKey);
            let finalTransferTxId = yield this.sendSignedPsbtWithRetry(signedTx);
            return {
                hash: finalTransferTxId,
                index: 0,
                value: brcInscribeUtxo.value,
                inputs: unsignedTx.inputs,
                change: unsignedTx.change,
                changeIndex: unsignedTx.change ? unsignedTx.outputs.length : undefined,
            };
        });
    }
    inscribeAndTransferBrc20Unsigned(receiver, brc, signer, ordinalSigner, otherTargets, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            const ordinalSignerInfo = ordinalSigner || signer;
            let brc20Balance = yield this.unisat.getBrc20AddressBalanceForTicker(signer.address, brc.tick);
            if ((0, bignumber_js_1.default)(brc20Balance.transferableBalance).gte(brc.amount)) {
                let transferrableInscription = brc20Balance.transferableInscriptions.find((insc) => insc.data.tick === brc.tick && (0, bignumber_js_1.default)(insc.data.amt).isEqualTo(brc.amount));
                console.log("transferrableInscription", transferrableInscription);
            }
            if ((0, bignumber_js_1.default)(brc20Balance.availableBalanceSafe).isLessThan(brc.amount)) {
                throw new Error("insufficient balance");
            }
            let feeRate = yield this.getFeeRate(fee);
            let utxo1 = extendedUtxo || (yield this.btcInterface.getBTCUtxo(signer.address, signer));
            let utxo2 = [];
            const { inscribeAddress, inscribeDepositUnsignedInfo, inscribeUnsignedInfo } = yield this.inscribeBrc20Unsigned(brc, signer, ordinalSignerInfo, feeRate, utxo1);
            utxo2 = utxo1.filter((u) => inscribeDepositUnsignedInfo.inputs.findIndex((i) => i.hash === u.hash && i.index === u.index) === -1);
            if (inscribeDepositUnsignedInfo.change) {
                if (!inscribeDepositUnsignedInfo.possibleTxId) {
                    throw new Error("inscribeDepositUnsignedInfo.possibleTxId is required");
                }
                utxo2.push({
                    hash: inscribeDepositUnsignedInfo.possibleTxId,
                    index: inscribeDepositUnsignedInfo.outputs.length,
                    value: inscribeDepositUnsignedInfo.change.value,
                    signerInfo: signer,
                });
            }
            let transferTxUnsignedInfo = yield this.transferBrc20Unsigned(receiver, {
                hash: inscribeUnsignedInfo.possibleTxId,
                value: inscribeUnsignedInfo.outputs[0].value,
                index: 0,
            }, signer, ordinalSignerInfo, feeRate, utxo2, otherTargets);
            return {
                inscribeDepositUnsignedInfo,
                inscribeUnsignedInfo,
                transferTxUnsignedInfo,
                inscribeAddress,
            };
        });
    }
    inscribeAndTransferBrc20(receiver, brc, otherTargets, fee = "normal", extendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            let brc20Balance = yield this.unisat.getBrc20AddressBalanceForTicker(this.bitcoinAddress, brc.tick);
            if ((0, bignumber_js_1.default)(brc20Balance.transferableBalance).gte(brc.amount)) {
                let transferrableInscription = brc20Balance.transferableInscriptions.find((insc) => insc.data.tick === brc.tick && (0, bignumber_js_1.default)(insc.data.amt).isEqualTo(brc.amount));
                console.log("transferrableInscription", transferrableInscription);
                if (transferrableInscription) {
                    let ins = yield this.btcInterface.unisat.getInscriptionInfo(transferrableInscription.inscriptionId);
                    if (ins) {
                        let transferTx = yield this.transferBrc20(receiver, {
                            hash: ins.utxo.txid,
                            index: ins.utxo.vout,
                            value: ins.utxo.satoshi,
                        }, yield this.getFeeRate(fee), extendedUtxo ||
                            (yield this.btcInterface.getBTCUtxo(this.bitcoinAddress, this.signerInfo)), otherTargets);
                        return {
                            transferTx,
                        };
                    }
                }
            }
            if ((0, bignumber_js_1.default)(brc20Balance.availableBalanceSafe).isLessThan(brc.amount)) {
                throw new Error(`insufficient balance ${brc20Balance.availableBalanceSafe} ${brc.amount}`);
            }
            let feeRate = yield this.getFeeRate(fee);
            let utxo1 = extendedUtxo || (yield this.btcInterface.getBTCUtxo(this.bitcoinAddress, this.signerInfo));
            let utxo2 = [];
            const { inscribeAddress, inscribeDepositTx, inscribeTx } = yield this.inscribeBrc20(brc, feeRate, utxo1);
            utxo2 = utxo1.filter((u) => inscribeDepositTx.inputs.findIndex((i) => i.hash === u.hash && i.index === u.index) === -1);
            if (inscribeDepositTx.change) {
                utxo2.push({
                    hash: inscribeDepositTx.hash,
                    index: inscribeDepositTx.changeIndex,
                    value: inscribeDepositTx.change.value,
                    signerInfo: this.signerInfo,
                });
            }
            yield (0, tools_1.sleep)(10 * 1000);
            let transferTx = yield this.transferBrc20(receiver, inscribeTx, feeRate, utxo2, otherTargets);
            return {
                inscribeTx,
                inscribeAddress,
                inscribeDepositTx,
                transferTx,
            };
        });
    }
    wrapBrc20Unsigned(recipientAddress, brc, brc20TokenId, signer, lockerAddress, exchange, ordinalSigner, fee = "normal", extendedUtxo, { chainId = 137, appId = exchange ? 1 : 0 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const isExchange = !!exchange;
            let dataHex = (0, brc20_helper_1.generateBrc2OpReturn)({
                chainId,
                appId,
                brc20TokenId,
                inputAmount: (0, bignumber_js_1.default)(brc.amount).multipliedBy(1e18).toFixed(0),
                recipientAddress,
                isExchange,
                outputToken: exchange === null || exchange === void 0 ? void 0 : exchange.outputToken,
                outputAmount: exchange === null || exchange === void 0 ? void 0 : exchange.outputAmount,
            });
            let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex);
            return this.inscribeAndTransferBrc20Unsigned(lockerAddress, brc, signer, ordinalSigner, [opTarget], fee, extendedUtxo);
        });
    }
    wrapBrc20OnlyTransferUnsigned(recipientAddress, brcInscribeTx, brc, brc20TokenId, signer, lockerAddress, exchange, ordinalSigner, fee = "normal", extendedUtxo, { chainId = 137, appId = exchange ? 1 : 0 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxo = extendedUtxo || (yield this.btcInterface.getBTCUtxo(signer.address, signer));
            const isExchange = !!exchange;
            let dataHex = (0, brc20_helper_1.generateBrc2OpReturn)({
                chainId,
                appId,
                brc20TokenId,
                inputAmount: (0, bignumber_js_1.default)(brc.amount).multipliedBy(1e18).toFixed(0),
                recipientAddress,
                isExchange,
                outputToken: exchange === null || exchange === void 0 ? void 0 : exchange.outputToken,
                outputAmount: exchange === null || exchange === void 0 ? void 0 : exchange.outputAmount,
            });
            let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex);
            let feeRate = yield this.getFeeRate(fee);
            let transferTxUnsignedInfo = yield this.transferBrc20Unsigned(lockerAddress, brcInscribeTx, signer, ordinalSigner, feeRate, utxo, [opTarget]);
            return transferTxUnsignedInfo;
        });
    }
    wrapBrc20(recipientAddress, brc, brc20TokenId, lockerAddress, exchange, fee = "normal", extendedUtxo, { chainId = 137, appId = exchange ? 1 : 0 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const isExchange = !!exchange;
            let dataHex = (0, brc20_helper_1.generateBrc2OpReturn)({
                chainId,
                appId,
                brc20TokenId,
                inputAmount: (0, bignumber_js_1.default)(brc.amount).multipliedBy(1e18).toFixed(0),
                recipientAddress,
                isExchange,
                outputToken: exchange === null || exchange === void 0 ? void 0 : exchange.outputToken,
                outputAmount: exchange === null || exchange === void 0 ? void 0 : exchange.outputAmount,
            });
            let opTarget = this.transactionBuilder.getOpReturnTarget(dataHex);
            return this.inscribeAndTransferBrc20(lockerAddress, brc, [opTarget], fee, extendedUtxo);
        });
    }
}
exports.default = OrdinalWallet;
//# sourceMappingURL=ordinal-wallet.js.map