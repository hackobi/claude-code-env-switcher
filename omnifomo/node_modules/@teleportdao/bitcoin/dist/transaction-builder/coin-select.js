"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.coinSelectAll = exports.coinSelectAccumulative = exports.coinSelectBnB = exports.calculateTxSize = exports.getOutputSize = exports.getInputSize = exports.DUST = exports.componentBytes = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bitcoin_utils_1 = require("../bitcoin-utils");
exports.componentBytes = {
    bytePerInput: {
        p2pkh: 152,
        p2wpkh: 72,
        "p2sh-p2wpkh": 96,
        p2tr: 62,
        default: 100,
    },
    baseTxBytes: 10 + 5,
    bytePerOutput: {
        p2pkh: 34,
        p2wpkh: 31,
        p2sh: 32,
        p2tr: 43,
        p2wsh: 44,
        default: 35,
        max: 45,
    },
    scriptExtraBytes: {
        lessThan255: 12,
        moreThan255: 15,
    },
};
exports.DUST = 600;
function getInputSize(addressType, details) {
    let { m = 3 } = details || {};
    const n = (details === null || details === void 0 ? void 0 : details.n) || m || 2;
    if (addressType === "p2sh") {
        return 46 + 74 * n + 34 * m;
    }
    if (addressType === "p2sh-p2wsh") {
        return +((306 + 76 * n + 34 * m) / 4).toFixed();
    }
    if (addressType === "p2wsh") {
        return +((166 + 76 * n + 34 * m) / 4).toFixed();
    }
    return (exports.componentBytes.bytePerInput[addressType] ||
        exports.componentBytes.bytePerInput.default);
}
exports.getInputSize = getInputSize;
function getOutputSize(output, network = bitcoin.networks.bitcoin) {
    if (output.addressType) {
        return (exports.componentBytes.bytePerOutput[output.addressType] || exports.componentBytes.bytePerOutput.default);
    }
    if (output.address) {
        let addressType = "max";
        try {
            addressType = (0, bitcoin_utils_1.getAddressType)(output.address, network);
        }
        catch (_a) {
            addressType = "max";
        }
        return (exports.componentBytes.bytePerOutput[addressType] ||
            exports.componentBytes.bytePerOutput.max);
    }
    if (output.script) {
        if (output.script.byteLength < 255) {
            return output.script.byteLength + exports.componentBytes.scriptExtraBytes.lessThan255;
        }
        return output.script.byteLength + exports.componentBytes.scriptExtraBytes.moreThan255;
    }
    throw new Error("invalid output");
}
exports.getOutputSize = getOutputSize;
function calculateTxSize(inputTypes, outputs, changeAddressType = "default", network = bitcoin.networks.bitcoin) {
    const inputsSizes = inputTypes.map(({ addressType, n, m }) => getInputSize(addressType, { n, m }));
    const outputSizes = outputs.map((outP) => {
        if (!outP.address && !outP.script) {
            return getOutputSize({
                addressType: changeAddressType,
            }, network);
        }
        return getOutputSize(outP, network);
    });
    const txSize = exports.componentBytes.baseTxBytes +
        inputsSizes.reduce((a, c) => a + c, 0) +
        outputSizes.reduce((a, c) => a + c, 0);
    return txSize;
}
exports.calculateTxSize = calculateTxSize;
function sumValues(outputs) {
    return outputs.reduce((sum, o) => sum + o.value, 0);
}
function fixNumberToInteger(value) {
    return Math.ceil(value);
}
function coinSelectBnB(inputs, outputs, feeRate, changeAddressType = "max", network = bitcoin.networks.bitcoin) {
    const sortedInputs = [...inputs].sort((a, b) => b.value - a.value);
    const totalOutputValue = sumValues(outputs);
    const totalOutputFee = fixNumberToInteger(outputs.reduce((sum, o) => sum + getOutputSize(o, network) * feeRate, 0));
    const totalOutputValueWithFee = totalOutputValue + totalOutputFee;
    const changeFee = fixNumberToInteger(getOutputSize({ addressType: changeAddressType }, network) * feeRate);
    const baseTxFee = fixNumberToInteger(exports.componentBytes.baseTxBytes * feeRate);
    let bestWaste = Infinity;
    let bestSelection = null;
    function bnb(idx, selected) {
        const selectedValue = sumValues(selected);
        const totalInputFee = selected.length > 0
            ? fixNumberToInteger(selected.reduce((sum, i) => {
                var _a;
                return sum +
                    getInputSize(i.signerInfo.addressType, {
                        n: i.signerInfo.numberOfSigners,
                        m: (_a = i.signerInfo.publicKeys) === null || _a === void 0 ? void 0 : _a.length,
                    }) *
                        feeRate;
            }, 0))
            : 0;
        let totalNeeded = totalInputFee + totalOutputValueWithFee + baseTxFee;
        if (selectedValue - totalNeeded > exports.DUST) {
            totalNeeded = totalNeeded + changeFee;
        }
        if (selectedValue > totalNeeded + bestWaste)
            return;
        if (selectedValue >= totalNeeded) {
            const waste = selectedValue - totalNeeded;
            if (waste < bestWaste) {
                bestWaste = waste;
                bestSelection = selected.slice();
            }
            return;
        }
        if (idx >= sortedInputs.length)
            return;
        bnb(idx + 1, [...selected, sortedInputs[idx]]);
        bnb(idx + 1, selected);
    }
    bnb(0, []);
    const selected = bestSelection || inputs;
    const selectedValue = sumValues(selected);
    const totalInputFee = selected.length > 0
        ? fixNumberToInteger(selected.reduce((sum, i) => {
            var _a;
            return sum +
                getInputSize(i.signerInfo.addressType, {
                    n: i.signerInfo.numberOfSigners,
                    m: (_a = i.signerInfo.publicKeys) === null || _a === void 0 ? void 0 : _a.length,
                }) *
                    feeRate;
        }, 0))
        : 0;
    let totalNeeded = totalInputFee + totalOutputValueWithFee + baseTxFee;
    let change;
    if (!bestSelection) {
        return {
            success: false,
            inputs,
            outputs,
            fee: totalInputFee + totalOutputFee + baseTxFee,
            totalInputValue: selectedValue,
            totalOutputValue,
            needed: selectedValue - totalNeeded,
        };
    }
    if (selectedValue - totalNeeded > exports.DUST) {
        totalNeeded = totalNeeded + changeFee;
        change = { value: selectedValue - totalNeeded };
    }
    const changeValue = (change === null || change === void 0 ? void 0 : change.value) || 0;
    return {
        success: true,
        inputs: bestSelection,
        outputs,
        change,
        fee: selectedValue - totalOutputValue - changeValue,
        totalInputValue: selectedValue,
        totalOutputValue: totalOutputValue + changeValue,
        needed: 0,
    };
}
exports.coinSelectBnB = coinSelectBnB;
function coinSelectAccumulative(inputs, outputs, feeRate, changeAddressType = "max", network = bitcoin.networks.bitcoin, minInputAggregate = {
    minInputCount: 1,
    maxInputValue: Infinity,
}) {
    const totalOutputValue = sumValues(outputs);
    const totalOutputFee = fixNumberToInteger(outputs.reduce((sum, o) => sum + getOutputSize(o, network) * feeRate, 0));
    const totalOutputValueWithFee = totalOutputValue + totalOutputFee;
    const changeFee = fixNumberToInteger(getOutputSize({ addressType: changeAddressType }, network) * feeRate);
    const baseTxFee = fixNumberToInteger(exports.componentBytes.baseTxBytes * feeRate);
    const selected = [];
    let change;
    for (let index = 0; index <= inputs.length; index += 1) {
        const input = inputs[index];
        const selectedValue = sumValues(selected);
        const totalInputFee = selected.length > 0
            ? fixNumberToInteger(selected.reduce((sum, i) => {
                var _a;
                return sum +
                    getInputSize(i.signerInfo.addressType, {
                        n: i.signerInfo.numberOfSigners,
                        m: (_a = i.signerInfo.publicKeys) === null || _a === void 0 ? void 0 : _a.length,
                    }) *
                        feeRate;
            }, 0))
            : 0;
        let totalNeeded = totalInputFee + totalOutputValueWithFee + baseTxFee;
        if (selectedValue - totalNeeded > exports.DUST) {
            totalNeeded = totalNeeded + changeFee;
            change = { value: selectedValue - totalNeeded };
        }
        if (selectedValue >= totalNeeded) {
            if (+index === inputs.length ||
                selected.length >= minInputAggregate.minInputCount ||
                input.value >= minInputAggregate.maxInputValue) {
                break;
            }
        }
        if (+index === inputs.length) {
            return {
                success: false,
                inputs,
                outputs,
                fee: totalInputFee + totalOutputFee + baseTxFee,
                totalInputValue: selectedValue,
                totalOutputValue,
                needed: selectedValue - totalNeeded,
            };
        }
        selected.push(input);
    }
    const selectedValue = sumValues(selected);
    const changeValue = (change === null || change === void 0 ? void 0 : change.value) || 0;
    return {
        success: true,
        inputs: selected,
        outputs,
        change,
        fee: selectedValue - totalOutputValue - changeValue,
        totalInputValue: selectedValue,
        totalOutputValue: totalOutputValue + changeValue,
        needed: 0,
    };
}
exports.coinSelectAccumulative = coinSelectAccumulative;
function coinSelectAll(inputs, targets, feeRate, changeAddressType = "max", network = bitcoin.networks.bitcoin) {
    if (!targets[0].address) {
        throw new Error("target address is required");
    }
    let newOutputs = [];
    const changeFee = fixNumberToInteger(getOutputSize({ addressType: changeAddressType }, network) * feeRate);
    const baseTxFee = fixNumberToInteger(exports.componentBytes.baseTxBytes * feeRate);
    const selected = inputs;
    const selectedValue = sumValues(selected);
    const totalInputFee = selected.length > 0
        ? fixNumberToInteger(selected.reduce((sum, i) => {
            var _a;
            return sum +
                getInputSize(i.signerInfo.addressType, {
                    n: i.signerInfo.numberOfSigners,
                    m: (_a = i.signerInfo.publicKeys) === null || _a === void 0 ? void 0 : _a.length,
                }) *
                    feeRate;
        }, 0))
        : 0;
    let totalNeeded = totalInputFee + changeFee + baseTxFee;
    if (selectedValue - totalNeeded > exports.DUST) {
        newOutputs.push({
            address: targets[0].address,
            value: selectedValue - totalNeeded,
        });
    }
    else {
        return {
            success: false,
            inputs,
            outputs: [],
            fee: totalNeeded,
            totalInputValue: selectedValue,
            totalOutputValue: 0,
            needed: selectedValue - totalNeeded,
            change: undefined,
        };
    }
    const totalOutputValue = sumValues(newOutputs);
    return {
        success: true,
        inputs,
        outputs: newOutputs,
        change: undefined,
        fee: selectedValue - totalOutputValue,
        totalInputValue: selectedValue,
        totalOutputValue,
        needed: 0,
    };
}
exports.coinSelectAll = coinSelectAll;
if (require.main === module) {
    const utxos = [
        {
            signerInfo: { address: "A", publicKey: "", addressType: "p2pkh" },
            hash: "h1",
            value: 50000,
            index: 0,
        },
        {
            signerInfo: { address: "B", publicKey: "", addressType: "p2pkh" },
            hash: "h2",
            value: 30000,
            index: 1,
        },
        {
            signerInfo: { address: "C", publicKey: "", addressType: "p2pkh" },
            hash: "h3",
            value: 4000,
            index: 2,
        },
        {
            signerInfo: { address: "D", publicKey: "", addressType: "p2pkh" },
            hash: "h4",
            value: 10000,
            index: 3,
        },
    ];
    const outputs = [
        { address: "X", value: 40000 },
        { address: "Y", value: 15000 },
    ];
    const outputs2 = [
        { address: "X", value: 40000 },
        { address: "Y", value: 2484 },
        { address: "Z", value: 50000 },
    ];
    const feeRate = 2;
    console.log("Coin selection result:", coinSelectBnB(utxos, outputs, feeRate));
    console.log("Coin selection result:", coinSelectAccumulative(utxos, outputs, feeRate));
    console.log("Coin selection result:", coinSelectAll(utxos, outputs, feeRate));
    console.log("Selection failed:", coinSelectBnB(utxos, outputs2, feeRate));
    console.log("Selection failed:", coinSelectAccumulative(utxos, outputs2, feeRate));
}
//# sourceMappingURL=coin-select.js.map