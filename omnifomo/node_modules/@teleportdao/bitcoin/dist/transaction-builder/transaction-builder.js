"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransactionBuilder = exports.DUST = exports.componentBytes = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bitcoin_utils_1 = require("../bitcoin-utils");
const coinselect = require("coinselect");
const coinselectSplit = require("coinselect/split");
const coinselectAccumulative = require("coinselect/accumulative");
exports.componentBytes = {
    bytePerInput: {
        p2pkh: 148,
        p2wpkh: 68,
        "p2sh-p2wpkh": 91,
        p2tr: 58,
        default: 100,
    },
    baseTxBytes: 10 + 5,
    bytePerOutput: {
        p2pkh: 34,
        p2wpkh: 31,
        p2sh: 32,
        p2tr: 43,
        default: 35,
        max: 45,
    },
    scriptExtraBytes: {
        lessThan255: 12,
        moreThan255: 15,
    },
};
exports.DUST = 1000;
function coinSelectInOrder(utxos, outputs, feeRate) {
    let response = coinselectAccumulative(utxos, outputs, 1);
    return Object.assign(Object.assign({}, response), { fee: +(+response.fee * feeRate).toFixed() });
}
class BaseTransactionBuilder {
    constructor({ network, testnet, feeMin = 0, dustLimit, maximumNumberOfOutputsInTransaction = 50, }) {
        this.NO_RBF_SEQUENCE = 0xffffffff;
        this.testnet = testnet;
        this.network = network;
        this.maximumNumberOfOutputsInTransaction = maximumNumberOfOutputsInTransaction;
        this.feeMin = feeMin;
        this.dustLimit = dustLimit || 1 * 2 * exports.componentBytes.bytePerInput.p2pkh;
    }
    createAddressObject(input) {
        return (0, bitcoin_utils_1.createAddressObjectByPublicKey)(input, this.network);
    }
    validateAddress(address) {
        try {
            (0, bitcoin_utils_1.getAddressType)(address, this.network);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    getOpReturnTarget(dataHex) {
        if (!(dataHex.length > 0))
            throw new Error("invalid data in hex");
        const embed = bitcoin.payments.embed({
            data: [Buffer.from(dataHex, "hex")],
            network: this.network,
        });
        return {
            script: embed.output,
            value: 0,
        };
    }
    calculateTxSize(inputTypes, outputs, changeAddressType = "default") {
        const inputsSizes = inputTypes.map((addressType) => exports.componentBytes.bytePerInput[addressType]);
        const outputSizes = outputs.map((outP) => {
            if (outP.address) {
                let addressType = "default";
                try {
                    addressType = (0, bitcoin_utils_1.getAddressType)(outP.address, this.network);
                }
                catch (_a) {
                    addressType = "default";
                }
                return exports.componentBytes.bytePerOutput[addressType];
            }
            if (outP.script) {
                if (outP.script.byteLength < 255) {
                    return outP.script.byteLength + exports.componentBytes.scriptExtraBytes.lessThan255;
                }
                return outP.script.byteLength + exports.componentBytes.scriptExtraBytes.moreThan255;
            }
            return exports.componentBytes.bytePerOutput[changeAddressType];
        });
        const txSize = exports.componentBytes.baseTxBytes +
            inputsSizes.reduce((a, c) => a + c, 0) +
            outputSizes.reduce((a, c) => a + c, 0);
        return txSize;
    }
    helperHandleInputsAndOutputs({ targets, extendedUtxo, feeRate, changeObject, selectType = "normal", }) {
        const filteredUtxo = extendedUtxo.filter((u) => u.value >
            +feeRate *
                exports.componentBytes.bytePerInput[u.signerInfo.addressType]);
        let selectResponse;
        switch (selectType) {
            case "normal":
                selectResponse = coinselect(filteredUtxo, targets, Math.round(feeRate));
                break;
            case "accumulative":
                selectResponse = coinselectAccumulative(filteredUtxo, targets, Math.round(feeRate));
                break;
            case "inOrder":
                selectResponse = coinSelectInOrder(filteredUtxo, targets, Math.round(feeRate));
                break;
            case "full":
                if (!targets[0].address) {
                    throw new Error();
                }
                selectResponse = coinselectSplit(filteredUtxo, [{ address: targets[0].address }], Math.round(feeRate));
                break;
            default:
                break;
        }
        let { inputs, outputs, fee, } = selectResponse;
        if (!inputs || !outputs) {
            inputs = filteredUtxo;
            outputs = targets;
            fee = inputs.reduce((a, b) => a + b.value, 0) - outputs.reduce((a, b) => a + b.value, 0);
        }
        let changeAddressType = "default";
        try {
            changeAddressType = (0, bitcoin_utils_1.getAddressType)((changeObject === null || changeObject === void 0 ? void 0 : changeObject.address) || "", this.network);
        }
        catch (_a) {
            changeAddressType = "default";
        }
        const txSize = this.calculateTxSize(inputs.map((i) => i.signerInfo.addressType), outputs, changeAddressType) + exports.componentBytes.bytePerOutput.default;
        let txFee = Math.round(txSize * feeRate);
        if (Math.round(feeRate) === 1) {
            txFee = Math.round(txFee + txFee * 0.1);
        }
        if (inputs.reduce((a, b) => a + b.value, 0) -
            outputs.filter((o) => o.address || o.script).reduce((a, b) => a + b.value, 0) -
            txFee <
            0) {
            let spendableBalance = inputs.reduce((a, b) => a + b.value, 0);
            let totalOutputAmount = outputs
                .filter((o) => o.address || o.script)
                .reduce((a, b) => a + b.value, 0);
            let need = spendableBalance - totalOutputAmount - txFee;
            throw new Error(`not enough balance. details: ${JSON.stringify({ spendableBalance, totalOutputAmount, txFee, need }, null, 2)}`);
        }
        let diff = fee - txFee;
        let changeIndex = outputs.findIndex((x) => !(x === null || x === void 0 ? void 0 : x.address) && !x.script && (x.value || 0) > 0);
        let change;
        if (changeIndex >= 0 || diff > exports.DUST) {
            if (changeIndex >= 0) {
                diff = diff + exports.componentBytes.bytePerOutput.default * Math.round(feeRate);
            }
            if (diff < 0) {
                diff = 0;
            }
            if (selectType === "full") {
                outputs[0].value = outputs[0].value + diff;
                fee = fee - diff;
            }
            else {
                if (!changeObject)
                    throw new Error("change not exist");
                change = {
                    address: changeObject.address,
                    value: changeIndex >= 0 ? outputs[changeIndex].value + diff : diff,
                };
                fee = fee - diff;
            }
            if (changeIndex >= 0) {
                outputs.splice(changeIndex, 1);
            }
        }
        return {
            inputs,
            fee,
            outputs: outputs,
            change,
        };
    }
    filterAndConvertTxDataToStandardFormat({ extendedUtxo, targets, changeObject, feeRate, selectType, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let { inputs: filteredInputs, outputs, change, fee, } = this.helperHandleInputsAndOutputs({
                targets,
                extendedUtxo,
                feeRate,
                changeObject,
                selectType,
            });
            let inputs = yield this.convertExtendedUtxoToInputs(filteredInputs);
            return {
                inputs,
                outputs,
                change,
                fee,
                feeRate,
            };
        });
    }
    convertExtendedUtxoToInputs(baseInputs = []) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let inputs = baseInputs;
            const transactionHex = {};
            for (let i in inputs) {
                let { address, publicKey, derivationPath, masterFingerprint, addressType } = inputs[i].signerInfo;
                let addressObject = this.createAddressObject({
                    publicKey: Buffer.from(publicKey, "hex"),
                    addressType,
                });
                if (derivationPath && masterFingerprint && addressObject.pubkey) {
                    inputs[i].bip32Derivation = [
                        {
                            path: derivationPath,
                            pubkey: addressObject.pubkey,
                            masterFingerprint: Buffer.from(masterFingerprint, "hex"),
                        },
                    ];
                }
                if (addressType === "p2pkh") {
                    const txHex = transactionHex[inputs[i].hash] || (yield this._getTransactionHex(inputs[i].hash));
                    transactionHex[inputs[i].hash] = txHex;
                    inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex");
                }
                else if (addressType === "p2wpkh") {
                    if (!addressObject.output)
                        throw new Error("invalid signer info");
                    inputs[i].witnessUtxo = {
                        script: addressObject.output,
                        value: inputs[i].value,
                    };
                    if (inputs[i].signerInfo.includeHex) {
                        const txHex = transactionHex[inputs[i].hash] || (yield this._getTransactionHex(inputs[i].hash));
                        transactionHex[inputs[i].hash] = txHex;
                        inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex");
                    }
                }
                else if (addressType === "p2sh-p2wpkh") {
                    if (!addressObject.output)
                        throw new Error("invalid signer info");
                    inputs[i].witnessUtxo = {
                        script: addressObject.output,
                        value: inputs[i].value,
                    };
                    if (!((_a = addressObject === null || addressObject === void 0 ? void 0 : addressObject.redeem) === null || _a === void 0 ? void 0 : _a.output))
                        throw new Error("invalid signer info for p2sh address");
                    inputs[i].redeemScript = addressObject.redeem.output;
                    if (inputs[i].signerInfo.includeHex) {
                        const txHex = transactionHex[inputs[i].hash] || (yield this._getTransactionHex(inputs[i].hash));
                        transactionHex[inputs[i].hash] = txHex;
                        inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex");
                    }
                }
                else if (addressType === "p2tr") {
                    if (!addressObject.output)
                        throw new Error("invalid signer info");
                    inputs[i].witnessUtxo = {
                        script: addressObject.output,
                        value: inputs[i].value,
                    };
                    if (!addressObject.pubkey)
                        throw new Error("invalid signer info for p2tr address (pubkey)");
                    inputs[i].tapInternalKey = addressObject.internalPubkey;
                    if (inputs[i].signerInfo.includeHex) {
                        const txHex = transactionHex[inputs[i].hash] || (yield this._getTransactionHex(inputs[i].hash));
                        transactionHex[inputs[i].hash] = txHex;
                        inputs[i].nonWitnessUtxo = Buffer.from(txHex, "hex");
                    }
                }
            }
            return inputs;
        });
    }
    createUnsignedTransaction({ inputs, outputs, change, fee, feeRate, sequenceNumber, }) {
        const sequence = sequenceNumber || this.NO_RBF_SEQUENCE - 2;
        const { network } = this;
        const newPsbt = new bitcoin.Psbt({ network });
        newPsbt.setMaximumFeeRate(+(feeRate + feeRate / 100).toFixed());
        for (const input of inputs) {
            let { addressType } = input.signerInfo;
            switch (addressType) {
                case "p2pkh": {
                    let i = {
                        hash: input.hash,
                        index: Number(input.index),
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        sequence,
                        bip32Derivation: input.bip32Derivation,
                    };
                    if (!i.bip32Derivation)
                        delete i.bip32Derivation;
                    newPsbt.addInput(i);
                    break;
                }
                case "p2wpkh": {
                    let i = {
                        hash: input.hash,
                        index: Number(input.index),
                        witnessUtxo: input.witnessUtxo,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        sequence,
                        bip32Derivation: input.bip32Derivation,
                    };
                    if (!i.bip32Derivation)
                        delete i.bip32Derivation;
                    if (!i.nonWitnessUtxo)
                        delete i.nonWitnessUtxo;
                    newPsbt.addInput(i);
                    break;
                }
                case "p2sh-p2wpkh": {
                    let i = {
                        hash: input.hash,
                        index: Number(input.index),
                        witnessUtxo: input.witnessUtxo,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        redeemScript: input.redeemScript,
                        sequence,
                        bip32Derivation: input.bip32Derivation,
                    };
                    if (!i.bip32Derivation)
                        delete i.bip32Derivation;
                    if (!i.nonWitnessUtxo)
                        delete i.nonWitnessUtxo;
                    newPsbt.addInput(i);
                    break;
                }
                case "p2tr": {
                    let i = {
                        hash: input.hash,
                        index: Number(input.index),
                        witnessUtxo: input.witnessUtxo,
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        tapInternalKey: input.tapInternalKey,
                        sequence,
                        bip32Derivation: input.bip32Derivation,
                    };
                    if (!i.bip32Derivation)
                        delete i.bip32Derivation;
                    if (!i.nonWitnessUtxo)
                        delete i.nonWitnessUtxo;
                    newPsbt.addInput(i);
                    break;
                }
                default:
                    throw new Error("address type is incorrect");
            }
        }
        for (const target of outputs) {
            newPsbt.addOutput(target);
        }
        if (change && Object.keys(change).length !== 0) {
            newPsbt.addOutput(change);
        }
        if (change && Object.keys(change).length !== 0) {
            if (newPsbt.txOutputs[outputs.length].address !== change.address) {
                throw new Error("error change address");
            }
        }
        const unsignedPsbtBaseText = newPsbt.toBase64();
        const safeAddressTypeForPossibleTxId = ["p2wpkh", "p2tr"];
        const isPossibleTxId = inputs.reduce((a, b) => a && safeAddressTypeForPossibleTxId.includes(b.signerInfo.addressType), true);
        return {
            unsignedTransaction: unsignedPsbtBaseText,
            outputs,
            inputs: inputs.map((utx) => ({
                hash: utx.hash,
                value: Number(utx.value),
                index: utx.index,
                signerInfo: utx.signerInfo,
            })),
            fee,
            change,
            possibleTxId: isPossibleTxId ? this.getUnsignedPsbtTxId(unsignedPsbtBaseText) : undefined,
        };
    }
    processUnsignedTransaction({ extendedUtxo, targets = [], changeAddress = undefined, fullAmount = false, feeRate, selectType = "normal", sequenceNumber, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!changeAddress && targets.length === 0)
                throw new Error("no target");
            let changeObject = typeof changeAddress === "string"
                ? {
                    address: changeAddress,
                }
                : changeAddress;
            const { inputs, outputs, change, fee } = yield this.filterAndConvertTxDataToStandardFormat({
                extendedUtxo,
                targets,
                changeObject,
                feeRate,
                selectType: fullAmount ? "full" : selectType,
            });
            let unsignedTransaction = this.createUnsignedTransaction({
                inputs,
                outputs,
                change,
                fee,
                feeRate,
                sequenceNumber,
            });
            return unsignedTransaction;
        });
    }
    getUnsignedPsbtTxId(unsignedPsbt) {
        let psbt = bitcoin.Psbt.fromBase64(unsignedPsbt, {
            network: this.network,
        });
        return psbt.__CACHE.__TX.getId();
    }
}
exports.BaseTransactionBuilder = BaseTransactionBuilder;
//# sourceMappingURL=transaction-builder.js.map