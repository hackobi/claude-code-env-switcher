/// <reference types="node" />
import * as bitcoin from "bitcoinjs-lib";
export declare const componentBytes: {
    bytePerInput: {
        p2pkh: number;
        p2wpkh: number;
        "p2sh-p2wpkh": number;
        p2tr: number;
        default: number;
    };
    baseTxBytes: number;
    bytePerOutput: {
        p2pkh: number;
        p2wpkh: number;
        p2sh: number;
        p2tr: number;
        default: number;
        max: number;
    };
    scriptExtraBytes: {
        lessThan255: number;
        moreThan255: number;
    };
};
export declare const DUST = 1000;
export type Utxo = {
    hash: string;
    value: number;
    index: number;
};
export type SignerInfo = {
    address: string;
    publicKey: string;
    addressType: string;
    derivationPath?: string;
    masterFingerprint?: string;
    includeHex?: boolean;
};
export type ExtendedUtxo = {
    signerInfo: SignerInfo;
    hash: string;
    value: number;
    index: number;
};
export type TargetAddress = {
    address: string;
    value: number;
};
export type TargetScript = {
    script: Buffer;
    value: number;
};
export type Target = TargetAddress | TargetScript;
export type ChangeTarget = TargetAddress & {
    bip32Derivation?: {
        path: string;
        pubkey: Buffer;
        masterFingerprint: Buffer;
    }[];
};
export type BitcoinJSInputInfo = ExtendedUtxo & {
    bip32Derivation?: {
        path: string;
        pubkey: Buffer;
        masterFingerprint: Buffer;
    }[];
    nonWitnessUtxo?: Buffer;
    witnessUtxo?: {
        script: Buffer;
        value: number;
    };
    redeemScript?: Buffer;
    tapInternalKey?: Buffer;
};
export type ExtendedUnsignedTransaction = {
    unsignedTransaction: string;
    outputs: Target[];
    inputs: {
        hash: string;
        value: number;
        index: number;
        signerInfo: SignerInfo;
    }[];
    fee: number;
    change: TargetAddress | undefined;
};
export declare abstract class BaseTransactionBuilder {
    testnet: boolean;
    network: bitcoin.Network;
    maximumNumberOfOutputsInTransaction: number;
    feeMin: number;
    dustLimit: number;
    NO_RBF_SEQUENCE: number;
    constructor({ network, testnet, feeMin, dustLimit, maximumNumberOfOutputsInTransaction, }: {
        network: bitcoin.Network;
        testnet: boolean;
        feeMin?: number;
        dustLimit?: number;
        maximumNumberOfOutputsInTransaction?: number;
    });
    abstract _getTransactionHex(transactionId: string): Promise<string>;
    createAddressObject(input: {
        addressType: string;
        publicKey: Buffer;
    }): bitcoin.payments.Payment;
    validateAddress(address: string): boolean;
    getOpReturnTarget(dataHex: string): {
        script: Buffer;
        value: number;
    };
    calculateTxSize(inputTypes: string[], outputs: {
        script?: Buffer;
        address?: string;
        value: number;
    }[], changeAddressType?: string): number;
    helperHandleInputsAndOutputs({ targets, extendedUtxo, feeRate, changeObject, selectType, }: {
        extendedUtxo: ExtendedUtxo[];
        targets: Target[];
        feeRate: number;
        changeObject?: {
            address: string;
            publicKey?: string;
            addressType?: string;
            derivationPath?: string;
            masterFingerprint?: string;
        };
        selectType?: "normal" | "accumulative" | "full" | "inOrder";
    }): {
        inputs: ExtendedUtxo[];
        fee: number;
        outputs: Target[];
        change: ChangeTarget | undefined;
    };
    filterAndConvertTxDataToStandardFormat({ extendedUtxo, targets, changeObject, feeRate, selectType, }: {
        extendedUtxo: ExtendedUtxo[];
        targets: Target[];
        feeRate: number;
        changeObject?: {
            address: string;
            publicKey?: string;
            addressType?: string;
            derivationPath?: string;
            masterFingerprint?: string;
        };
        selectType?: "normal" | "accumulative" | "full" | "inOrder";
    }): Promise<{
        inputs: (ExtendedUtxo & {
            bip32Derivation?: {
                path: string;
                pubkey: Buffer;
                masterFingerprint: Buffer;
            }[] | undefined;
            nonWitnessUtxo?: Buffer | undefined;
            witnessUtxo?: {
                script: Buffer;
                value: number;
            } | undefined;
            redeemScript?: Buffer | undefined;
            tapInternalKey?: Buffer | undefined;
        } & {
            signerInfo: SignerInfo;
        })[];
        outputs: Target[];
        change: ChangeTarget | undefined;
        fee: number;
        feeRate: number;
    }>;
    convertExtendedUtxoToInputs(baseInputs?: ExtendedUtxo[]): Promise<(ExtendedUtxo & {
        bip32Derivation?: {
            path: string;
            pubkey: Buffer;
            masterFingerprint: Buffer;
        }[] | undefined;
        nonWitnessUtxo?: Buffer | undefined;
        witnessUtxo?: {
            script: Buffer;
            value: number;
        } | undefined;
        redeemScript?: Buffer | undefined;
        tapInternalKey?: Buffer | undefined;
    } & {
        signerInfo: SignerInfo;
    })[]>;
    createUnsignedTransaction({ inputs, outputs, change, fee, feeRate, sequenceNumber, }: {
        inputs: BitcoinJSInputInfo[];
        outputs: Target[];
        change?: ChangeTarget;
        fee: number;
        feeRate: number;
        sequenceNumber?: number;
    }): {
        unsignedTransaction: string;
        outputs: Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: ChangeTarget | undefined;
        possibleTxId: string | undefined;
    };
    processUnsignedTransaction({ extendedUtxo, targets, changeAddress, fullAmount, feeRate, selectType, sequenceNumber, }: {
        extendedUtxo: ExtendedUtxo[];
        targets: Target[];
        feeRate: number;
        changeAddress?: string | SignerInfo;
        fullAmount?: boolean;
        selectType?: "normal" | "accumulative" | "full" | "inOrder";
        sequenceNumber?: number;
    }): Promise<{
        unsignedTransaction: string;
        outputs: Target[];
        inputs: {
            hash: string;
            value: number;
            index: number;
            signerInfo: SignerInfo;
        }[];
        fee: number;
        change: ChangeTarget | undefined;
        possibleTxId: string | undefined;
    }>;
    getUnsignedPsbtTxId(unsignedPsbt: string): string;
}
//# sourceMappingURL=transaction-builder.d.ts.map