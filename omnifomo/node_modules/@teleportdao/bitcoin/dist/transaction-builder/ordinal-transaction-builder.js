"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrdinalTransactionBuilder = void 0;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bip341_1 = require("bitcoinjs-lib/src/payments/bip341");
const bitcoin_transaction_builder_1 = require("./bitcoin-transaction-builder");
const ordinal_helper_1 = require("../helper/ordinal-helper");
class OrdinalTransactionBuilder extends bitcoin_transaction_builder_1.BitcoinTransactionBuilder {
    createNftPsbt({ extendedUtxo, nftExtendedUtxo, receiverAddress, feeRate, changeAddress, otherTargets, }) {
        return __awaiter(this, void 0, void 0, function* () {
            let targets = [
                {
                    address: receiverAddress,
                    value: nftExtendedUtxo.value,
                },
            ];
            if (otherTargets)
                targets.push(...otherTargets);
            if (!changeAddress && targets.length === 0)
                throw new Error("no target");
            let changeObject = {
                address: changeAddress,
            };
            let { inputs, outputs, change, fee } = yield this.filterAndConvertTxDataToStandardFormat({
                extendedUtxo: [nftExtendedUtxo, ...extendedUtxo],
                targets,
                changeObject,
                feeRate,
                selectType: "inOrder",
            });
            let unsignedTx = this.createUnsignedTransaction({
                inputs,
                outputs,
                change,
                fee,
                feeRate,
            });
            return unsignedTx;
        });
    }
    createOrdinalAddress(file, publicKey) {
        const internalPublicKey = (0, ordinal_helper_1.toXOnly)(publicKey).toString("hex");
        let leafScript = (0, ordinal_helper_1.getOrdinalScript)(file, internalPublicKey);
        const scriptTree = {
            output: leafScript,
        };
        const redeem = {
            output: leafScript,
            redeemVersion: bip341_1.LEAF_VERSION_TAPSCRIPT,
        };
        const p2trTapOrdinalScript = bitcoin.payments.p2tr({
            internalPubkey: Buffer.from(internalPublicKey, "hex"),
            scriptTree,
            network: this.network,
            redeem,
        });
        let ordinalAddress = p2trTapOrdinalScript.address;
        const controlBlock = p2trTapOrdinalScript.witness[p2trTapOrdinalScript.witness.length - 1];
        return {
            ordinalAddress,
            ordinalScript: p2trTapOrdinalScript.output,
            redeem,
            controlBlock,
        };
    }
    createInscribeUnsignedTx(ordinalSpendDetails, inscribeDeposit, receiverAddress, ordinalAmount = 600) {
        const psbt = new bitcoin.Psbt({ network: this.network })
            .addInput(Object.assign(Object.assign({}, inscribeDeposit), { witnessUtxo: { value: inscribeDeposit.value, script: ordinalSpendDetails.ordinalScript }, tapLeafScript: [
                {
                    leafVersion: ordinalSpendDetails.redeem.redeemVersion,
                    script: ordinalSpendDetails.redeem.output,
                    controlBlock: ordinalSpendDetails.controlBlock,
                },
            ] }))
            .addOutput({
            value: ordinalAmount,
            address: receiverAddress,
        });
        return {
            unsignedTransaction: psbt.toBase64(),
            inputs: [inscribeDeposit],
            outputs: [
                {
                    value: ordinalAmount,
                    address: receiverAddress,
                },
            ],
            fee: inscribeDeposit.value - ordinalAmount,
            possibleTxId: this.getUnsignedPsbtTxId(psbt.toBase64()),
        };
    }
}
exports.OrdinalTransactionBuilder = OrdinalTransactionBuilder;
//# sourceMappingURL=ordinal-transaction-builder.js.map