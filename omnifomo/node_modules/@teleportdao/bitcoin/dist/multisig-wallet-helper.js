"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigWalletHelper = void 0;
const providers_1 = require("@teleportdao/providers");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
class MultisigWalletHelper {
    constructor(baseWallet, coordinatorUrl, coordinatorApiKey, txCounterMonitor = true, acceptableFeeDiffPercentage, txCheckConfig) {
        this.baseWallet = baseWallet;
        this.coordinator = new providers_1.TeleportdaoMultisigCoordinator(coordinatorUrl, coordinatorApiKey);
        this.acceptableFeeDiff = acceptableFeeDiffPercentage || 30;
        this.txCheckConfig = txCheckConfig || {
            sleepTime: 1500,
            maxRetry: 30,
        };
        this.txCounterMonitor = txCounterMonitor;
        this.txCounter = undefined;
    }
    get bitcoinAddress() {
        return this.baseWallet.bitcoinAddress;
    }
    setAccountType(addressType, publicKeys, numberOfSigners) {
        if (!this.baseWallet.publicKey ||
            !publicKeys.includes(this.baseWallet.publicKey.toString("hex"))) {
            throw new Error("public keys not match with the key");
        }
        return this.baseWallet.setAccountType(addressType, {
            publicKeys,
            numberOfSigners,
        });
    }
    setTxCounter(txCounter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.txCounterMonitor)
                this.txCounter = txCounter;
        });
    }
    resetTxCounter() {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = yield this.coordinator.getWallet();
            this.setTxCounter(wallet.txCounter);
            return wallet.txCounter;
        });
    }
    step1SendBTCToMultipleAddressUnsigned(receivers, signerInfo, fee = "normal", staticExtendedUtxo, fullAmount = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let unsignedTx = yield this.baseWallet.sendBTCToMultipleAddressUnsignedTx(receivers, signerInfo, fee, staticExtendedUtxo, fullAmount);
                console.log("this.txCounter step 1 start", this.txCounter);
                let txRequest = yield this.coordinator.createOrConfirmNewTx({
                    inputs: unsignedTx.inputs.map((x) => ({
                        hash: x.hash,
                        index: x.index,
                        value: x.value,
                    })),
                    outputs: unsignedTx.outputs,
                    feeRate: unsignedTx.feeRate,
                    unsignedPsbt: unsignedTx.unsignedTransaction,
                    txCounter: this.txCounter,
                });
                if (txRequest.status !== "Rejected" && txRequest.status !== "Broadcasted") {
                    this.setTxCounter(txRequest.txCounter);
                }
                else {
                    yield this.resetTxCounter();
                }
                console.log("this.txCounter step 1 end", this.txCounter);
                return {
                    txRequest,
                    unsignedTx,
                };
            }
            catch (e) {
                yield this.resetTxCounter();
                throw e;
            }
        });
    }
    step2WaitForUnsignedTxApproval(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const feeRateDiffPercentage = this.acceptableFeeDiff;
            let newUnsignedTx = input.unsignedTx;
            let newTxRequest = input.txRequest;
            if (newTxRequest.status === "Pending") {
                this.setTxCounter(newTxRequest.txCounter);
                if (newTxRequest.unsignedPsbt !== newUnsignedTx.unsignedTransaction) {
                    const feeDiff = (0, bignumber_js_1.default)(newTxRequest.feeRate)
                        .minus(newUnsignedTx.feeRate)
                        .abs()
                        .dividedBy(newUnsignedTx.feeRate);
                    if (!feeDiff.isLessThan(feeRateDiffPercentage / 100)) {
                        const txRequest = yield this.coordinator.rejectTxRequest(newTxRequest.id);
                        this.setTxCounter((this.txCounter || txRequest.txCounter) + 1);
                        throw new Error("Reject because of Invalid FeeRate");
                    }
                    const { signerInfo } = newUnsignedTx.inputs[0];
                    console.log(newUnsignedTx.outputs, newTxRequest.outputs);
                    newUnsignedTx = yield this.baseWallet.sendBTCToMultipleAddressUnsignedTx(newUnsignedTx.outputs, signerInfo, +newTxRequest.feeRate, newTxRequest.inputs.map((x) => (Object.assign(Object.assign({}, x), { signerInfo }))));
                    let updatedTxRequest = yield this.coordinator.confirmOrRejectTxRequest(newTxRequest.id, newUnsignedTx.unsignedTransaction);
                    if (updatedTxRequest.status === "Rejected" ||
                        updatedTxRequest.unsignedPsbt !== newUnsignedTx.unsignedTransaction) {
                        console.log("not equal unsignedPsbt");
                        console.log(updatedTxRequest.unsignedPsbt);
                        console.log(newUnsignedTx.unsignedTransaction);
                        this.setTxCounter((this.txCounter || updatedTxRequest.txCounter) + 1);
                        throw new Error("Reject because of invalid outputs");
                    }
                    newTxRequest = updatedTxRequest;
                }
                const updatedTxRequest = yield this.coordinator.waitTxStatusChange(newTxRequest.id, "Pending", this.txCheckConfig.sleepTime, this.txCheckConfig.maxRetry);
                if (!updatedTxRequest) {
                    yield this.coordinator.rejectTxRequest(newTxRequest.id);
                    if (this.txCounter)
                        this.setTxCounter(this.txCounter + 1);
                    throw new Error("Tx Timeout");
                }
                newTxRequest = updatedTxRequest;
                if (newTxRequest.status === "Rejected") {
                    if (this.txCounter)
                        this.setTxCounter(this.txCounter + 1);
                    throw new Error("Tx Rejected");
                }
            }
            if (newTxRequest.status === "Rejected") {
                yield this.resetTxCounter();
                throw new Error("Tx was Rejected");
            }
            console.log("this.txCounter step 2 end", this.txCounter);
            return {
                unsignedTx: newUnsignedTx,
                txRequest: newTxRequest,
            };
        });
    }
    step3SignTxAndWaitForBroadcast(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.baseWallet.privateKey)
                throw new Error("account is not initialized");
            const { unsignedTx, txRequest } = input;
            let newTxRequest = txRequest;
            if (newTxRequest.status === "Approved") {
                const signed = yield this.baseWallet.signer.signPsbt(unsignedTx, this.baseWallet.privateKey);
                newTxRequest = yield this.coordinator.submitSignedPsbt(newTxRequest.id, signed);
            }
            if (newTxRequest.status === "Approved") {
                if (this.txCounter)
                    this.setTxCounter(newTxRequest.txCounter);
                const finalTx = yield this.coordinator.waitTxStatusChange(newTxRequest.id, "Approved", this.txCheckConfig.sleepTime, this.txCheckConfig.maxRetry);
                if (!finalTx || finalTx.status === "Failed") {
                    throw new Error("Tx not broadcasted for long time");
                }
                newTxRequest = finalTx;
            }
            if (this.txCounter)
                this.setTxCounter(this.txCounter + 1);
            console.log("this.txCounter step3", this.txCounter);
            return newTxRequest;
        });
    }
    sendBTCMultipleAddress(receivers, fee = "normal", staticExtendedUtxo, fullAmount = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.baseWallet.signerInfo || !this.baseWallet.privateKey) {
                throw new Error("account not initialized");
            }
            let unsignedResponse = yield this.step1SendBTCToMultipleAddressUnsigned(receivers, this.baseWallet.signerInfo, fee, staticExtendedUtxo, fullAmount);
            unsignedResponse = yield this.step2WaitForUnsignedTxApproval(unsignedResponse);
            const txRequest = yield this.step3SignTxAndWaitForBroadcast(unsignedResponse);
            return txRequest;
        });
    }
    sendBTC(receiverAddress, amountInSatoshi, fee = "normal", staticExtendedUtxo) {
        return __awaiter(this, void 0, void 0, function* () {
            const txRequest = yield this.sendBTCMultipleAddress([{ address: receiverAddress, value: amountInSatoshi === "all" ? 0 : amountInSatoshi }], fee, staticExtendedUtxo, amountInSatoshi === "all");
            return txRequest;
        });
    }
}
exports.MultisigWalletHelper = MultisigWalletHelper;
//# sourceMappingURL=multisig-wallet-helper.js.map