"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeleswapWallet = void 0;
const configs_1 = require("@teleportdao/configs");
const bitcoin_wallet_base_1 = require("./bitcoin-wallet-base");
const teleswap_helper_1 = require("./helper/teleswap-helper");
class TeleswapWallet extends bitcoin_wallet_base_1.BitcoinBaseWallet {
    wrap(recipientAddress, amount, networkFee, lockerAddress, chainId, exchange, appId = exchange
        ? configs_1.teleswap.requestAppId.WrapAndSwap.default
        : configs_1.teleswap.requestAppId.Wrap.default, speed = false, fee = "normal", thirdPartyId, staticExtendedUtxo, changeAddress, fullAmount = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.signerInfo || !this.privateKey) {
                throw new Error("account not initialized");
            }
            let unsignedTransaction = yield this.wrapUnsigned(recipientAddress, amount, networkFee, lockerAddress, chainId, this.signerInfo, exchange, appId, speed, fee, thirdPartyId, staticExtendedUtxo, changeAddress, fullAmount);
            let signedPsbt = yield this.signer.signPsbt(unsignedTransaction, this.privateKey);
            return this.sendSignedPsbt(signedPsbt);
        });
    }
    wrapUnsigned(recipientAddress, amount, networkFee, lockerAddress, chainId, signer, exchange, appId = exchange
        ? configs_1.teleswap.requestAppId.WrapAndSwap.default
        : configs_1.teleswap.requestAppId.Wrap.default, speed = false, fee = "normal", thirdPartyId, staticExtendedUtxo, changeAddress, fullAmount = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataHex = (0, teleswap_helper_1.generateWrapOpReturn)({
                chainId,
                appId,
                recipientAddress,
                networkFee,
                speed,
                isExchange: !!exchange,
                outputAmount: exchange === null || exchange === void 0 ? void 0 : exchange.outputAmount,
                outputToken: exchange === null || exchange === void 0 ? void 0 : exchange.outputToken,
                bridgePercentageFee: exchange === null || exchange === void 0 ? void 0 : exchange.bridgePercentageFee,
                thirdPartyId,
            });
            let extendedUtxo = staticExtendedUtxo || (yield this.getExtendedUtxo(signer));
            let feeRate = yield this.getFeeRate(fee);
            const targets = fullAmount
                ? [this.transactionBuilder.getOpReturnTarget(dataHex)]
                : [
                    {
                        address: lockerAddress,
                        value: +amount,
                    },
                    this.transactionBuilder.getOpReturnTarget(dataHex),
                ];
            const sequenceNumber = speed === true ? this.transactionBuilder.NO_RBF_SEQUENCE : undefined;
            const unsignedTx = this.transactionBuilder.processUnsignedTransaction({
                extendedUtxo,
                feeRate,
                targets,
                changeAddress: fullAmount ? lockerAddress : changeAddress || signer.address,
                fullAmount,
                sequenceNumber,
            });
            return unsignedTx;
        });
    }
}
exports.TeleswapWallet = TeleswapWallet;
exports.default = TeleswapWallet;
//# sourceMappingURL=teleswap-wallet.js.map