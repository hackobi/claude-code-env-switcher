"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinInterface = void 0;
const tools_1 = require("./utils/tools");
const bitcoin_utils_1 = require("./bitcoin-utils");
const bitcoin_interface_wallet_1 = __importDefault(require("./bitcoin-interface-wallet"));
class BitcoinInterface extends bitcoin_interface_wallet_1.default {
    getLatestBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            let latestHeight = yield (this.rpcProvider || this.apiProvider).getLatestBlockNumber();
            return latestHeight;
        });
    }
    getBlockHash(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let headerHash = yield (0, tools_1.runWithRetries)(() => (this.rpcProvider || this.apiProvider).getBlockHash(blockNumber));
            return headerHash;
        });
    }
    getBlockHeaderHex(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let headerHex = yield (0, tools_1.runWithRetries)(() => (this.rpcProvider || this.apiProvider).getBlockHeaderHex(blockNumber));
            return headerHex;
        });
    }
    getTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.rpcProvider || this.apiProvider).getTransaction(txId);
        });
    }
    getRawTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.rpcProvider || this.apiProvider).getRawTransaction(txId);
        });
    }
    sendRawTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.rpcProvider || this.apiProvider).sendRawTransaction(txId);
        });
    }
    getMerkleProof(txId, blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rpcProvider) {
                return this.apiProvider.getMerkleProof(txId);
            }
            let txIds = yield (0, tools_1.runWithRetries)(() => this.rpcProvider.getBlockTransactionIds(blockHash), {
                maxTries: 5,
                retrySleep: 2000,
            });
            let proof = (0, bitcoin_utils_1.calculateMerkleProof)(txIds, txId);
            return proof;
        });
    }
    getRequestProof(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactionHex = transaction.hex || (yield this.getRawTransaction(transaction.txId));
            let blockHash = transaction.blockHash;
            let blockNumber = transaction.blockNumber;
            if (!(transaction.blockHash && transaction.blockNumber)) {
                let txInfo = yield this.getTransaction(transaction.txId);
                blockHash = txInfo.blockHash;
                blockNumber = txInfo.blockNumber;
            }
            let parsedTx = (0, bitcoin_utils_1.parseRawTransaction)(transactionHex);
            let merkleProof = transaction.merkleProof || (yield this.getMerkleProof(transaction.txId, blockHash));
            return {
                parsedTx,
                merkleProof,
                blockNumber: blockNumber,
                blockHash: blockHash,
            };
        });
    }
    getBlockTransactions(addresses, blockNumber, inputTxIds = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rpcProvider) {
                throw new Error("RPC provider not set");
            }
            let rawBlockHex = yield (0, tools_1.runWithRetries)(() => this.rpcProvider.getBlockByBlockNumber(blockNumber, 0), {
                maxTries: 10,
                retrySleep: 2000,
            });
            return (0, bitcoin_utils_1.extractTransactionsAndBlockInfoFromRawBlock)(rawBlockHex, blockNumber, addresses, inputTxIds, this.network);
        });
    }
    getMultipleBlocksTransactions(addresses, startBlockNumber, endBlockNumber, inputTxIds = []) {
        return __awaiter(this, void 0, void 0, function* () {
            let blockTxs = [];
            for (let blockNumber = +startBlockNumber + 1; blockNumber <= endBlockNumber; blockNumber += 1) {
                console.log(blockNumber);
                const response = yield this.getBlockTransactions(addresses, blockNumber, inputTxIds);
                blockTxs.push(response.withdrawTxs, response.depositTxs);
            }
            blockTxs = yield Promise.all(blockTxs);
            return blockTxs.flat(1);
        });
    }
}
exports.BitcoinInterface = BitcoinInterface;
exports.default = BitcoinInterface;
//# sourceMappingURL=bitcoin-interface.js.map