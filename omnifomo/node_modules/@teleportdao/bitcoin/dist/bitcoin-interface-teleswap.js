"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinInterfaceTeleswap = void 0;
const configs_1 = require("@teleportdao/configs");
const bitcoin_utils_1 = require("./bitcoin-utils");
const teleswap_helper_1 = require("./helper/teleswap-helper");
const bitcoin_interface_1 = __importDefault(require("./bitcoin-interface"));
class BitcoinInterfaceTeleswap extends bitcoin_interface_1.default {
    constructor(connectionInfo, networkName) {
        if (!connectionInfo.rpc) {
            throw new Error("rpc provider is required");
        }
        super(networkName, connectionInfo);
    }
    getHexBlockHeaders(startBlockNumber, endBlockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockHeaders = [];
            let difficulty = null;
            let hexBlockHeaders = "";
            let fromBlockNumber = startBlockNumber;
            for (let blockNumber = startBlockNumber; blockNumber <= endBlockNumber; blockNumber += 1) {
                let blockHeader = yield this.getBlockHeaderHex(blockNumber);
                console.log("block", blockNumber);
                let parsedBlockHeader = (0, bitcoin_utils_1.parseBlockHeader)(blockHeader);
                if (difficulty && parsedBlockHeader.difficulty !== difficulty) {
                    blockHeaders.push({
                        hexBlockHeaders,
                        fromBlockNumber,
                        toBlockNumber: blockNumber - 1,
                        difficulty,
                    });
                    hexBlockHeaders = blockHeader;
                    fromBlockNumber = blockNumber;
                }
                else {
                    hexBlockHeaders += blockHeader;
                }
                difficulty = parsedBlockHeader.difficulty;
            }
            if (hexBlockHeaders) {
                blockHeaders.push({
                    hexBlockHeaders,
                    fromBlockNumber,
                    toBlockNumber: endBlockNumber,
                    difficulty,
                });
            }
            return blockHeaders;
        });
    }
    getWrapRequests(addresses, startblockNumber, endBlockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactions = yield this.getMultipleBlocksTransactions(addresses, startblockNumber, endBlockNumber);
            let requests = [];
            let invalidRequests = [];
            for (let inputTx of transactions) {
                let { transaction, request, lockerAddress, lockerLockingScript } = yield this.getWrapRequestByTx(inputTx, inputTx.address);
                if (request.status && "data" in request && request.data) {
                    if (!configs_1.teleswap.requestAppId[request.data.requestType].appIds.includes(request.data.appId)) {
                        invalidRequests.push({
                            transaction,
                            request: Object.assign(Object.assign({}, request), { message: "invalid app id", code: "INVALID_APP_ID" }),
                            lockerAddress,
                            lockerLockingScript,
                        });
                    }
                    else {
                        requests.push({
                            transaction,
                            request,
                            lockerAddress,
                            lockerLockingScript,
                        });
                    }
                }
                else if (request.code !== "NO_OP_RETURN") {
                    invalidRequests.push({ transaction, request, lockerAddress, lockerLockingScript });
                }
            }
            return { requests, invalidRequests };
        });
    }
    getWrapRequestByTx(inputTransaction, lockerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let transaction;
            if ("vout" in inputTransaction && "blockNumber" in inputTransaction) {
                transaction = inputTransaction;
            }
            else {
                if (!inputTransaction.txId)
                    throw new Error("txId not exist");
                transaction = yield this.getTransaction(inputTransaction.txId);
            }
            let vout = transaction.vout;
            let request = (0, teleswap_helper_1.checkAndParseWrapRequest)(vout, lockerAddress);
            let lockerLockingScript = transaction.addressScript ||
                this.convertAddressToScript(lockerAddress).script.toString("hex");
            return {
                transaction,
                request,
                lockerAddress,
                lockerLockingScript,
            };
        });
    }
}
exports.BitcoinInterfaceTeleswap = BitcoinInterfaceTeleswap;
//# sourceMappingURL=bitcoin-interface-teleswap.js.map