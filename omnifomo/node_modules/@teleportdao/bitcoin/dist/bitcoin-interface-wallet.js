"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinInterfaceWallet = void 0;
const providers_1 = require("@teleportdao/providers");
const bitcoin_interface_utils_1 = require("./bitcoin-interface-utils");
class BitcoinInterfaceWallet extends bitcoin_interface_utils_1.BitcoinInterfaceUtils {
    constructor(networkName, connectionInfo) {
        var _a;
        super(networkName);
        if (((_a = connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.api) === null || _a === void 0 ? void 0 : _a.provider) === "BlockStream") {
            this.apiProvider = new providers_1.bitcoin.BlockStream(this.testnet);
        }
        else {
            this.apiProvider = new providers_1.bitcoin.MempoolSpace(this.testnet);
        }
        this.utxoProvider = (connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.utxo)
            ? providers_1.bitcoin.getUtxoProvider(connectionInfo.utxo, networkName)
            : this.apiProvider;
        if (connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.rpc)
            this.rpcProvider = providers_1.bitcoin.getRpcProvider(connectionInfo === null || connectionInfo === void 0 ? void 0 : connectionInfo.rpc);
    }
    getFeeRate(speed) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiProvider.getRecommendedFeeRate(speed);
        });
    }
    getUtxo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.utxoProvider.getUtxos(address);
        });
    }
    getExtendedUtxo(signerInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxos = yield this.getUtxo(signerInfo.address);
            return utxos.map((tx) => ({
                hash: tx.txId,
                value: tx.value,
                index: tx.index,
                signerInfo,
            }));
        });
    }
    getAddressesUtxo(allAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkOfAddresses = [];
            const chunkLength = 20;
            for (let i = 0; i < allAddresses.length; i += chunkLength) {
                const tmp = allAddresses.slice(i, i + chunkLength);
                chunkOfAddresses.push(tmp);
            }
            let results = [];
            for (let addresses of chunkOfAddresses) {
                const allPromises = [];
                for (let address of addresses) {
                    let promise = yield this.getUtxo(address);
                    allPromises.push(promise);
                }
                let result = yield Promise.all(allPromises);
                if (result.flat(1).length === 0) {
                    break;
                }
                results.push(result.flat(1));
            }
            return results.flat(1);
        });
    }
    getAddressesExtendedUtxo(signerInfos) {
        return __awaiter(this, void 0, void 0, function* () {
            const chunkOfAddresses = [];
            const chunkLength = 20;
            for (let i = 0; i < signerInfos.length; i += chunkLength) {
                const tmp = signerInfos.slice(i, i + chunkLength);
                chunkOfAddresses.push(tmp);
            }
            let results = [];
            for (let addresses of chunkOfAddresses) {
                const allPromises = [];
                for (let signerInfo of addresses) {
                    let promise = yield this.getExtendedUtxo(signerInfo);
                    allPromises.push(promise);
                }
                let result = yield Promise.all(allPromises);
                if (result.flat(1).length === 0) {
                    break;
                }
                results.push(result.flat(1));
            }
            return results.flat(1);
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxos = yield this.utxoProvider.getUtxos(address);
            return utxos.reduce((a, tx) => a + Number(tx.value), 0);
        });
    }
    getRawTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rpcProvider)
                return this.rpcProvider.getRawTransaction(txId);
            if (this.utxoProvider.getRawTransaction)
                return this.utxoProvider.getRawTransaction(txId);
            return this.apiProvider.getRawTransaction(txId);
        });
    }
    sendRawTransaction(txHex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rpcProvider)
                return this.rpcProvider.sendRawTransaction(txHex);
            if (this.utxoProvider.sendRawTransaction)
                return this.utxoProvider.sendRawTransaction(txHex);
            return this.apiProvider.sendRawTransaction(txHex);
        });
    }
}
exports.BitcoinInterfaceWallet = BitcoinInterfaceWallet;
exports.default = BitcoinInterfaceWallet;
//# sourceMappingURL=bitcoin-interface-wallet.js.map