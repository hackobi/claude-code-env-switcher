// not complete
import { AxiosInstance } from "axios"
import { getAxiosInstance } from "../utils/tools"
import type {
  FeeParamsResponse,
  SelectLockerResponse,
  SupportedNetwork,
  TeleportDaoLockers,
  GetUtxo,
  EvmNetworkRPC,
  AcrossFeeResponse,
  SupportedNetworkAll,
  WaitingTx,
  TeleportRequest,
} from "./types"
import { waitingRequestWrapper } from "./wrapper"

export class TeleportDao {
  api: AxiosInstance
  constructor(testnet = false) {
    const baseUrl = testnet
      ? "https://testnet.api.teleportdao.xyz/api"
      : "https://api.teleportdao.xyz/api"
    this.api = getAxiosInstance({
      baseUrl,
      headers: {},
      timeout: 1 * 60000,
    })
  }

  async getLockers(network?: string) {
    return (
      await this.api.get("/v1/teleswap/lockers", {
        params: {
          network,
        },
      })
    ).data.data.lockers as TeleportDaoLockers[]
  }

  async selectLocker(network: SupportedNetwork, amount: string, type: "wrap" | "unwrap") {
    const data = (
      await this.api.get(`/v1/teleswap/select-locker/${network}`, {
        params: {
          amount,
          type,
        },
      })
    ).data as SelectLockerResponse
    return data.data
  }

  async getAllFeeParams(network: SupportedNetwork) {
    const data = (await this.api.get(`/v1/teleswap/utils/fee-params/${network}`, {}))
      .data as FeeParamsResponse
    return data.data
  }

  async getUtxos(address: string) {
    const result: GetUtxo = (await this.api.get(`/v1/proxy/get-utxo/${address}`)).data
    const utxos = result.data
    return utxos
  }

  async getNetworkRpc() {
    const result: EvmNetworkRPC = (await this.api.get(`/v1/utils/get-evm-networks-rpc`)).data
    const networks = result.data
    return networks
  }

  async getAcrossFee(
    token: string,
    amount: string | number,
    destinationChainId: number,
    originChainId?: number,
    message?: string,
    recipient?: string,
  ) {
    const result: AcrossFeeResponse = (
      await this.api.get(`/v1/proxy/get-across-fee`, {
        params: {
          token,
          destinationChainId,
          amount,
          originChainId,
          message,
          recipient,
        },
      })
    ).data
    const networks = result.data
    return networks
  }

  async getRequests(
    userAddresses: string[],
    input?: {
      createdAtAfter?: string
      createdAtBefore?: string
      tokenType?: "BTC" | "Rune" | "BRC20"
      type?: "Wrap" | "Unwrap" | "WrapAndSwap" | "SwapAndUnwrap"
      tokenAddress?: string
      network?: SupportedNetworkAll
      filter?: "all" | "done" | "pending"
      thirdPartyId?: number

      limit?: number
      offset?: number
      order?: "asc" | "desc"
    },
  ) {
    if (userAddresses.length === 0) throw new Error("no address provided")
    const defaultConfig = { filter: "done", limit: 10, offset: 0 }
    const config = { ...defaultConfig, ...(input || {}) }
    const result: {
      data: TeleportRequest[]
    } = (
      await this.api.get(`/v2/teleswap/requests`, {
        params: config,
      })
    ).data
    return result.data
  }

  async getAllRequests(input?: {
    createdAtAfter?: string
    createdAtBefore?: string
    tokenType?: "BTC" | "Rune" | "BRC20"
    type?: "Wrap" | "Unwrap" | "WrapAndSwap" | "SwapAndUnwrap"
    tokenAddress?: string
    network?: SupportedNetworkAll
    filter?: "all" | "done" | "pending"
    thirdPartyId?: number

    limit?: number
    offset?: number
    order?: "asc" | "desc"
  }) {
    const defaultConfig = { filter: "done", limit: 10, offset: 0 }
    const config = { ...defaultConfig, ...(input || {}) }
    const result: {
      data: TeleportRequest[]
    } = (
      await this.api.get(`/v2/teleswap/requests`, {
        params: config,
      })
    ).data
    return result.data
  }

  async getWaitingRequests(
    address: string,
    {
      limit = 10,
      offset = 0,
    }: {
      limit?: number
      offset?: number
    },
  ) {
    const result: {
      data: WaitingTx[]
    } = (
      await this.api.get(`/v1/teleswap/cross-chain/waiting-request/${address}`, {
        params: {
          limit,
          offset,
        },
      })
    ).data
    return result.data.map((r) => waitingRequestWrapper(r))
  }

  async getRequestByTxId(txId: string) {
    const result: {
      data: TeleportRequest | null
    } = (await this.api.get(`/v2/teleswap/requests/tx/${txId}`)).data
    return result.data
  }

  async getWaitingRequestByTxId(txId: string) {
    const result: {
      data: WaitingTx | null
    } = (await this.api.get(`/v2/teleswap/requests/waiting/tx/${txId}`)).data
    return result.data ? waitingRequestWrapper(result.data) : null
  }

  async checkRequestStatusByTxId(txId: string) {
    let res = await this.getRequestByTxId(txId)
    if (!res) res = await this.getWaitingRequestByTxId(txId)
    return res
  }
}
