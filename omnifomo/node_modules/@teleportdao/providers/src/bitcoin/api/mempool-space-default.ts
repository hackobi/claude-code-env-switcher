import { AxiosInstance } from "axios"
import { getAxiosInstance, sleep } from "../../utils/tools"
import { ConfirmedTransaction, Utxo } from "../types"

class BlockStream {
  api: AxiosInstance
  constructor(baseUrl: string, headers?: any) {
    this.api = getAxiosInstance({
      baseUrl,
      headers,
    } as any)
  }

  async getOutspend(txId: string, index: number) {
    let response = await this.api.get(`/tx/${txId}/outspend/${index}`)
    return response.data
  }
  async getOutspends(txId: string) {
    let response = await this.api.get(`/tx/${txId}/outspends`)
    return response.data
  }

  async getLatestBlockNumber() {
    const result = await this.api.get(`/blocks/tip/height`)
    return result.data as number
  }

  async getBlockHash(blockNumber: number) {
    const result = await this.api.get(`/block-height/${blockNumber}`)
    return result.data as string
  }

  async getBlockHeaderHex(blockNumber: number) {
    const hash = await this.getBlockHash(blockNumber)
    const result = await this.api.get(`/block/${hash}/header`)
    return result.data as string
  }

  // --------------

  async getConfirmedTransactions(userAddress: string, lastReceivedTxId = "") {
    const result = await this.api.get(`/address/${userAddress}/txs/chain/${lastReceivedTxId}`)
    return result.data
  }

  async getMempoolTransactions(userAddress: string) {
    const result = await this.api.get(`/address/${userAddress}/txs/mempool`)
    return result.data
  }

  async getTransaction(txId: string): Promise<
    Omit<ConfirmedTransaction, "vin"> & {
      vin: {
        txId: string
        index: number
        address: string
        script: string
        value: number
      }[]
    }
  > {
    const result = await this.api.get(`/tx/${txId}`)
    let tx = result.data
    return {
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      blockTime: tx.status.block_time,
      blockNumber: tx.status.block_height || null,
      blockHash: tx.status.block_hash || null,
      vout: tx.vout.map((vo: any) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
      vin: tx.vin.map((vi: any) => ({
        txId: vi.txid,
        index: vi.vout,
        address: vi.prevout.scriptpubkey_address || null,
        script: vi.prevout.scriptpubkey,
        value: vi.prevout.value,
      })),
    }
  }

  async getRawTransaction(txId: string) {
    const result = await this.api.get(`/tx/${txId}/hex`)
    return result.data as string
  }

  async getTransactionHistory(userAddress: string, blockNumber = 0, lastSeenTxId = undefined) {
    let maximumTxsLength = 15
    // get transactions from lastSeenTxId to the end
    let fetchTxs = true
    let allResults = []
    let lastReceivedTxId = ""
    while (fetchTxs) {
      let result = await this.getConfirmedTransactions(userAddress, lastReceivedTxId)
      let lastSeenTxIdIndex = result.findIndex((tx: any) => tx.txid === lastSeenTxId)
      result = result.filter((_value: any) => +_value.status.block_height > blockNumber)
      result =
        lastSeenTxIdIndex < 0
          ? result
          : result.filter((_value: any, index: number) => index < lastSeenTxIdIndex)
      allResults.push(...result)
      lastReceivedTxId = result[result.length - 1]?.txid
      fetchTxs = result.length === maximumTxsLength && lastSeenTxIdIndex < 0 && result.length !== 0
    }

    return allResults.map((tx) => ({
      address: userAddress,
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      blockNumber: tx.status.block_height || null,
      blockHash: tx.status.block_hash || null,
      blockTime: tx.status.block_time || null,
      vout: tx.vout.map((vo: any) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
      vin: tx.vin.map((vi: any) => ({
        txId: vi.txid,
        index: vi.vout,
        address: vi.prevout.scriptpubkey_address || null,
        script: vi.prevout.scriptpubkey,
        value: vi.prevout.value,
      })),
    }))
  }

  async getMempoolTransactionHistory(userAddress: string) {
    let result = await this.getMempoolTransactions(userAddress)
    return result.map((tx: any) => ({
      address: userAddress,
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      vout: tx.vout.map((vo: any) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
      vin: tx.vin.map((vi: any) => ({
        txId: vi.txid,
        index: vi.vout,
        address: vi.prevout.scriptpubkey_address || null,
        script: vi.prevout.scriptpubkey,
        value: vi.prevout.value,
      })),
    }))
  }

  async getMempoolTransactionHistoryForMultipleAddresses(addresses: string[]) {
    const allPromises = []
    for (let address of addresses) {
      let promise = await this.getMempoolTransactionHistory(address)
      allPromises.push(promise)
    }
    let result = await Promise.all(allPromises)
    return result
  }

  async getTransactionHistoryForMultipleAddresses(userAddresses: string[], blockNumber = 0) {
    const allPromises = []
    for (let address of userAddresses) {
      let promise = await this.getTransactionHistory(address, blockNumber)
      allPromises.push(promise)
      await sleep(200)
    }
    let result = await Promise.all(allPromises)
    return result
  }

  async getUtxos(userAddress: string): Promise<Utxo[]> {
    const result = await this.api.get(`/address/${userAddress}/utxo`)
    return result.data.map((tx: any) => ({
      address: userAddress,
      txId: tx.txid,
      index: tx.vout,
      value: tx.value,
      blockNumber: tx.status?.block_height || undefined,
    }))
  }

  async getBalance(address: string) {
    let utxos = await this.getUtxos(address)
    return utxos.reduce((a: any, tx: any) => a + Number(tx.value), 0)
  }

  async getBlockTransactionIds(blockHash: string) {
    let result = await this.api.get(`/block/${blockHash}/txids`)
    return result.data
  }

  async getFeeRate(speed: "normal" | "slow" | "fast" = "normal") {
    let result = await this.api.get(`/fee-estimates`)
    let fees = {
      slow: +result.data[10],
      normal: +result.data[6],
      fast: +result.data[3],
    }
    return fees[speed] || fees.normal
  }

  async getRecommendedFeeRate(speed: "normal" | "slow" | "fast" = "normal") {
    let result = await this.api.get(`/v1/fees/recommended`)

    let fees = {
      slow: +result.data.economyFee,
      normal: +result.data.halfHourFee,
      fast: +result.data.fastestFee,
    }
    return fees[speed] || fees.normal
  }

  async sendRawTransaction(rawTransaction: string) {
    const result = await this.api.post(`/tx`, rawTransaction)
    return result.data as string
  }

  // not used

  async getMerkleProof(txId: string) {
    let result = (await this.api.get(`/tx/${txId}/merkle-proof`)).data
    let intermediateNodes = result.merkle.reduce(
      (a: any, merkle: any) => a + Buffer.from(merkle, "hex").reverse().toString("hex"),
      "0x",
    )
    let transactionIndex = result.pos
    return {
      intermediateNodes,
      transactionIndex,
    }
  }

  async getLatestBlock() {
    const result = await this.api.get(`/blocks`)
    // 10 newest blocks
    const blocks = result.data
    return blocks[0]
  }

  async getBlock(blockNumber: number) {
    const blockHash = await this.getBlockHash(blockNumber)
    const result = await this.api.get(`/block/${blockHash}`)
    return result.data
  }
}

export default BlockStream
