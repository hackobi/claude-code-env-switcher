type Details = Record<string, any> | null;
export interface Coin {
    id: string;
    slug: string;
    title: string;
    priceUSD: string;
    type: string;
}
export interface Event {
    targetTransaction: {
        txId: string;
    };
    name: string;
}
export interface SourceTransaction {
    txId: string;
}
export interface Network {
    id: string;
    name: string;
    title: string;
    lastBlock: string;
    chainId: number;
    status: string;
    details: Details;
}
export interface Token {
    id: string;
    contractAddress: string;
    name: string;
    symbol: string;
    type: string;
    coinId: string;
    networkId: string;
    decimal: number;
    status: string;
    details: Details;
    coin: Coin;
}
export type TeleportDaoLockers = {
    id: string;
    sourceAddress: string;
    sourceRescueAddress: string;
    targetAddress: string;
    networkId: string;
    addedAt: string;
    isScriptHash: boolean;
    TDTLockedAmount: string;
    nativeTokenLockedAmount: string;
    capacity: string;
    netMinted: string;
    slashingTeleBTCAmount: string;
    reservedNativeTokenForSlash: string;
    totalTeleBtcReceivedFee: string;
    healthFactor: number;
    totalPaidFee: string;
    totalBurn: string;
    status: string;
    details: {
        unwrapPriority: string;
        lockerLockingScript: string;
    };
    createdAt: string;
    updatedAt: string;
    network: Network;
};
export interface SelectLockerResponse {
    data: {
        preferred: TeleportDaoLockers;
        lockers: TeleportDaoLockers[];
    };
    success: boolean;
}
export interface FeeParamsResponse {
    data: {
        gasPrice: string;
        lastRelayBlockFeeWei: string;
        lockerPercentageFee: number | string;
        protocolPercentageFeeCCTransfer: number | string;
        protocolPercentageFeeCCExchange: number | string;
        protocolPercentageFeeCCBurn: number | string;
        burnBitcoinFeeSatoshi: number | string;
        gasUsedWrap: number | string;
        gasUsedWrapAndSwap: number | string;
        nativeTokenBTCRate: number | string;
    };
    success: boolean;
}
export interface GetUtxo {
    data: {
        address: string;
        txId: string;
        index: number;
        value: number;
        blockNumber: number;
    }[];
    success: boolean;
}
export interface EvmNetworkRPC {
    data: {
        bob: string;
        bsc: string;
        polygon: string;
        arbitrum: string;
        bsquared: string;
        ethereum: string;
        optimism: string;
        base: string;
    };
    success: boolean;
}
export interface AcrossFeeResponse {
    data: {
        estimatedFillTimeSec: number;
        capitalFeePct: string;
        capitalFeeTotal: string;
        relayGasFeePct: string;
        relayGasFeeTotal: string;
        relayFeePct: string;
        relayFeeTotal: string;
        lpFeePct: string;
        timestamp: string;
        isAmountTooLow: boolean;
        quoteBlock: string;
        exclusiveRelayer: string;
        exclusivityDeadline: number;
        spokePoolAddress: string;
        destinationSpokePoolAddress: string;
        totalRelayFee: {
            pct: string;
            total: string;
        };
        relayerCapitalFee: {
            pct: string;
            total: string;
        };
        relayerGasFee: {
            pct: string;
            total: string;
        };
        lpFee: {
            pct: string;
            total: string;
        };
        limits: {
            minDeposit: string;
            maxDeposit: string;
            maxDepositInstant: string;
            maxDepositShortDelay: string;
            recommendedDepositInstant: string;
        };
    };
    success: boolean;
}
export type SupportedNetworkTestnet = "bsc_testnet" | "polygon_testnet";
export type SupportedNetwork = "bsc" | "polygon" | "bsquared" | "bob";
export type CrossChainNetwork = "arbitrum" | "ethereum" | "optimism" | "base";
export type SupportedNetworkAll = SupportedNetwork | CrossChainNetwork;
export interface WaitingTx {
    id: string;
    originNetworkId: string;
    targetNetworkId: string;
    identifier: string;
    originEventId: string;
    targetEventId: string;
    connectorContractId: string;
    events: string[];
    userTargetAddress: string;
    userSourceAddress: string;
    inputTokenContractId: string;
    inputTokenAmount: string;
    inputTokenRemainingAmount: string;
    inputTokenAmountUSD: string;
    outputTokenContractId: string;
    outputTokenAmount: string;
    outputTokenRemainingAmount: string;
    outputTokenAmountUSD: string;
    status: string;
    details: Details;
    createdAt: string;
    updatedAt: string;
    tokenType: string | undefined;
    type: string;
    originNetwork: Network;
    targetNetwork: Network;
    inputToken: Token;
    outputToken: Token;
    targetEvent: Event;
    originEvent: Event;
}
export interface TeleportRequest {
    id: string;
    fromNetworkId: string;
    fromAddress: string;
    inputTokenContractId: string;
    inputTokenAmount: string;
    inputTokenAmountUSD: string;
    toNetworkId: string;
    outputTokenContractId: string;
    outputTokenAmount: string;
    outputTokenAmountUSD: string;
    toAddress: string;
    networkFee: string;
    lockerFee: string;
    protocolFee: string;
    thirdPartyFee: string;
    bridgeFee: string;
    totalFee: string;
    crossChainId: string | null;
    thirdPartyId: number;
    tokenType: string;
    type: string;
    status: string;
    state: string;
    createdAt: string;
    updatedAt: string;
    fromNetwork: Network;
    toNetwork: Network;
    inputToken: Token;
    outputToken: Token;
    sourceTransactionId: number | null;
    lockerId: string | null;
    sourceTransaction: SourceTransaction | null;
    targetEvent: Event | null;
    targetEventId: string | null;
}
export {};
//# sourceMappingURL=types.d.ts.map