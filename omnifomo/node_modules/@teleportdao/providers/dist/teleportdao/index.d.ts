import { AxiosInstance } from "axios";
import type { SupportedNetwork, TeleportDaoLockers, SupportedNetworkAll, TeleportRequest } from "./types";
export declare class TeleportDao {
    api: AxiosInstance;
    constructor(testnet?: boolean);
    getLockers(network?: string): Promise<TeleportDaoLockers[]>;
    selectLocker(network: SupportedNetwork, amount: string, type: "wrap" | "unwrap"): Promise<{
        preferred: TeleportDaoLockers;
        lockers: TeleportDaoLockers[];
    }>;
    getAllFeeParams(network: SupportedNetwork): Promise<{
        gasPrice: string;
        lastRelayBlockFeeWei: string;
        lockerPercentageFee: string | number;
        protocolPercentageFeeCCTransfer: string | number;
        protocolPercentageFeeCCExchange: string | number;
        protocolPercentageFeeCCBurn: string | number;
        burnBitcoinFeeSatoshi: string | number;
        gasUsedWrap: string | number;
        gasUsedWrapAndSwap: string | number;
        nativeTokenBTCRate: string | number;
    }>;
    getUtxos(address: string): Promise<{
        address: string;
        txId: string;
        index: number;
        value: number;
        blockNumber: number;
    }[]>;
    getNetworkRpc(): Promise<{
        bob: string;
        bsc: string;
        polygon: string;
        arbitrum: string;
        bsquared: string;
        ethereum: string;
        optimism: string;
        base: string;
    }>;
    getAcrossFee(token: string, amount: string | number, destinationChainId: number, originChainId?: number, message?: string, recipient?: string): Promise<{
        estimatedFillTimeSec: number;
        capitalFeePct: string;
        capitalFeeTotal: string;
        relayGasFeePct: string;
        relayGasFeeTotal: string;
        relayFeePct: string;
        relayFeeTotal: string;
        lpFeePct: string;
        timestamp: string;
        isAmountTooLow: boolean;
        quoteBlock: string;
        exclusiveRelayer: string;
        exclusivityDeadline: number;
        spokePoolAddress: string;
        destinationSpokePoolAddress: string;
        totalRelayFee: {
            pct: string;
            total: string;
        };
        relayerCapitalFee: {
            pct: string;
            total: string;
        };
        relayerGasFee: {
            pct: string;
            total: string;
        };
        lpFee: {
            pct: string;
            total: string;
        };
        limits: {
            minDeposit: string;
            maxDeposit: string;
            maxDepositInstant: string;
            maxDepositShortDelay: string;
            recommendedDepositInstant: string;
        };
    }>;
    getRequests(userAddresses: string[], input?: {
        createdAtAfter?: string;
        createdAtBefore?: string;
        tokenType?: "BTC" | "Rune" | "BRC20";
        type?: "Wrap" | "Unwrap" | "WrapAndSwap" | "SwapAndUnwrap";
        tokenAddress?: string;
        network?: SupportedNetworkAll;
        filter?: "all" | "done" | "pending";
        thirdPartyId?: number;
        limit?: number;
        offset?: number;
        order?: "asc" | "desc";
    }): Promise<TeleportRequest[]>;
    getAllRequests(input?: {
        createdAtAfter?: string;
        createdAtBefore?: string;
        tokenType?: "BTC" | "Rune" | "BRC20";
        type?: "Wrap" | "Unwrap" | "WrapAndSwap" | "SwapAndUnwrap";
        tokenAddress?: string;
        network?: SupportedNetworkAll;
        filter?: "all" | "done" | "pending";
        thirdPartyId?: number;
        limit?: number;
        offset?: number;
        order?: "asc" | "desc";
    }): Promise<TeleportRequest[]>;
    getWaitingRequests(address: string, { limit, offset, }: {
        limit?: number;
        offset?: number;
    }): Promise<TeleportRequest[]>;
    getRequestByTxId(txId: string): Promise<TeleportRequest | null>;
    getWaitingRequestByTxId(txId: string): Promise<TeleportRequest | null>;
    checkRequestStatusByTxId(txId: string): Promise<TeleportRequest | null>;
}
//# sourceMappingURL=index.d.ts.map