"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tools_1 = require("../../utils/tools");
class BitcoinRPC {
    constructor({ headers = {}, url: baseUrl, auth, }) {
        this.axios = BitcoinRPC.getAxiosInstance({
            baseUrl,
            headers,
            auth,
            timeout: 3 * 60000,
        });
    }
    static getAxiosInstance(provider) {
        return (0, tools_1.getAxiosInstance)(provider);
    }
    static getRpcBody(method, params = []) {
        return {
            jsonrpc: "2.0",
            id: "teleport-dao",
            method,
            params,
        };
    }
    getChainInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getblockchaininfo"));
            return response.data.result;
        });
    }
    getLatestBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getblockcount"));
            return response.data.result;
        });
    }
    getBlockHash(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getblockhash", [+blockNumber]));
            return response.data.result;
        });
    }
    getBlockByBlockHash(blockHash, verbosity = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getblock", [blockHash, Number(verbosity)]), {
                headers: {
                    "Content-Type": "application/json",
                },
            });
            return response.data.result;
        });
    }
    getBlockHeaderByBlockHash(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getblockheader", [blockHash, false]));
            return response.data.result;
        });
    }
    getBlockByBlockNumber(blockNumber, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getBlockByBlockHash(yield this.getBlockHash(blockNumber), verbosity);
        });
    }
    getTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getrawtransaction", [txId, true]));
            let tx = response.data.result;
            if (!tx)
                throw new Error(`bitcoin transaction ${txId} not found`);
            let block = tx.blockhash ? yield this.getBlockByBlockHash(tx.blockhash) : {};
            return {
                txId: tx.txid,
                version: tx.version,
                locktime: tx.locktime,
                blockNumber: block.height || null,
                blockHash: tx.blockhash || null,
                vout: tx.vout.map((vo) => ({
                    address: vo.scriptPubKey.address || null,
                    script: vo.scriptPubKey.hex,
                    value: Number((Number(vo.value) * 1e8).toFixed()),
                })),
                vin: tx.vin.map((vi) => ({
                    txId: vi.txid,
                    index: vi.vout,
                })),
            };
        });
    }
    getRawTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("getrawtransaction", [txId, true]));
            return response.data.result.hex;
        });
    }
    getTxOutProof(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("gettxoutproof", [txId, true]));
            return response.data.result.hex;
        });
    }
    getBlockTransactionIds(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let block = yield this.getBlockByBlockHash(blockHash);
            return block.tx;
        });
    }
    sendRawTransaction(txHex, maxFeeRate = 0.1) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("sendrawtransaction", [txHex, maxFeeRate]));
            return response.data.result;
        });
    }
    getBlockHeaderHex(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = yield this.getBlockHash(blockNumber);
            const result = yield this.getBlockHeaderByBlockHash(hash);
            return result;
        });
    }
    getEstimateFeeByNumberOfBlock(n) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post("/", BitcoinRPC.getRpcBody("estimatesmartfee", [n, "ECONOMICAL"]));
            return response.data.result.feerate * Math.pow(10, 5);
        });
    }
    getFeeRate(speed = "normal") {
        return __awaiter(this, void 0, void 0, function* () {
            let fee;
            switch (speed) {
                case "slow":
                    fee = yield this.getEstimateFeeByNumberOfBlock(10);
                    break;
                case "normal":
                    fee = yield this.getEstimateFeeByNumberOfBlock(6);
                    break;
                case "fast":
                    fee = yield this.getEstimateFeeByNumberOfBlock(3);
                    break;
                default:
                    fee = yield this.getEstimateFeeByNumberOfBlock(6);
                    break;
            }
            return +fee.toFixed();
        });
    }
}
exports.default = BitcoinRPC;
//# sourceMappingURL=bitcoin-rpc.js.map